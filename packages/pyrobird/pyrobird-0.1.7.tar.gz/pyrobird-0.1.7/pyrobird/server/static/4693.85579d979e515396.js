"use strict";(self.webpackChunkfirebird=self.webpackChunkfirebird||[]).push([[4693],{4693:(R,G,w)=>{w.r(G),w.d(G,{TGraphPainter:()=>T,clTGraphAsymmErrors:()=>O});var $=w(467),_=w(6998),F=w(5680),E=w(9041),z=w(675),Y=w(2953),X=w(8732),L=w(5359),H=w(6714),D=w(6370);const A=(0,_.BIT)(18),C="TGraphErrors",O="TGraphAsymmErrors",N="TGraphBentErrors",B="TGraphMultiErrors";class T extends z.JW{constructor(t,i){super(t,i),this.axes_draw=!1,this.bins=null,this.xmin=this.ymin=this.xmax=this.ymax=0,this.wheel_zoomy=!0,this.is_bent=i._typename===N,this.has_errors=i._typename===C||i._typename===B||i._typename===O||this.is_bent||i._typename.match(/^RooHist/)}getGraph(){return this.getObject()}getHistogram(){return this.getObject()?.fHistogram}setHistogram(t){const i=this.getObject();i&&(i.fHistogram=t)}redraw(){var t=this;return(0,$.A)(function*(){let i=Promise.resolve(!0);if(t.$redraw_hist){delete t.$redraw_hist;const s=t.getMainPainter();s?.$secondary&&t.axes_draw&&(i=s.redraw())}return i.then(()=>t.drawGraph())})()}cleanup(){delete this.interactive_bin,delete this.bins,super.cleanup()}get_gme(){const t=this.getGraph();return t?._typename===B?t:null}decodeOptions(t,i){(0,_.isStr)(t)&&0===t.indexOf("same ")&&(t=t.slice(5));const s=this.getGraph(),a=!!this.get_gme(),n=i?!!this.getMainPainter():!this.axes_draw;let h=[];this.options||(this.options={});const g=(o,c)=>{Object.assign(c,{Line:0,Curve:0,Rect:0,Mark:0,Bar:0,OutRange:0,EF:0,Fill:0,MainError:1,Ends:1,ScaleErrX:1}),a&&o.check("S=",!0)&&(c.ScaleErrX=o.partAsFloat()),o.check("L")&&(c.Line=1),o.check("F")&&(c.Fill=1),o.check("CC")&&(c.Curve=2),o.check("C")&&(c.Curve=1),o.check("*")&&(c.Mark=103),o.check("P0")&&(c.Mark=104),o.check("P")&&(c.Mark=1),o.check("B")&&(c.Bar=1,c.Errors=0),o.check("Z")&&(c.Errors=1,c.Ends=0),o.check("||")&&(c.Errors=1,c.MainError=0,c.Ends=1),o.check("[]")&&(c.Errors=1,c.MainError=0,c.Ends=2),o.check("|>")&&(c.Errors=1,c.Ends=3),o.check(">")&&(c.Errors=1,c.Ends=4),o.check("0")&&(c.Mark=1,c.Errors=1,c.OutRange=1),o.check("1")&&1===c.Bar&&(c.Bar=2),o.check("2")&&(c.Rect=1,c.Errors=0),o.check("3")&&(c.EF=1,c.Errors=0),o.check("4")&&(c.EF=2,c.Errors=0),o.check("5")&&(c.Rect=2,c.Errors=0),o.check("X")&&(c.Errors=0)};Object.assign(this.options,{Axis:"",NoOpt:0,PadStats:!1,PadPalette:!1,original:t,second_x:!1,second_y:!1,individual_styles:!1}),a&&t&&(t.indexOf(";")>0?(h=t.split(";"),t=h.shift()):t.indexOf("_")>0&&(h=t.split("_"),t=h.shift()));const r=this.options;let x=new E.nC(t);r.PadStats=x.check("USE_PAD_STATS"),r.PadPalette=x.check("USE_PAD_PALETTE");let d="";if(Y.c.forEach(o=>{x.check(o)&&(d+=";"+o)}),x.check("XAXIS_",!0)&&(d+=";XAXIS_"+x.part),x.check("YAXIS_",!0)&&(d+=";YAXIS_"+x.part),x.empty()&&(r.original=n?"lp":"alp",x=new E.nC(r.original)),x.check("NOOPT")&&(r.NoOpt=1),x.check("POS3D_",!0)&&(r.pos3d=x.partAsInt()-.5),r._pfc=x.check("PFC"),r._plc=x.check("PLC"),r._pmc=x.check("PMC"),x.check("A")&&(r.Axis=x.check("I")?"A":"AXIS;"),x.check("X+")&&(r.Axis+="X+",r.second_x=n),x.check("Y+")&&(r.Axis+="Y+",r.second_y=n),x.check("RX")&&(r.Axis+="RX"),x.check("RY")&&(r.Axis+="RY"),a&&(r.blocks=[],r.skip_errors_x0=r.skip_errors_y0=!1,x.check("X0")&&(r.skip_errors_x0=!0),x.check("Y0")&&(r.skip_errors_y0=!0)),g(x,r),a&&x.check("S")&&(r.individual_styles=!0),void 0===r.Errors&&(r.Errors=!this.has_errors||a&&h.length?0:1),1===r.Mark&&1===s.fMarkerStyle&&(r.Mark=101),r.Line+r.Fill+r.Curve+r.Mark+r.Bar+r.EF+r.Rect+r.Errors===0&&x.empty()&&(r.Line=1),this.matchObjectType(C)){const o=s.fEX.length;let c=0;for(let e=0;e<o;++e)c=Math.max(c,s.fEX[e],s.fEY[e]);c<1e-100&&(r.Errors=0)}if(this._cutg=this.matchObjectType(_.clTCutG),this._cutg_lastsame=this._cutg&&s.fNpoints>3&&s.fX[0]===s.fX[s.fNpoints-1]&&s.fY[0]===s.fY[s.fNpoints-1],r.Axis)r.Axis.indexOf("A")<0&&(r.Axis="AXIS;"+r.Axis);else{const o=this.getPadPainter()?.getRootPad(!0);(!o||o?.fPrimitives?.arr[0]===this.getObject())&&(r.Axis="AXIS;")}r.Axis+=d;for(let o=0;o<h.length;++o){const e={};g(new E.nC(h[o]),e),e.skip_errors_x0=r.skip_errors_x0,e.skip_errors_y0=r.skip_errors_y0,r.blocks.push(e)}}extractGmeErrors(t){if(!this.bins)return;const i=this.getGraph();this.bins.forEach(s=>{s.eylow=i.fEyL[t][s.indx],s.eyhigh=i.fEyH[t][s.indx]})}createBins(){const t=this.getGraph();if(!t)return;let i=0,s=t.fNpoints;this._cutg&&this._cutg_lastsame&&s--,t._typename===C?i=1:t._typename===B?i=2:(t._typename===O||t._typename===N||t._typename.match(/^RooHist/))&&(i=3),this.bins=new Array(s);for(let a=0;a<s;++a){const n=this.bins[a]={x:t.fX[a],y:t.fY[a],indx:a};switch(i){case 1:n.exlow=n.exhigh=t.fEX[a],n.eylow=n.eyhigh=t.fEY[a];break;case 2:n.exlow=t.fExL[a],n.exhigh=t.fExH[a],n.eylow=t.fEyL[0][a],n.eyhigh=t.fEyH[0][a];break;case 3:n.exlow=t.fEXlow[a],n.exhigh=t.fEXhigh[a],n.eylow=t.fEYlow[a],n.eyhigh=t.fEYhigh[a]}0===a&&(this.xmin=this.xmax=n.x,this.ymin=this.ymax=n.y),i>0?(this.xmin=Math.min(this.xmin,n.x-n.exlow,n.x+n.exhigh),this.xmax=Math.max(this.xmax,n.x-n.exlow,n.x+n.exhigh),this.ymin=Math.min(this.ymin,n.y-n.eylow,n.y+n.eyhigh),this.ymax=Math.max(this.ymax,n.y-n.eylow,n.y+n.eyhigh)):(this.xmin=Math.min(this.xmin,n.x),this.xmax=Math.max(this.xmax,n.x),this.ymin=Math.min(this.ymin,n.y),this.ymax=Math.max(this.ymax,n.y))}}getHistRangeMargin(){return.1}createHistogram(t,i){!t&&!i&&(t=i=!0);const s=this.getGraph(),a=this.xmin,n=this.getHistRangeMargin();let h=this.xmax,g=this.ymin,r=this.ymax;a>=h&&(h=a+1),g>=r&&(r=g+1);const x=(h-a)*n,d=(r-g)*n;let o=a-x,c=h+x,e=g-d,l=r+d;this._not_adjust_hrange||(o<0&&a>=0&&(o=a*(1-n)),c>0&&h<=0&&(c=0));const y=e,m=l;let f=this.getHistogram();return f?f.fMaximum!==_.kNoZoom&&f.fMinimum!==_.kNoZoom&&(e=f.fMinimum,l=f.fMaximum):(f=this._need_2dhist?(0,_.createHistogram)(_.clTH2I,30,30):(0,_.createHistogram)(_.clTH1I,100),f.fName=s.fName+"_h",f.fBits|=_.kNoStats,this._own_histogram=!0,this.setHistogram(f)),s.fMinimum!==_.kNoZoom&&(e=g=s.fMinimum),s.fMaximum!==_.kNoZoom&&(l=s.fMaximum),e<0&&g>=0&&(e=(1-n)*g),(0,_.setHistogramTitle)(f,this.getObject().fTitle),t&&(f.fXaxis.fXmin=o,f.fXaxis.fXmax=c),i&&(f.fYaxis.fXmin=Math.min(y,e),f.fYaxis.fXmax=Math.max(m,l),f.fMinimum=e,f.fMaximum=l),f}unzoomUserRange(t,i){const s=this.getGraph();if(this._own_histogram||!s)return!1;const a=this.getHistogram();return i=i&&a&&(a.fYaxis.fXmin>this.ymin||a.fYaxis.fXmax<this.ymax),!(!(t=t&&a&&(a.fXaxis.fXmin>this.xmin||a.fXaxis.fXmax<this.xmax))&&!i||(this.createHistogram(t,i),this.getMainPainter()?.extractAxesProperties(1),0))}canOptimize(){return _.settings.OptimizeDraw>0&&!this.options.NoOpt}optimizeBins(t,i){if(this.bins.length<30&&!i)return this.bins;let s=null;if((0,_.isFunc)(i))for(let h=0;h<this.bins.length;++h)i(this.bins[h],h)?s||(s=0===h?[]:this.bins.slice(0,h)):s&&s.push(this.bins[h]);if(s||(s=this.bins),t||(t=5e5),s.length<t||!this.canOptimize())return s;let a=Math.floor(s.length/t);a<2&&(a=2);const n=[];for(let h=0;h<s.length;h+=a)n.push(s[h]);return n}getTooltips(t){const s=[],a=this.get_main().getGrFuncs(this.options.second_x,this.options.second_y),n=this.get_gme();if(s.push(this.getObjectHint()),t&&a)if(void 0!==t.indx&&s.push("p = "+t.indx),s.push("x = "+a.axisAsText("x",t.x),"y = "+a.axisAsText("y",t.y)),n?s.push("error x = -"+a.axisAsText("x",n.fExL[t.indx])+"/+"+a.axisAsText("x",n.fExH[t.indx])):this.options.Errors&&"normal"===a.x_handle.kind&&(t.exlow||t.exhigh)&&s.push("error x = -"+a.axisAsText("x",t.exlow)+"/+"+a.axisAsText("x",t.exhigh)),n)for(let h=0;h<n.fNYErrors;++h)s.push(`error y${h} = -${a.axisAsText("y",n.fEyL[h][t.indx])}/+${a.axisAsText("y",n.fEyH[h][t.indx])}`);else(this.options.Errors||this.options.EF>0)&&"normal"===a.y_handle.kind&&(t.eylow||t.eyhigh)&&s.push("error y = -"+a.axisAsText("y",t.eylow)+"/+"+a.axisAsText("y",t.eyhigh));return s}get_main(){let t=this.getFramePainter();if(t?.grx&&t?.gry)return t;const i=this.getPadPainter(),s=i?.getPadRect()||{width:800,height:600};return t={pad_layer:!0,pad:i?.getRootPad(!0),pw:s.width,ph:s.height,fX1NDC:.1,fX2NDC:.9,fY1NDC:.1,fY2NDC:.9,getFrameWidth(){return this.pw},getFrameHeight(){return this.ph},grx(a){return(a=this.pad.fLogx?a>0?Math.log10(a):this.pad.fUxmin:(a-this.pad.fX1)/(this.pad.fX2-this.pad.fX1))*this.pw},gry(a){return(1-(a=this.pad.fLogy?a>0?Math.log10(a):this.pad.fUymin:(a-this.pad.fY1)/(this.pad.fY2-this.pad.fY1)))*this.ph},revertAxis(a,n){return"x"===a?n/this.pw*(this.pad.fX2-this.pad.fX1)+this.pad.fX1:"y"===a?(1-n/this.ph)*(this.pad.fY2-this.pad.fY1)+this.pad.fY1:n},getGrFuncs(){return this}},t.pad?t:null}appendExclusion(t,i,s,a){const n=[];for(let g=s.length-1;g>=0;--g){const r=s[g],x=Math.sqrt(r.dgrx**2+r.dgry**2);x>1e-10&&(r.grx+=a*r.dgry/x,r.gry-=a*r.dgrx/x),n.push(r)}const h=(0,E.Mw)(n,{cmd:"L",line:!t});this.draw_g.append("svg:path").attr("d",i+h+"Z").call(this.fillatt.func).style("opacity",.75)}drawBins(t,i,s,a,n,h,g,r){const x=this.getGraph();if(!x?.fNpoints)return;let d=0,o=null;if(r&&h.excl_side&&(d=h.excl_width,h.width>0&&!i.Line&&!i.Curve&&(i.Line=1)),i.EF){o=this.optimizeBins(i.EF>1?2e4:0);for(let m=0;m<o.length;++m){const f=o[m];f.grx=t.grx(f.x),f.gry=t.gry(f.y-f.eylow)}const e=(0,E.Mw)(o,{line:i.EF<2,qubic:!0}),l=[];for(let m=o.length-1;m>=0;--m){const f=o[m];f.gry=t.gry(f.y+f.eyhigh),l.push(f)}const y=(0,E.Mw)(l,{line:i.EF<2,cmd:"L",qubic:!0});s.append("svg:path").attr("d",e+y+"Z").call(g.func),r&&(this.draw_kind="lines")}if(i.Line||i.Fill){let e="";this._cutg&&(e="Z",i.original||(i.Fill=1)),i.Fill&&(e="Z",d=0),o||(o=this.optimizeBins(0));for(let m=0;m<o.length;++m){const f=o[m];f.grx=t.grx(f.x),f.gry=t.gry(f.y)}const l=(0,E.Mw)(o,{line:!0,calc:d});d&&this.appendExclusion(!1,l,o,d);const y=s.append("svg:path").attr("d",l+e);i.Line&&y.call(h.func),i.Fill?y.call(g.func):y.style("fill","none"),r&&(this.draw_kind="lines")}if(i.Curve){let e=o;if("lines"!==this.draw_kind||!e||1===i.Curve&&e.length>2e4){e=this.optimizeBins(1===i.Curve?2e4:0);for(let y=0;y<e.length;++y){const m=e[y];m.grx=t.grx(m.x),m.gry=t.gry(m.y)}}const l=(0,E.Mw)(e,{qubic:!d});d&&this.appendExclusion(!0,l,e,d),s.append("svg:path").attr("d",l).call(h.func).style("fill","none"),r&&(this.draw_kind="lines")}let c=null;if((i.Errors||i.Rect||i.Bar)&&(o=this.optimizeBins(5e3,(e,l)=>{const y=t.grx(e.x);if(!i.Bar&&(y<0||y>a))return!0;const m=t.gry(e.y);return!i.Bar&&!i.OutRange&&(m<0||m>n)||(e.grx1=Math.round(y),e.gry1=Math.round(m),this.has_errors&&(e.grx0=Math.round(t.grx(e.x-i.ScaleErrX*e.exlow)-y),e.grx2=Math.round(t.grx(e.x+i.ScaleErrX*e.exhigh)-y),e.gry0=Math.round(t.gry(e.y-e.eylow)-m),e.gry2=Math.round(t.gry(e.y+e.eyhigh)-m),this.is_bent?(e.grdx0=Math.round(t.gry(e.y+x.fEXlowd[l])-m),e.grdx2=Math.round(t.gry(e.y+x.fEXhighd[l])-m),e.grdy0=Math.round(t.grx(e.x+x.fEYlowd[l])-y),e.grdy2=Math.round(t.grx(e.x+x.fEYhighd[l])-y)):e.grdx0=e.grdx2=e.grdy0=e.grdy2=0),!1)}),r&&(this.draw_kind="nodes"),c=s.selectAll(".grpoint").data(o).enter().append("svg:g").attr("class","grpoint").attr("transform",e=>(0,E.bk)(e.grx1,e.gry1))),i.Bar){let e=0,l=0;for(let f=0;f<o.length;++f)0===f?e=l=o[f].grx1:(e=Math.min(e,o[f].grx1),l=Math.max(l,o[f].grx1));if(1===o.length)o[0].width=a/4;else for(let f=0;f<o.length;++f)o[f].width=(l-e)/o.length*_.gStyle.fBarWidth;const y=Math.round(t.gry(0));let m=g;if(r){const f=this.getFramePainter(),p=f?.fillatt?.empty()?-1:f.fillatt.getFillColor();p===g.getFillColor()&&(m=new L.n({color:"white"===p?1:0,pattern:1001}))}c.append("svg:path").attr("d",f=>{f.bar=!0;const p=f.width>1?Math.round(-f.width/2):0,M=f.width>1?Math.round(f.width):1;return`M${p},${1!==i.Bar?0:f.gry1>y?y-f.gry1:0}h${M}v${1!==i.Bar?n>f.gry1?n-f.gry1:0:Math.abs(y-f.gry1)}h${-M}z`}).call(m.func)}if(i.Rect&&c.filter(e=>e.exlow>0&&e.exhigh>0&&e.eylow>0&&e.eyhigh>0).append("svg:path").attr("d",e=>(e.rect=!0,`M${e.grx0},${e.gry0}H${e.grx2}V${e.gry2}H${e.grx0}Z`)).call(g.func).call(2===i.Rect?h.func:()=>{}),this.error_size=0,i.Errors){let e=h.width+_.gStyle.fEndErrorSize,l=0;const y=i.Ends?`m0,${e}v${-2*e}`:"",m=i.Ends?`m${e},0h${-2*e}`:"";let f=y,p=y,M=m,b=m;const k=(u,P)=>{if(!i.MainError)return`M${u},${P}`;const S="M0,0";return u?S+(P?`L${u},${P}`:`H${u}`):P?S+`V${P}`:S};switch(i.Ends){case 2:l=Math.max(h.width+1,Math.round(.66*e)),f=`m${l},${e}h${-l}v${-2*e}h${l}`,p=`m${-l},${e}h${l}v${-2*e}h${-l}`,M=`m${-e},${l}v${-l}h${2*e}v${l}`,b=`m${-e},${-l}v${l}h${2*e}v${-l}`;break;case 3:e=Math.max(e,Math.round(8*x.fMarkerSize*.66)),l=Math.max(h.width+1,Math.round(.66*e)),f=`l${l},${e}v${-2*e}l${-l},${e}`,p=`l${-l},${e}v${-2*e}l${l},${e}`,M=`l${-e},${l}h${2*e}l${-e},${-l}`,b=`l${-e},${-l}h${2*e}l${-e},${l}`;break;case 4:e=Math.max(e,Math.round(8*x.fMarkerSize*.66)),l=Math.max(h.width+1,Math.round(.66*e)),f=`l${l},${e}m0,${-2*e}l${-l},${e}`,p=`l${-l},${e}m0,${-2*e}l${l},${e}`,M=`l${-e},${l}m${2*e},0l${-e},${-l}`,b=`l${-e},${-l}m${2*e},0l${-e},${l}`}this.error_size=e,e=Math.floor((h.width-1)/2);let v=c.filter(u=>u.exlow>0||u.exhigh>0||u.eylow>0||u.eyhigh>0);(i.skip_errors_x0||i.skip_errors_y0)&&(v=v.filter(u=>!(0===u.x&&i.skip_errors_x0||0===u.y&&i.skip_errors_y0))),!this.isBatchMode()&&_.settings.Tooltip&&r&&v.append("svg:path").style("fill","none").style("pointer-events","visibleFill").attr("d",u=>`M${u.grx0},${u.gry0}h${u.grx2-u.grx0}v${u.gry2-u.gry0}h${u.grx0-u.grx2}z`),v.append("svg:path").call(h.func).style("fill","none").attr("d",u=>(u.error=!0,(u.exlow>0?k(u.grx0+e,u.grdx0)+f:"")+(u.exhigh>0?k(u.grx2-e,u.grdx2)+p:"")+(u.eylow>0?k(u.grdy0,u.gry0-e)+b:"")+(u.eyhigh>0?k(u.grdy2,u.gry2+e)+M:"")))}if(i.Mark){this.createAttMarker({attr:x,style:i.Mark-100}),this.marker_size=this.markeratt.getFullSize(),this.markeratt.resetPos();const e=!this.isBatchMode()&&_.settings.Tooltip&&(!this.markeratt.fill||this.marker_size<7)&&!c&&r,l=Math.max(5,Math.round(.7*this.marker_size)),y=1e6/(this.markeratt.getMarkerLength()+7);let f,p,M,m="",b="",k=1;o?this.canOptimize()&&o.length>1.5*y&&(k=Math.min(2,Math.round(o.length/y))):o=this.optimizeBins(y);for(let v=0;v<o.length;v+=k)f=o[v],p=t.grx(f.x),p>-this.marker_size&&p<a+this.marker_size&&(M=t.gry(f.y),M>-this.marker_size&&M<n+this.marker_size&&(m+=this.markeratt.create(p,M),e&&(b+=`M${p-l},${M-l}h${2*l}v${2*l}h${-2*l}z`)));m&&(s.append("svg:path").attr("d",m).call(this.markeratt.func),null===c&&"none"===this.draw_kind&&r&&(this.draw_kind=101===i.Mark?"path":"mark")),e&&b&&s.append("svg:path").attr("d",b).style("fill","none").style("pointer-events","visibleFill")}}appendQQ(t,i){const s=Math.max(t.scale_xmin,i.fXq1),a=Math.min(t.scale_xmax,i.fXq2),n=Math.max(t.scale_ymin,i.fYq1),h=Math.min(t.scale_ymax,i.fYq2),g=(e,l,y,m)=>`M${t.grx(e)},${t.gry(l)}L${t.grx(y)},${t.gry(m)}`,r=(i.fYq2-i.fYq1)*(t.scale_xmin-i.fXq1)/(i.fXq2-i.fXq1)+i.fYq1,x=(i.fYq2-i.fYq1)*(t.scale_xmax-i.fXq1)/(i.fXq2-i.fXq1)+i.fYq1;let d="";d=r<t.scale_ymin?g((i.fXq2-i.fXq1)*(t.scale_ymin-i.fYq1)/(i.fYq2-i.fYq1)+i.fXq1,t.scale_ymin,s,n):g(t.scale_xmin,r,s,n),d+=x>t.scale_ymax?g(a,h,(i.fXq2-i.fXq1)*(t.scale_ymax-i.fYq1)/(i.fYq2-i.fYq1)+i.fXq1,t.scale_ymax):g(a,h,t.scale_xmax,x);const o=new X.gx({style:1,width:1,color:"black"}),c=new X.gx({style:2,width:1,color:"black"});this.draw_g.append("path").attr("d",g(s,n,a,h)).call(o.func).style("fill","none"),this.draw_g.append("path").attr("d",d).call(c.func).style("fill","none")}drawBins3D(){console.log("Load ./hist/TGraphPainter.mjs to draw graph in 3D")}drawGraph(){const t=this.get_main(),i=this.getGraph();if(!t)return;if(this.options.pos3d)return this.drawBins3D(t,i);const s=!!this.get_gme(),a=t.getGrFuncs(this.options.second_x,this.options.second_y),n=t.getFrameWidth(),h=t.getFrameHeight();if(this.createG(!t.pad_layer),this.options._pfc||this.options._plc||this.options._pmc){const r=this.getMainPainter();if((0,_.isFunc)(r?.createAutoColor)){const x=r.createAutoColor();this.options._pfc&&(i.fFillColor=x,delete this.fillatt),this.options._plc&&(i.fLineColor=x,delete this.lineatt),this.options._pmc&&(i.fMarkerColor=x,delete this.markeratt),this.options._pfc=this.options._plc=this.options._pmc=!1}}this.createAttLine({attr:i,can_excl:!0}),this.createAttFill({attr:i}),this.fillatt.used=!1,this.draw_kind="none",this.marker_size=0;const g=s?this.draw_g.append("svg:g"):this.draw_g;if(this.drawBins(a,this.options,g,n,h,this.lineatt,this.fillatt,!0),"TGraphQQ"===i._typename&&this.appendQQ(a,i),s){for(let r=0;r<i.fNYErrors;++r){let x=this.lineatt,d=this.fillatt;this.options.individual_styles&&(x=new X.gx({attr:i.fAttLine[r],std:!1}),d=new L.n({attr:i.fAttFill[r],std:!1,svg:this.getCanvSvg()}));const o=this.draw_g.append("svg:g"),c=r<this.options.blocks.length?this.options.blocks[r]:this.options;this.extractGmeErrors(r),this.drawBins(a,c,o,n,h,x,d)}this.extractGmeErrors(0)}this.isBatchMode()||((0,H.X2)(this,this.testEditable()),(0,D.wh)(this))}extractTooltip(t){if(!t)return null;if("lines"===this.draw_kind||"path"===this.draw_kind||"mark"===this.draw_kind)return this.extractTooltipForPath(t);if("nodes"!==this.draw_kind)return null;const i=this.get_main(),s=i.getFrameHeight(),a=this.error_size,n=1===this.options.Bar,h=n?i.getGrFuncs(this.options.second_x,this.options.second_y):null,g=this.marker_size?Math.round(this.marker_size/2+1.5):0;let r=null,x=1e10,d=null;if(this.draw_g.selectAll(".grpoint").each(function(){const l=(0,F.Lt)(this).datum();if(void 0===l)return;let m,y=(t.x-l.grx1)**2;if(1===t.nproc&&(y+=(t.y-l.gry1)**2),y>=x)return;if(l.error||l.rect||l.marker)m={x1:Math.min(-a,l.grx0,-g),x2:Math.max(a,l.grx2,g),y1:Math.min(-a,l.gry2,-g),y2:Math.max(a,l.gry0,g)};else if(l.bar){if(m={x1:-l.width/2,x2:l.width/2,y1:0,y2:s-l.gry1},n){const M=h.gry(0);m.y1=l.gry1>M?M-l.gry1:0,m.y2=l.gry1>M?0:M-l.gry1}}else m={x1:-5,x2:5,y1:-5,y2:5};const p=t.y>=l.gry1+m.y1&&t.y<=l.gry1+m.y2;t.x>=l.grx1+m.x1&&t.x<=l.grx1+m.x2&&(p||t.nproc>1)&&(x=y,r=this,d=m,d.exact=p)}),null===r)return null;const o=(0,F.Lt)(r).datum(),c=this.getGraph(),e={name:c.fName,title:c.fTitle,x:o.grx1,y:o.gry1,color1:this.lineatt.color,lines:this.getTooltips(o),rect:d,d3bin:r};return e.user_info={obj:c,name:c.fName,bin:o.indx,cont:o.y,grx:o.grx1,gry:o.gry1},this.fillatt?.used&&!this.fillatt?.empty()&&(e.color2=this.fillatt.getFillColor()),d.exact&&(e.exact=!0),e.menu=e.exact,e.menu_dist=3,e.bin=o,e.binindx=o.indx,e}showTooltip(t){let i=this.draw_g?.selectChild(".tooltip_bin");if(!t||!this.draw_g)return void i?.remove();if(t.usepath)return this.showTooltipForPath(t);const s=(0,F.Lt)(t.d3bin).datum();i.empty()&&(i=this.draw_g.append("svg:rect").attr("class","tooltip_bin").style("pointer-events","none").call(E.Ru)),t.changed=i.property("current_bin")!==t.d3bin,t.changed&&i.attr("x",s.grx1+t.rect.x1).attr("width",t.rect.x2-t.rect.x1).attr("y",s.gry1+t.rect.y1).attr("height",t.rect.y2-t.rect.y1).style("opacity","0.3").property("current_bin",t.d3bin)}processTooltipEvent(t){const i=this.extractTooltip(t);return(!t||!t.disabled)&&this.showTooltip(i),i}findBestBin(t){if(!this.bins)return null;const i="lines"===this.draw_kind,s=this.get_main().getGrFuncs(this.options.second_x,this.options.second_y);let g,r,x,d,o,a=-1,n=null,h=1e10;for(d=0;d<this.bins.length;++d)o=this.bins[d],r=s.grx(o.x),x=s.gry(o.y),g=(t.x-r)**2+(t.y-x)**2,g<h&&(h=g,n=o,a=d);h>100&&i&&(n=null);let c=Math.max(this.lineatt.width+3,4);this.marker_size>0&&(c=Math.max(this.marker_size,c)),n&&(h=Math.sqrt((t.x-s.grx(n.x))**2+(t.y-s.gry(n.y))**2)),!i&&h>c&&(n=null),n||(a=-1);const e={bin:n,indx:a,dist:h,radius:Math.round(c)};if(!n&&i){h=1e10;const l=(M,b,k)=>b>=M&&M>=k||b<=M&&M<=k;let f,y=this.bins[0],m=s.grx(y.x),p=0;for(d=1;d<this.bins.length;++d)o=this.bins[d],r=s.grx(o.x),l(t.x,m,r)&&(f=s.gry(y.y),x=s.gry(o.y),Math.abs(r-m)<1?(p=t.y,g=l(t.y,f,x)?0:Math.min(Math.abs(t.y-f),Math.abs(t.y-x))):(p=f+(t.x-m)/(r-m)*(x-f),g=Math.abs(p-t.y)),g<h&&(h=g,e.linex=t.x,e.liney=p)),y=o,m=r;h<.5*c&&(e.linedist=h,e.closeline=!0)}return e}testEditable(t){const i=this.getGraph();return!!i&&(("toggle"===t||void 0!==t&&!t!==i.TestBit(A))&&i.InvertBit(A),!i.TestBit(A))}extractTooltipForPath(t){if(null===this.bins)return null;const i=this.findBestBin(t);if(!i||!i.bin&&!i.closeline)return null;const s="lines"===this.draw_kind,a="mark"===this.draw_kind,h=this.get_main().getGrFuncs(this.options.second_x,this.options.second_y),g=this.getGraph(),r={name:g.fName,title:g.fTitle,x:i.bin?h.grx(i.bin.x):i.linex,y:i.bin?h.gry(i.bin.y):i.liney,color1:this.lineatt.color,lines:this.getTooltips(i.bin),usepath:!0};return r.user_info={obj:g,name:g.fName,bin:0,cont:0,grx:r.x,gry:r.y},r.ismark=a,r.islines=s,i.closeline?(r.menu=r.exact=!0,r.menu_dist=i.linedist):i.bin&&(this.options.EF&&s?(r.gry1=h.gry(i.bin.y-i.bin.eylow),r.gry2=h.gry(i.bin.y+i.bin.eyhigh)):r.gry1=r.gry2=h.gry(i.bin.y),r.binindx=i.indx,r.bin=i.bin,r.radius=i.radius,r.user_info.bin=i.indx,r.user_info.cont=i.bin.y,r.exact=Math.abs(t.x-r.x)<=i.radius&&(Math.abs(t.y-r.gry1)<=i.radius||Math.abs(t.y-r.gry2)<=i.radius),r.menu=r.exact,r.menu_dist=Math.sqrt((t.x-r.x)**2+Math.min(Math.abs(t.y-r.gry1),Math.abs(t.y-r.gry2))**2)),this.fillatt?.used&&!this.fillatt?.empty()&&(r.color2=this.fillatt.getFillColor()),s||(r.color1=this.getColor(g.fMarkerColor),r.color2||(r.color2=r.color1)),r}showTooltipForPath(t){let i=this.draw_g?.selectChild(".tooltip_bin");if(t?.bin&&this.draw_g){if(i.empty()&&(i=this.draw_g.append("svg:g").attr("class","tooltip_bin")),t.changed=i.property("current_bin")!==t.bin,t.changed)if(i.selectAll("*").remove(),i.property("current_bin",t.bin),t.ismark)i.append("svg:rect").style("pointer-events","none").call(E.Ru).style("opacity","0.3").attr("x",Math.round(t.x-t.radius)).attr("y",Math.round(t.y-t.radius)).attr("width",2*t.radius).attr("height",2*t.radius);else{i.append("svg:circle").attr("cy",Math.round(t.gry1)),Math.abs(t.gry1-t.gry2)>1&&i.append("svg:circle").attr("cy",Math.round(t.gry2));const s=i.selectAll("circle").attr("r",t.radius).attr("cx",Math.round(t.x));t.islines?(this.options.Line||this.options.Curve?s.call(this.lineatt.func):s.style("stroke","black"),this.options.Fill?s.call(this.fillatt.func):s.style("fill","none")):s.style("stroke","black"===t.color1?"green":"black").style("fill","none")}}else i?.remove()}moveEnabled(){return this.testEditable()}moveStart(t,i){this.pos_dx=this.pos_dy=0,this.move_funcs=this.get_main().getGrFuncs(this.options.second_x,this.options.second_y);const s=this.extractTooltip({x:t,y:i});s&&s.exact&&void 0!==s.binindx?(this.move_binindx=s.binindx,this.move_bin=s.bin,this.move_x0=this.move_funcs.grx(this.move_bin.x),this.move_y0=this.move_funcs.gry(this.move_bin.y)):delete this.move_binindx}moveDrag(t,i){this.pos_dx+=t,this.pos_dy+=i,void 0===this.move_binindx?(0,E.bk)(this.draw_g,this.pos_dx,this.pos_dy):this.move_funcs&&this.move_bin&&(this.move_bin.x=this.move_funcs.revertAxis("x",this.move_x0+this.pos_dx),this.move_bin.y=this.move_funcs.revertAxis("y",this.move_y0+this.pos_dy),this.drawGraph())}moveEnd(t){const i=this.getGraph(),s=i?.fNpoints-1;let a="";const n=h=>{a+=`SetPoint(${h.indx},${h.x},${h.y});;`,i.fX[h.indx]=h.x,i.fY[h.indx]=h.y,0===h.indx&&this._cutg_lastsame&&(a+=`SetPoint(${s},${h.x},${h.y});;`,i.fX[s]=h.x,i.fY[s]=h.y)};if(void 0===this.move_binindx){if(this.draw_g.attr("transform",null),this.move_funcs&&this.bins&&!t){for(let h=0;h<this.bins.length;++h){const g=this.bins[h];g.x=this.move_funcs.revertAxis("x",this.move_funcs.grx(g.x)+this.pos_dx),g.y=this.move_funcs.revertAxis("y",this.move_funcs.gry(g.y)+this.pos_dy),n(g)}i.$redraw_pad?this.redrawPad():this.drawGraph()}}else n(this.move_bin),delete this.move_binindx,i.$redraw_pad&&this.redrawPad();delete this.move_funcs,a&&!t&&this.submitCanvExec(a)}fillContextMenuItems(t){this.snapid||t.addchk(this.testEditable(),"Editable",()=>{this.testEditable("toggle"),this.drawGraph()})}executeMenuCommand(t,i){if(super.executeMenuCommand(t,i))return!0;const s=this.getCanvPainter(),a=this.get_main();if("RemovePoint"===t.fName||"InsertPoint"===t.fName){if(!s||s._readonly)return!0;const n=(0,_.isFunc)(a?.getLastEventPos)?a.getLastEventPos():null,h=this.extractTooltip(n);if("InsertPoint"===t.fName){if(n){const g=a.getGrFuncs(this.options.second_x,this.options.second_y),r=g.revertAxis("x",n.x)??0,x=g.revertAxis("y",n.y)??0;this.submitCanvExec(`AddPoint(${r.toFixed(3)}, ${x.toFixed(3)})`,t.$execid)}}else t.$execid&&void 0!==h?.binindx&&this.submitCanvExec(`RemovePoint(${h.binindx})`,t.$execid);return!0}return!1}_updateMembers(t,i){t.fBits=i.fBits,t.fTitle=i.fTitle,t.fX=i.fX,t.fY=i.fY,t.fNpoints=i.fNpoints,t.fMinimum=i.fMinimum,t.fMaximum=i.fMaximum}updateObject(t,i){if(!this.matchObjectType(t))return!1;if(i&&i!==this.options.original&&this.decodeOptions(i),this._updateMembers(this.getObject(),t),this.createBins(),delete this.$redraw_hist,this.axes_draw){const s=this.createHistogram(),a=this.getMainPainter();a?.$secondary&&(a.updateObject(s,this.options.Axis),this.$redraw_hist=!0)}return!0}canZoomInside(t,i,s){const a=this.getGraph();if(!a||t!==(this.options.pos3d?"y":"x"))return!1;for(let n=0;n<a.fNpoints;++n)if(i<a.fX[n]&&a.fX[n]<s)return!0;return!1}clickButton(t){return"ToggleZoom"===t&&(this.xmin!==this.xmax||this.ymin!==this.ymax)&&this.getFramePainter()?.zoom(this.xmin,this.xmax,this.ymin,this.ymax)}findFunc(){return this.getGraph()?.fFunctions?.arr?.find(t=>t._typename===_.clTF1||t._typename===_.clTF2)}findStat(){return this.getGraph()?.fFunctions?.arr?.find(t=>t._typename===_.clTPaveStats&&"stats"===t.fName)}createStat(){const t=this.findFunc();if(!t)return null;let i=this.findStat();if(i)return i;if(this.getCanvPainter()?.normal_canvas||this.options.PadStats)return null;this.create_stats=!0;const s=_.gStyle;return i=(0,_.create)(_.clTPaveStats),Object.assign(i,{fName:"stats",fOptStat:0,fOptFit:s.fOptFit||111,fBorderSize:1}),i.fX1NDC=s.fStatX-s.fStatW,i.fY1NDC=s.fStatY-s.fStatH,i.fX2NDC=s.fStatX,i.fY2NDC=s.fStatY,i.fFillColor=s.fStatColor,i.fFillStyle=s.fStatStyle,i.fTextAngle=0,i.fTextSize=s.fStatFontSize,i.fTextAlign=12,i.fTextColor=s.fStatTextColor,i.fTextFont=s.fStatFont,i.AddText(t.fName),this.getGraph().fFunctions.Add(i),i}fillStatistic(t,i,s){const a=this.findFunc();return!!(a&&s&&this.create_stats)&&(t.clearPave(),t.fillFunctionStat(a,s,1),!0)}drawNextFunction(t){var i=this;return(0,$.A)(function*(){const s=i.getGraph();if(t>=(s?.fFunctions?.arr?.length||0))return i;const a=s.fFunctions.arr[t],n=s.fFunctions.opt[t];return a.$main_painter=i,i.getPadPainter().drawObject(i.getDom(),a,n).then(()=>i.drawNextFunction(t+1))})()}getHistoOpt(){let t=this.options.Axis;return 0===t.indexOf("AXIS;")&&(t=t.slice(5)),t}drawAxisHisto(){var t=this;return(0,$.A)(function*(){const i=t.createHistogram();return Y.N.draw(t.getDom(),i,t.getHistoOpt())})()}static _drawGraph(t,i){return(0,$.A)(function*(){t.decodeOptions(i,!0),t.createBins(),t.createStat();const s=t.getGraph();!_.settings.DragGraphs&&s&&!s.TestBit(A)&&s.InvertBit(A);let a=Promise.resolve();return(!t.getMainPainter()||t.options.second_x||t.options.second_y)&&t.options.Axis&&(a=t.drawAxisHisto().then(n=>{n&&(t.axes_draw=!0,t._own_histogram||(t.$primary=!0),n.$secondary="hist")})),a.then(()=>(t.addToPadPrimitives(),t.drawGraph())).then(()=>t.drawNextFunction(0))})()}static draw(t,i,s){return(0,$.A)(function*(){return T._drawGraph(new T(t,i),s)})()}}}}]);