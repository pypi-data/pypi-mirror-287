"use strict";(self.webpackChunkfirebird=self.webpackChunkfirebird||[]).push([[3675],{3675:(L,T,d)=>{d.r(T),d.d(T,{THStackPainter:()=>M});var S=d(467),m=d(6998),v=d(9041),H=d(675),A=d(1516),N=d(4149),b=d(9025);class M extends H.JW{constructor(n,s,e){super(n,s,e),this.firstpainter=null,this.painters=[]}cleanup(){this.getPadPainter()?.cleanPrimitives(n=>n===this.firstpainter||this.painters.indexOf(n)>=0),delete this.firstpainter,delete this.painters,super.cleanup()}buildStack(n){if(!n.fHists)return!1;const s=n.fHists.arr.length;if(s<=0)return!1;const e=(0,m.create)(m.clTList);e.Add((0,m.clone)(n.fHists.arr[0]),n.fHists.opt[0]);for(let i=1;i<s;++i){const t=(0,m.clone)(n.fHists.arr[i]),a=n.fHists.opt[i],r=e.arr[i-1],f=t.fXaxis,h=r.fXaxis;if(f.fNbins!==h.fNbins||f.fXmin!==h.fXmin||f.fXmax!==h.fXmax)return console.warn(`When drawing THStack, cannot sum-up histograms ${t.fName} and ${r.fName}`),e.Clear(),!1;for(let p=0;p<t.fArray.length;++p)t.fArray[p]+=r.fArray[p];e.Add(t,a)}return n.fStack=e,!0}getMinMax(n){const s=this.getObject(),e=this.getPadPainter().getRootPad(!0);let i=0,t=0;const a=(o,c)=>{const l={min:0,max:0};let P=!0,k=!0;if(o.fMinimum!==m.kNoZoom&&(l.min=o.fMinimum,P=!1),o.fMaximum!==m.kNoZoom&&(l.max=o.fMaximum,k=!1),!P&&!k)return l;let X=1,E=o.fXaxis.fNbins,w=1,O=1,C=!0;o.fXaxis.TestBit(H.rb.kAxisRange)&&(X=o.fXaxis.fFirst,E=o.fXaxis.fLast),0===o._typename.indexOf(m.clTH2)&&(O=o.fYaxis.fNbins,o.fYaxis.TestBit(H.rb.kAxisRange)&&(w=o.fYaxis.fFirst,O=o.fYaxis.fLast));for(let u=w;u<=O;++u)for(let x=X;x<=E;++x){const _=o.getBinContent(x,u),g=c?o.getBinError(o.getBin(x,u)):0;P&&(C||_-g<l.min)&&(l.min=_-g),k&&(C||_+g>l.max)&&(l.max=_+g),C=!1}return l};if(this.options.nostack)for(let o=0;o<s.fHists.arr.length;++o){const c=a(s.fHists.arr[o],n);0===o?(i=c.min,t=c.max):(i=Math.min(i,c.min),t=Math.max(t,c.max))}else i=a(s.fStack.arr[0],n).min,t=a(s.fStack.arr[s.fStack.arr.length-1],n).max;const r=()=>{if(e&&(1===this.options.ndim?e.fLogy:e.fLogz)){t<=0&&(t=1),i<=0&&(i=1e-4*t);const o=1/(1+.5*Math.log10(t/i)),c=1+.2*Math.log10(t/i);i*=o,t*=c}else i>0&&i<.05*t&&(i=0)};t*=1+m.gStyle.fHistTopMargin,r();let f=t,h=i,p=!1;return s.fMaximum!==m.kNoZoom&&(t=s.fMaximum,f=Math.max(t,f),p=!0),s.fMinimum!==m.kNoZoom&&(i=s.fMinimum,h=Math.min(i,h),p=!0),p?r():i=t=m.kNoZoom,{min:i,max:t,min0:h,max0:f,zoomed:p,hopt:`hmin:${h};hmax:${f};minimum:${i};maximum:${t}`}}drawNextHisto(n,s){var e=this;return(0,S.A)(function*(){const i=e.getObject(),t=e.options.nostack?i.fHists:i.fStack,a=t?.arr?.length||0;if(n>=a)return e;const r=e.options.horder?n:a-n-1,f=t.arr[r];let h=t.opt[r]||f.fOption||e.options.hopt,p="";if(h.toUpperCase().indexOf(e.options.hopt)<0&&(h+=" "+e.options.hopt),e.options.draw_errors&&!h&&(h="E"),e.options._pfc||e.options._plc||e.options._pmc){const o=e.getMainPainter();if((0,m.isFunc)(o?.createAutoColor)){const c=o.createAutoColor(a);e.options._pfc&&(f.fFillColor=c,p+=`SetFillColor(${c});;`),e.options._plc&&(f.fLineColor=c,p+=`SetLineColor(${c});;`),e.options._pmc&&(f.fMarkerColor=c,p+=`SetMarkerColor(${c});;`)}}if(s){const o=s.getSubPadPainter(n+1);if(!o)return e;const c=o.selectCurrentPad(o.this_pad_name);return e.hdraw_func(o.getDom(),f,h).then(l=>(l&&(l._auto_exec=p,e.painters.push(l)),o.selectCurrentPad(c),e.drawNextHisto(n+1,s)))}return r>0&&!e.options.nostack&&(f.$baseh=t.arr[r-1]),e.hdraw_func(e.getDom(),f,h+" same nostat").then(o=>(e.painters.push(o),e.drawNextHisto(n+1,s)))})()}decodeOptions(n){this.options||(this.options={}),Object.assign(this.options,{ndim:1,nostack:!1,same:!1,horder:!0,has_errors:!1,draw_errors:!1,hopt:""});const s=this.getObject(),e=s.fHistogram||(s.fHists?s.fHists.arr[0]:null)||(s.fStack?s.fStack.arr[0]:null),i=r=>{if(r.fSumw2&&r.fSumw2.length>0)for(let f=0;f<r.fSumw2.length;++f)if(r.fSumw2[f]>0)return!0;return!1};if(e&&0===e._typename.indexOf(m.clTH2)&&(this.options.ndim=2),2===this.options.ndim&&!n&&(n="lego1"),s.fHists&&!this.options.nostack)for(let r=0;r<s.fHists.arr.length;++r)this.options.has_errors=this.options.has_errors||i(s.fHists.arr[r]);this.options.nhist=s.fHists?s.fHists.arr.length:1;const t=new v.nC(n);this.options.nostack=t.check("NOSTACK"),t.check("STACK")&&(this.options.nostack=!1),this.options.same=t.check("SAME"),t.check("NOCLEAR"),this.options._pfc=t.check("PFC"),this.options._plc=t.check("PLC"),this.options._pmc=t.check("PMC"),this.options.pads=t.check("PADS"),this.options.pads&&(this.options.nostack=!0),this.options.hopt=t.remain();const a=t.check("LEGO");this.options.errors=t.check("E"),!this.options.nostack&&this.options.has_errors&&!a&&!t.check("HIST")&&this.options.hopt.indexOf("E")<0&&(this.options.draw_errors=!0),this.options.horder=this.options.nostack||a}createHistogram(n){const s=n.fHists,e=s?s.arr.length:0;if(!e){const a=(0,m.createHistogram)(m.clTH1I,100);return(0,m.setHistogramTitle)(a,n.fTitle),a.fBits|=m.kNoStats,a}const i=s.arr[0],t=(0,m.createHistogram)(1===this.options.ndim?m.clTH1I:m.clTH2I,i.fXaxis.fNbins,i.fYaxis.fNbins);t.fName="axis_hist",t.fBits|=m.kNoStats,Object.assign(t.fXaxis,i.fXaxis),2===this.options.ndim&&Object.assign(t.fYaxis,i.fYaxis);for(let a=1;a<e;++a){const r=s.arr[a];t.fXaxis.fLabels||(t.fXaxis.fXmin=Math.min(t.fXaxis.fXmin,r.fXaxis.fXmin),t.fXaxis.fXmax=Math.max(t.fXaxis.fXmax,r.fXaxis.fXmax)),2===this.options.ndim&&!t.fYaxis.fLabels&&(t.fYaxis.fXmin=Math.min(t.fYaxis.fXmin,r.fYaxis.fXmin),t.fYaxis.fXmax=Math.max(t.fYaxis.fXmax,r.fYaxis.fXmax))}return t.fTitle=n.fTitle,t}updateObject(n){if(!this.matchObjectType(n))return!1;const s=this.getObject();if(s.fHists=n.fHists,s.fStack=n.fStack,s.fTitle=n.fTitle,s.fMinimum=n.fMinimum,s.fMaximum=n.fMaximum,this.options.nostack||(this.options.nostack=!this.buildStack(s)),this.firstpainter){let t=n.fHistogram;t||(t=s.fHistogram=this.createHistogram(s));const a=this.getMinMax(this.options.errors||this.options.draw_errors);this.firstpainter.options.minimum=a.min,this.firstpainter.options.maximum=a.max,this.firstpainter._checked_zooming=!1,1===this.options.ndim?(this.firstpainter.ymin=a.min0,this.firstpainter.ymax=a.max0):(this.firstpainter.zmin=a.min0,this.firstpainter.zmax=a.max0),this.firstpainter.updateObject(t)}const e=this.options.nostack?s.fHists:s.fStack,i=e?.arr?.length??0;if(i!==this.painters.length)this.getPadPainter()?.cleanPrimitives(t=>this.painters.indexOf(t)>=0),this.painters=[],this.did_update=!0;else for(let t=0;t<i;++t){const a=this.options.horder?t:i-t-1,r=e.arr[a],f=e.opt[a],h=this.painters[t].getHisto();this.options._pfc&&(r.fFillColor=h.fFillColor),this.options._plc&&(r.fLineColor=h.fLineColor),this.options._pmc&&(r.fMarkerColor=h.fMarkerColor),this.painters[t].updateObject(r,f||r.fOption||this.options.hopt)}return!0}redraw(){if(this.did_update)return delete this.did_update,this.drawNextHisto(0,this.options.pads?this.getPadPainter():null)}static draw(n,s,e){return(0,S.A)(function*(){if(!s.fHists||!s.fHists.arr)return null;const i=new M(n,s,e);let t=null,a=!1;return(0,b.ensureTCanvas)(i,!1).then(()=>{if(i.decodeOptions(e),i.hdraw_func=1===i.options.ndim?A.TH1Painter.draw:N.TH2Painter.draw,i.options.pads)return t=i.getPadPainter(),t.doingDraw()&&t.pad?.fPrimitives&&t.pad.fPrimitives.arr.length>1&&0===t.pad.fPrimitives.arr.indexOf(s)?(a=!0,void console.log("special case with THStack with is already rendered - do nothing")):(t.cleanPrimitives(p=>p!==i),t.divide(i.options.nhist));if(i.options.nostack||(i.options.nostack=!i.buildStack(s)),i.options.same)return;const r=!s.fHistogram;r&&(s.fHistogram=i.createHistogram(s));const f=i.getMinMax(i.options.errors||i.options.draw_errors);return i.hdraw_func(n,s.fHistogram,i.options.hopt+";"+f.hopt).then(p=>{i.addToPadPrimitives(),i.firstpainter=p,p.$secondary="hist",r||(i.$primary=!0)})}).then(()=>a?i:i.drawNextHisto(0,t))})()}}}}]);