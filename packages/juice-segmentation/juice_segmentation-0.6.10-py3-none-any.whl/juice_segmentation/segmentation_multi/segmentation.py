"""
Created on May 2021

@author: Claudio Munoz Crego (ESAC)

This module allows to generate a Segmentation Proposal File (SCHE_0010)
from an Opportunities' timeline file


    0) We start loading and parsing json file
        0.1) Segmentation Opportunities timeline (generated by user from SHT)
        0.2) Segmentation Definition get via REST-API
        Note: To perform this the corresponding path must be set-up

    1) Define environment parameter
    2) Define parameters, input and output path
    3) Select original segments per working group
    3) Select original segments pedl_r working group
    4) Set-up Metrics for reporting using original segments before any cut
    5) Select Calibration
    6) Combine WG according to given priority rules
    7) Allocating Juice Moon OPE_NAV for FD and WG3 (and WG4, WG2 if needed)
    8) Generating segmentation and metric report

"""

import os
import sys
import logging

from juice_segmentation.commons.mission_timeline_event_file_handler import MissionTimelineEvent
from juice_segmentation.commons.segment_handler import SegmentHandler, get_absolute_start_end_segment
from juice_segmentation.segmentation_multi.partitions import set_partitions
from juice_segmentation.segmentation_multi.op_nav_schedulling import perform_op_nav_scheduling
from juice_segmentation.segmentation_multi.generic_schedulling import perform_generic_scheduling
from juice_segmentation.wg.wg_utils import is_mask_in_keys
from juice_segmentation.wg.wg_segmentation import WgSegmentation


def generate_proposal_file(input_segmentation_file_path, output_dir_path, config, create_csv=True,
                           wg_segments_to_ignore=[]):
    """
    Generate a Juice Segmentation Proposal File (SCHE_0010)
    from a Segmentation Opportunities timeline

    :param wg_segments_to_ignore: Working group - segment to be ignored
    :param input_segmentation_file_path: segmentation Opportunities timeline file path (json)
    :param output_dir_path: output directory path (must exits)
    :param config: configuration parameters
    :param create_csv: Flag allowing to create orginale working group segment files; default=true
    """

    if 'calib_roll' not in list(config.keys()):
        logging.warning('You are Running the segmentation Scheduler')
        logging.error('calib_roll section missing in json configuration file.error')
        logging.warning('Are you trying to run the Segmentation Updater?')
        sys.exit()

    check_input_path(input_segmentation_file_path, output_dir_path)

    crema_id = str(config['crema_id']).lower()

    juice_conf = config["juice_conf"]
    if "mission_phases" in config.keys():
        mission_phases = config["mission_phases"]
    else:
        mission_phases = os.path.join(juice_conf, 'internal', 'geopipeline', 'output', crema_id, 'Mission_Phases.csv')

    if "mission_timeline_event_file" in config.keys():
        mission_timeline_event_file = config["mission_timeline_event_file"]
    else:
        crema_id_x_y = crema_id.replace('crema_', '')
        mission_timeline_event_file_name = 'mission_timeline_event_file_{}.csv'.format(crema_id_x_y)
        mission_timeline_event_file = os.path.join(juice_conf, 'internal', 'geopipeline', 'output',
                                                   crema_id, mission_timeline_event_file_name)

    if "opportunity_vs_prime" in config.keys():
        opportunity_vs_prime = config["opportunity_vs_prime"]
    else:
        opportunity_vs_prime = os.path.join(juice_conf, *['internal', 'segmentation_scheduler', 'input', 'conf',
                                                          'OPPORTUNITY_PRIME_correspondance.csv'])

    mission_phases = os.path.expandvars(mission_phases)

    plan_start, plan_end = get_absolute_start_end_segment(input_segmentation_file_path)
    partitions, max_start, max_end = set_partitions(config, mission_phases, plan_start, plan_end)

    start, end = max_start, max_end

    #
    # 1) Load and parse Segmentation Opportunities timeline & Segmentation Definition
    # and generate a csv working group segment file corresponding to Segmentation Opportunities timeline (name wg_all)
    #

    seg_all_json_file_path = input_segmentation_file_path

    wg_all_original_segment_file = os.path.join(output_dir_path, 'wg_all.csv')

    if 'new_plan_name' in list(config.keys()):
        new_plan_name = config['new_plan_name']
    else:
        new_plan_name = None  # And then set to input plan name + '_new'

    segment_handler = SegmentHandler(seg_all_json_file_path, wg_segments_to_ignore=wg_segments_to_ignore,
                                     start=start, end=end)

    if start or end:
        segment_handler.create_sub_plan_for_selected_period(start, end, output_dir_path)

    segment_handler.create_csv_segment_file(wg_csv_file_path=wg_all_original_segment_file, crema_id=crema_id)

    #
    # 2) Define parameters, input and output path
    #   - root_path: is the local base directory use as default directory for inputs (we will use outputdir)
    #   - wg_seg_input: contains the list of csv files including segment detail.
    #     This list contain wg_all generate in 0) and do not need to be changed
    #   - mission_phases: path to the trajectory dependent file "Mission_Phases.csv"
    #   - mission_timeline_event_file: path to the trajectory dependent file "mission_timeline_event_file_X_Y.csv"
    #   - opportunity_vs_prime: path to the OPPORTUNITY_PRIME_correspondance.csv file
    #

    wg_seg_input = [wg_all_original_segment_file]
    if "wg_seg_input" in config.keys():
        wg_seg_input = wg_seg_input + config["wg_seg_input"]

    json_data = \
        {
            "root_path": output_dir_path,
            "output": {"dir": output_dir_path,
                       "file_prefix": "segmentation_proposal_" + crema_id, "file_sufix": ".csv",
                       "file_prefix_origin": "segmentation_opportunities_" + crema_id, "file_sufix_origin": ".csv"},
            "wg_seg_input": wg_seg_input,
            "mission_phases": mission_phases,
            "mission_timeline_event_file": mission_timeline_event_file,
            "opportunity_vs_prime": opportunity_vs_prime,
            "calib_roll": config['calib_roll']
        }

    if "segment_with_dv_not_shared_by_group" in list(config.keys()):
        segment_with_dv_not_shared_by_group = config["segment_with_dv_not_shared_by_group"]
    else:
        segment_with_dv_not_shared_by_group = []

    dl_segment_minimum_sec = 4 * 3600  # Default value is 4 hours in seconds
    if 'dl_segment_minimum_sec' in list(config.keys()):
        dl_segment_minimum_sec = config["dl_segment_minimum_sec"]

    #
    # 3) Select original segments per working group
    # For instance:
    # - From wg1, we select segment with name including '_FLYBY_GALA'
    # - From wgx, we select all the 'JMAG_CALROLL' and 'SUN_CONJUNCTION_SUP'
    # - We get FD from GENERIC working group
    #

    juice_seg = WgSegmentation(json_data, main_config=config)
    sun_conjunction = MissionTimelineEvent(juice_seg.config.mission_timeline_event_file).get_sun_conjunctions()
    wgx_sun_conjunction = {'WGX': sun_conjunction}
    seg = juice_seg.seg

    wg_seg = seg.get_original_wg_seg(juice_seg.config)

    ws, wg1, wg2, wg3, wg4, wgx, dl_, fd_nav, fd_tcm, fd_wol = set_wg_seg(seg, wg_seg, only_wg_x=False)

    fd_ope_nav = seg.select_wgx_subset(wg_seg, wg_filter=['GENERIC'], seg_filter=["OPNAV_"])

    #
    #  4) Set-up Metrics for reporting using original segments before any cut
    #

    juice_seg.set_original_metrics(wg1, wg2, wg3, wg4, wgx, dl_, fd_nav, fd_tcm, fd_wol, fd_ope_nav,
                                   create_csv=create_csv)

    #
    #  5) Select Calibration (using Mission_Phases.cvs labels)
    #

    wgx_calib = juice_seg.get_wgx_cal_roll(wgx, config['calib_roll'])
    wgx_calib_original = seg.select_wgx_subset(wg_seg, wg_filter=["WGX"], seg_filter=['JMAG_CALROLL'])

    #
    # 6) Combine WG according to given priority rules
    # Decreasing priority order for scheduling
    #

    wg_all = {}
    wg1 = {}
    wg2 = {}
    wg3 = {}
    wg4 = {}
    wgx = {}
    fd_tcm = {}
    fd_wol = {}
    dl_ = {}
    fd_openav_selected = {}

    flag_cutted_gs_downlink = False

    nb_partitions = len(partitions)
    for i_part in range(nb_partitions):

        partition = [partitions[i_part]['start'], partitions[i_part]['end']]
        partition_start = partition[0]

        logging.info('Processing period {}/{} [{} - {}]'.format(i_part + 1, nb_partitions, partition[0], partition[1]))

        seg_to_load = config["partitions"][i_part]["seg_to_load_rule"]

        if "op_nav_insertion_rules" in list(config["partitions"][i_part].keys()):
            op_nav_insertion_rules = config["partitions"][i_part]["op_nav_insertion_rules"]
        else:
            op_nav_insertion_rules = []

        if "other_insertion_rules" in list(config["partitions"][i_part].keys()):
            other_insertion_rules = config["partitions"][i_part]["other_insertion_rules"]
        else:
            other_insertion_rules = []

        ws, seg_to_load = set_wg_seg(seg, wg_seg, seg_to_load, other_insertion_rules=other_insertion_rules)
        ids = range(len(seg_to_load))

        part_fd_ope_nav = seg.select_wgx_subset_by_time(fd_ope_nav, intervals=[partition])
        part_wgx_sun_conjunction = seg.select_wgx_subset_by_time(wgx_sun_conjunction, intervals=[partition])
        part_wgx_calib_original = seg.select_wgx_subset_by_time(wgx_calib_original, intervals=[partition])
        part_wgx_calib = seg.select_wgx_subset_by_time(wgx_calib, intervals=[partition])

        part_ws = []
        for i in ids:
            if ws[i]:
                tmp = seg.select_wgx_subset_by_time(ws[i], intervals=[partition])
                part_ws.append(tmp)

        part_wg1, part_wg2, part_wg3, part_wg4, part_wgx, part_fd_tcm, part_fd_wol, part_dl_, \
            part_wg_all, part_fd_openav_selected = perform_op_nav_scheduling(
                seg, part_ws, seg_to_load, op_nav_insertion_rules, juice_seg,
                part_fd_ope_nav, part_wgx_sun_conjunction,
                part_wgx_calib_original, part_wgx_calib,
                partition, flag_cutted_gs_downlink, dl_segment_minimum_sec)

        # Check if last OPNAV have been allocated
        last_instance_part_fd_ope_nav, last_wg, last_seg = seg.get_last_segments(part_fd_ope_nav)
        last_instance_part_fd_openav_sel, last_sel_wg, last_sel_seg, = seg.get_last_segments(part_fd_openav_selected)

        if last_instance_part_fd_ope_nav:

            if last_instance_part_fd_openav_sel:

                if last_instance_part_fd_openav_sel[0] >= last_instance_part_fd_ope_nav[0]:

                    if last_instance_part_fd_openav_sel[1] <= last_instance_part_fd_ope_nav[1]:
                        last_instance = {last_sel_wg: {last_sel_seg: [last_instance_part_fd_openav_sel]}}
                        fd_ope_nav = seg.remove_seg_if_overlapping(fd_ope_nav, last_instance)

        for rule in other_insertion_rules:

            seg_to_insert = {}
            for [wg, wg_segments] in rule["seg_to_insert"]:
                for wg_segment in wg_segments:
                    segments_to_add = seg.select_wgx_subset(wg_seg, wg_filter=[wg], seg_filter=[wg_segment])
                    segments_to_add = seg.select_wgx_subset_by_time(segments_to_add, intervals=[partition])
                    seg_to_insert = seg.merge_wgx_segments(seg_to_insert, segments_to_add)

            seg_allowed = {}
            for [wg, wg_segments] in rule["seg"]:
                for wg_segment in wg_segments:
                    segments_to_add = seg.select_wgx_subset(part_wg_all, wg_filter=[wg], seg_filter=[wg_segment])
                    seg_allowed = seg.merge_wgx_segments(seg_allowed, segments_to_add)

            part_wg1, part_wg2, part_wg3, part_wg4, part_wgx, part_dl_, part_wg_all = \
                perform_generic_scheduling(rule, seg, part_ws, seg_to_load, seg_to_insert,
                                           seg_allowed, part_fd_ope_nav, part_wgx_sun_conjunction,
                                           part_wgx_calib_original, part_wgx_calib,
                                           partition, flag_cutted_gs_downlink)

        wg_all = seg.join_wg_segments_at_given_time(wg_all, part_wg_all, partition_start)
        wg1 = seg.join_wg_segments_at_given_time(wg1, part_wg1, partition_start)
        wg2 = seg.join_wg_segments_at_given_time(wg2, part_wg2, partition_start)
        wg3 = seg.join_wg_segments_at_given_time(wg3, part_wg3, partition_start)
        wg4 = seg.join_wg_segments_at_given_time(wg4, part_wg4, partition_start)
        wgx = seg.join_wg_segments_at_given_time(wgx, part_wgx, partition_start)
        fd_tcm = seg.join_wg_segments_at_given_time(fd_tcm, part_fd_tcm, partition_start)
        fd_wol = seg.join_wg_segments_at_given_time(fd_wol, part_fd_wol, partition_start)
        dl_ = seg.join_wg_segments_at_given_time(dl_, part_dl_, partition_start)
        fd_openav_selected = seg.join_wg_segments_at_given_time(
            fd_openav_selected, part_fd_openav_selected, partition_start)

        current_last_seg_period, current_last_wg_name, current_last_seg_name = seg.get_last_segments(wg_all)

        # prev_last_segment = SegmentInstance(current_last_seg_period, current_last_wg_name, current_last_seg_name)
        if str(current_last_seg_name).startswith('DL_'):
            flag_cutted_gs_downlink = True

    #
    # 8) Generating segmentation and metric report
    #

    juice_seg.generate_segment_and_report(wg1, wg2, wg3, wg4, wgx,
                                          dl_, fd_nav, fd_tcm, fd_wol, fd_openav_selected, wg_all,
                                          segment_handler=segment_handler,
                                          generate_report=True,
                                          create_csv=create_csv,
                                          new_plan_name=new_plan_name,
                                          other_insertion_rules=other_insertion_rules,
                                          segment_with_dv_not_shared_by_group=segment_with_dv_not_shared_by_group)

    if not create_csv:  # then remove 'wg_all.csv' the csv version of input_segmentation_file

        os.remove(wg_all_original_segment_file)


def check_input_path(input_segmentation_file_path, output_dir_path):
    if not os.path.exists(input_segmentation_file_path):
        logging.error('input_segmentation_file_path does not exist: {}'.format(input_segmentation_file_path))
        sys.exit(0)
    elif not os.path.isfile(input_segmentation_file_path):
        logging.error('input_segmentation_file_path is not a file: {}'.format(input_segmentation_file_path))
        sys.exit(0)

    if not os.path.exists(output_dir_path):
        logging.error('output_dir_path does not exist: {}'.format(output_dir_path))
        logging.info('Please, create the corresponding directory')
        sys.exit(0)
    elif not os.path.isdir(output_dir_path):
        logging.error('output_dir_path is not a directory: {}'.format(output_dir_path))
        sys.exit(0)


def set_wg_seg(seg, wg_seg, seg_to_load=None, only_wg_x=True, other_insertion_rules=[]):
    """
    Set WG segments for a given seg_to_load


    :param seg: seg object
    :param wg_seg: working group - segment structure
    :param seg_to_load: list of segment
    :param only_wg_x: Flag to customize output; default is True
    :param other_insertion_rules: if seg_to_load empty then all but other_insertion_rules segment to INSERT to include
    :return: if only_wg_x: ws, seg_to_load
             else ws, wg1, wg2, wg3, wg4, wgx, dl_, fd_nav, fd_tcm, fd_wol
    """

    wg_seg_to_avoid = []

    if not seg_to_load:
        seg_to_load = None

    if seg_to_load is None:

        seg_to_load = [["GENERIC", ['DL_']],
                       ["GENERIC", ['_FD_TCM']],
                       ["GENERIC", ['_FD_WOL']],
                       ["WGX", []],
                       ["WG1", []],
                       ["WG2", []],
                       ["WG4", []],
                       ["WG3", []]]

        for rule in other_insertion_rules:

            if 'seg_to_insert' in list(rule.keys()):
                wg_seg_to_avoid.extend(rule['seg_to_insert'])

    wg1 = {'WG1': {}}
    wg2 = {'WG2': {}}
    wg3 = {'WG3': {}}
    wg4 = {'WG4': {}}
    wgx = {'WGX': {}}
    dl_ = {'GENERIC': {}}
    fd_nav = {'GENERIC': {}}
    fd_tcm = {'GENERIC': {}}
    fd_wol = {'GENERIC': {}}

    ids = range(len(seg_to_load))
    ws = []
    for i in ids:

        [wg_i, seg_i] = seg_to_load[i]

        wg_seg_to_add = seg.select_wgx_subset(wg_seg, wg_filter=[wg_i], seg_filter=seg_i)
        for [wg_i_to_avoid, seg_i_to_avoid] in wg_seg_to_avoid:
            wg_seg_to_add = seg.remove_wgx_subset(wg_seg_to_add, wg_filter=[wg_i_to_avoid], seg_filter=seg_i_to_avoid)
        ws.append(wg_seg_to_add)

        if wg_i == "WG1":
            wg1 = seg.merge_wgx_segments(wg1, ws[i])
        elif wg_i == 'WG2':
            wg2 = seg.merge_wgx_segments(wg2, ws[i])
        elif wg_i == 'WG3':
            wg3 = seg.merge_wgx_segments(wg3, ws[i])
        elif wg_i == 'WG4':
            wg4 = seg.merge_wgx_segments(wg4, ws[i])
        elif wg_i == 'WGX':
            wgx = seg.merge_wgx_segments(wgx, ws[i])
        elif wg_i == 'GENERIC' and 'DL_' in seg_i:
            dl_ = seg.merge_wgx_segments(dl_, ws[i])
        elif wg_i == 'GENERIC' and is_mask_in_keys(seg_i, '_FD_TCM'):
            fd_tcm = seg.merge_wgx_segments(fd_tcm, ws[i])
        elif wg_i == 'GENERIC' and is_mask_in_keys(seg_i, '_FD_WOL'):
            fd_wol = seg.merge_wgx_segments(fd_wol, ws[i])
        else:
            logging.error('cannot catch working group segment: {}, {}'.format(wg_i, seg_i))
            sys.exit()

    if only_wg_x:

        return ws, seg_to_load

    else:

        return ws, wg1, wg2, wg3, wg4, wgx, dl_, fd_nav, fd_tcm, fd_wol
