
# **********************************************************************
# This file has been auto-generated by a code generation tool.
# Version:   "4.1.6"
# Date/time: 25 Jul 2024 12:00:26
# Template:  /python/calculations.razor.
# **********************************************************************

# ================================================================================
# Python PWS calculations.
# ================================================================================

import uuid
from http import HTTPStatus

import requests
from marshmallow import EXCLUDE, Schema, fields, post_load, pre_load
from marshmallow_enum import EnumField
from requests import Response

from .constants import *
from .entities import *
from .entity_schemas import *
from .enums import *
from .utilities import (
    get_access_token,
    get_access_token_info,
    get_analytics_api_target,
    get_client_alias_id,
)


class _CalculationRequestBase(object):
    """Calculation request base class."""

    def __init__(self):
      pass


class _CalculationBase(object):
    """Calculation base class."""

    def __init__(self):

        self.result_code = ResultCode.SUCCESS
        """ resultCode: ResultCode

            Possible values:

            -1: Failed validation
            0: Success
            +1: Failed execution

        """

        self.messages = list[str]()
        """ messages: List of messages returned by a calculation. """

        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Post json to url and time the call
    def post_request(self, url: str, data: str, access_token: str) -> Response:

        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {access_token}'
        }

        (platform, expiry_date, has_expired) = get_access_token_info(access_token)

        if not has_expired:
            response = requests.post(url, data=data, headers=headers, verify = 'localhost' not in url)
            return response
        else:
            print(f"Your access token has expired: {expiry_date}")

            response = Response()

            response.status_code = HTTPStatus.UNAUTHORIZED
            response.reason = "Expired access token"

            return response

    def print_messages(self):
        """Utility method to print the messages returned by the calculation."""
        if (self.messages is not None and len(self.messages) > 0):
            for message in self.messages:
                print(message)
        else:
            print("No messages")


class _CalculationResponseBase(object):
    """Calculation response base class."""

    def __init__(self):
      pass


class CalculationFailedResponse(object):
    """Calculation failed response class."""

    def __init__(self, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int):
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time


class _CalculationFailedResponseSchema(Schema):
    """Calculation failed response schema."""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_calculation_failed_response(self, data, **kwargs):
        """Post-processing of the CalculationFailedResponseSchema class."""

        return CalculationFailedResponse(**data)


class _LateExplosionCalculationRequestSchema(Schema):
    """Schema for the LateExplosion calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    explosion_output_config = fields.Nested(ExplosionOutputConfigSchema, data_key="explosionOutputConfig")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_late_explosion_calculation_request(self, data, **kwargs):
        """Post-processing of the LateExplosionSchema class."""

        return _LateExplosionCalculationRequest(**data)


class _VesselLeakFlammableLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselLeakFlammableLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionOutputConfigs")
    dispersion_output_config_count = fields.Int(data_key="dispersionOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_leak_flammable_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakFlammableLinkedRunSchema class."""

        return _VesselLeakFlammableLinkedRunCalculationRequest(**data)


class _SideviewAtTimeCalculationRequestSchema(Schema):
    """Schema for the SideviewAtTime calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_sideview_at_time_calculation_request(self, data, **kwargs):
        """Post-processing of the SideviewAtTimeSchema class."""

        return _SideviewAtTimeCalculationRequest(**data)


class _SetPhaseToReleaseForReliefValveScenarioCalculationRequestSchema(Schema):
    """Schema for the SetPhaseToReleaseForReliefValveScenario calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    phase_to_release = fields.Enum(Phase, by_value=True, data_key="phaseToRelease")
    release_elevation = fields.Float(data_key="releaseElevation")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_phase_to_release_for_relief_valve_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForReliefValveScenarioSchema class."""

        return _SetPhaseToReleaseForReliefValveScenarioCalculationRequest(**data)


class _DistancesAndFootprintsToConcentrationLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesAndFootprintsToConcentrationLevels calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionOutputConfigs")
    dispersion_output_config_count = fields.Int(data_key="dispersionOutputConfigCount")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    material = fields.Nested(MaterialSchema, data_key="material")

    @post_load
    def make_distances_and_footprints_to_concentration_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesAndFootprintsToConcentrationLevelsSchema class."""

        return _DistancesAndFootprintsToConcentrationLevelsCalculationRequest(**data)


class _VesselLeakMaxFlammableCloudCalculationRequestSchema(Schema):
    """Schema for the VesselLeakMaxFlammableCloud calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")

    @post_load
    def make_vessel_leak_max_flammable_cloud_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakMaxFlammableCloudSchema class."""

        return _VesselLeakMaxFlammableCloudCalculationRequest(**data)


class _PoolFireCalculationRequestSchema(Schema):
    """Schema for the PoolFire calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    pool_records = fields.Nested(PoolRecordSchema, allow_none=True, many=True, data_key="poolRecords")
    pool_record_count = fields.Int(data_key="poolRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")

    @post_load
    def make_pool_fire_calculation_request(self, data, **kwargs):
        """Post-processing of the PoolFireSchema class."""

        return _PoolFireCalculationRequest(**data)


class _DistancesToRadiationLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesToRadiationLevels calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_distances_to_radiation_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesToRadiationLevelsSchema class."""

        return _DistancesToRadiationLevelsCalculationRequest(**data)


class _FlashCalculationRequestSchema(Schema):
    """Schema for the Flash calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    material_state = fields.Nested(StateSchema, data_key="materialState")

    @post_load
    def make_flash_calculation_request(self, data, **kwargs):
        """Post-processing of the FlashSchema class."""

        return _FlashCalculationRequest(**data)


class _VesselLeakFlamToxSimpleLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselLeakFlamToxSimpleLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    mole_fraction_toxic = fields.Float(data_key="moleFractionToxic")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_leak_flam_tox_simple_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakFlamToxSimpleLinkedRunSchema class."""

        return _VesselLeakFlamToxSimpleLinkedRunCalculationRequest(**data)


class _MaxConcDistanceCalculationRequestSchema(Schema):
    """Schema for the MaxConcDistance calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_max_conc_distance_calculation_request(self, data, **kwargs):
        """Post-processing of the MaxConcDistanceSchema class."""

        return _MaxConcDistanceCalculationRequest(**data)


class _MixtureConstantPropertiesCalculationRequestSchema(Schema):
    """Schema for the MixtureConstantProperties calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")

    @post_load
    def make_mixture_constant_properties_calculation_request(self, data, **kwargs):
        """Post-processing of the MixtureConstantPropertiesSchema class."""

        return _MixtureConstantPropertiesCalculationRequest(**data)


class _UserDefinedSourceLinkedRunCalculationRequestSchema(Schema):
    """Schema for the UserDefinedSourceLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    phase_to_be_released = fields.Enum(Phase, by_value=True, data_key="phaseToBeReleased")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_user_defined_source_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the UserDefinedSourceLinkedRunSchema class."""

        return _UserDefinedSourceLinkedRunCalculationRequest(**data)


class _UDSSetLiqFracFromTemperatureCalculationRequestSchema(Schema):
    """Schema for the UDSSetLiqFracFromTemperature calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    phase_to_be_released = fields.Enum(Phase, by_value=True, data_key="phaseToBeReleased")
    temperature = fields.Float(data_key="temperature")

    @post_load
    def make_uds_set_liq_frac_from_temperature_calculation_request(self, data, **kwargs):
        """Post-processing of the UDSSetLiqFracFromTemperatureSchema class."""

        return _UDSSetLiqFracFromTemperatureCalculationRequest(**data)


class _RadiationTransectCalculationRequestSchema(Schema):
    """Schema for the RadiationTransect calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_transect_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationTransectSchema class."""

        return _RadiationTransectCalculationRequest(**data)


class _RadiationTransectForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the RadiationTransectForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_transect_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationTransectForPoolFiresSchema class."""

        return _RadiationTransectForPoolFiresCalculationRequest(**data)


class _VesselLeakCalculationRequestSchema(Schema):
    """Schema for the VesselLeak calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_leak_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakSchema class."""

        return _VesselLeakCalculationRequest(**data)


class _VesselLineRuptureLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselLineRuptureLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    line_rupture = fields.Nested(LineRuptureSchema, data_key="lineRupture")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_line_rupture_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureLinkedRunSchema class."""

        return _VesselLineRuptureLinkedRunCalculationRequest(**data)


class _SetMixingLayerHeightCalculationRequestSchema(Schema):
    """Schema for the SetMixingLayerHeight calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    weather = fields.Nested(WeatherSchema, data_key="weather")

    @post_load
    def make_set_mixing_layer_height_calculation_request(self, data, **kwargs):
        """Post-processing of the SetMixingLayerHeightSchema class."""

        return _SetMixingLayerHeightCalculationRequest(**data)


class _UDSSetTemperatureFromLiqFracCalculationRequestSchema(Schema):
    """Schema for the UDSSetTemperatureFromLiqFrac calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    phase_to_be_released = fields.Enum(Phase, by_value=True, data_key="phaseToBeReleased")
    liquid_fraction = fields.Float(data_key="liquidFraction")

    @post_load
    def make_uds_set_temperature_from_liq_frac_calculation_request(self, data, **kwargs):
        """Post-processing of the UDSSetTemperatureFromLiqFracSchema class."""

        return _UDSSetTemperatureFromLiqFracCalculationRequest(**data)


class _LoadMassInventoryVesselForReliefValveScenarioCalculationRequestSchema(Schema):
    """Schema for the LoadMassInventoryVesselForReliefValveScenario calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    mass = fields.Float(data_key="mass")
    pressure = fields.Float(data_key="pressure")
    temperature = fields.Float(data_key="temperature")
    constriction_size = fields.Float(data_key="constrictionSize")
    pipe_diameter = fields.Float(data_key="pipeDiameter")
    pipe_length = fields.Float(data_key="pipeLength")
    release_elevation = fields.Float(data_key="releaseElevation")
    release_angle = fields.Float(data_key="releaseAngle")

    @post_load
    def make_load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForReliefValveScenarioSchema class."""

        return _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest(**data)


class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevelsForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsForPoolFiresSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest(**data)


class _GetMassFromVesselCalculationRequestSchema(Schema):
    """Schema for the GetMassFromVessel calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_get_mass_from_vessel_calculation_request(self, data, **kwargs):
        """Post-processing of the GetMassFromVesselSchema class."""

        return _GetMassFromVesselCalculationRequest(**data)


class _UDSTemperatureLimitsCalculationRequestSchema(Schema):
    """Schema for the UDSTemperatureLimits calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    phase_to_be_released = fields.Enum(Phase, by_value=True, data_key="phaseToBeReleased")

    @post_load
    def make_uds_temperature_limits_calculation_request(self, data, **kwargs):
        """Post-processing of the UDSTemperatureLimitsSchema class."""

        return _UDSTemperatureLimitsCalculationRequest(**data)


class _MaxConcFootprintCalculationRequestSchema(Schema):
    """Schema for the MaxConcFootprint calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_max_conc_footprint_calculation_request(self, data, **kwargs):
        """Post-processing of the MaxConcFootprintSchema class."""

        return _MaxConcFootprintCalculationRequest(**data)


class _DistancesToConcLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesToConcLevels calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionOutputConfigs")
    dispersion_output_config_count = fields.Int(data_key="dispersionOutputConfigCount")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_distances_to_conc_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesToConcLevelsSchema class."""

        return _DistancesToConcLevelsCalculationRequest(**data)


class _JetFireCalculationRequestSchema(Schema):
    """Schema for the JetFire calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")

    @post_load
    def make_jet_fire_calculation_request(self, data, **kwargs):
        """Post-processing of the JetFireSchema class."""

        return _JetFireCalculationRequest(**data)


class _RadiationAtAPointForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the RadiationAtAPointForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_at_apoint_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointForPoolFiresSchema class."""

        return _RadiationAtAPointForPoolFiresCalculationRequest(**data)


class _ConvertCompositionMoleToMassCalculationRequestSchema(Schema):
    """Schema for the ConvertCompositionMoleToMass calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mixture = fields.Nested(MaterialSchema, data_key="mixture")
    composition_moles = fields.List(fields.Float, allow_none=True, many=True, data_key="compositionMoles")
    composition_moles_count = fields.Int(data_key="compositionMolesCount")

    @post_load
    def make_convert_composition_mole_to_mass_calculation_request(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMoleToMassSchema class."""

        return _ConvertCompositionMoleToMassCalculationRequest(**data)


class _FireballCalculationRequestSchema(Schema):
    """Schema for the Fireball calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    state = fields.Nested(StateSchema, data_key="state")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    weather = fields.Nested(WeatherSchema, data_key="weather")

    @post_load
    def make_fireball_calculation_request(self, data, **kwargs):
        """Post-processing of the FireballSchema class."""

        return _FireballCalculationRequest(**data)


class _FlareStackDesignerCalculationRequestSchema(Schema):
    """Schema for the FlareStackDesigner calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flare_stack = fields.Nested(FlareStackSchema, data_key="flareStack")
    flare_stack_constraint = fields.Nested(ConstraintSchema, data_key="flareStackConstraint")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_flare_stack_designer_calculation_request(self, data, **kwargs):
        """Post-processing of the FlareStackDesignerSchema class."""

        return _FlareStackDesignerCalculationRequest(**data)


class _LateExplosionToOPLevelsCalculationRequestSchema(Schema):
    """Schema for the LateExplosionToOPLevels calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_late_explosion_to_oplevels_calculation_request(self, data, **kwargs):
        """Post-processing of the LateExplosionToOPLevelsSchema class."""

        return _LateExplosionToOPLevelsCalculationRequest(**data)


class _LethalityDistanceCalculationRequestSchema(Schema):
    """Schema for the LethalityDistance calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_lethality_distance_calculation_request(self, data, **kwargs):
        """Post-processing of the LethalityDistanceSchema class."""

        return _LethalityDistanceCalculationRequest(**data)


class _RadiationAtPointsForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the RadiationAtPointsForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_radiation_at_points_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsForPoolFiresSchema class."""

        return _RadiationAtPointsForPoolFiresCalculationRequest(**data)


class _VesselReliefValveLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselReliefValveLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    relief_valve = fields.Nested(ReliefValveSchema, data_key="reliefValve")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_relief_valve_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselReliefValveLinkedRunSchema class."""

        return _VesselReliefValveLinkedRunCalculationRequest(**data)


class _DispersionCalculationRequestSchema(Schema):
    """Schema for the Dispersion calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    end_point_concentration = fields.Float(data_key="endPointConcentration")

    @post_load
    def make_dispersion_calculation_request(self, data, **kwargs):
        """Post-processing of the DispersionSchema class."""

        return _DispersionCalculationRequest(**data)


class _SetPhaseToReleaseForLineRuptureScenarioCalculationRequestSchema(Schema):
    """Schema for the SetPhaseToReleaseForLineRuptureScenario calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    phase_to_release = fields.Enum(Phase, by_value=True, data_key="phaseToRelease")
    release_elevation = fields.Float(data_key="releaseElevation")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_phase_to_release_for_line_rupture_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLineRuptureScenarioSchema class."""

        return _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest(**data)


class _SetReleaseElevationForScenarioCalculationRequestSchema(Schema):
    """Schema for the SetReleaseElevationForScenario calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    release_elevation = fields.Float(data_key="releaseElevation")
    release_height_fraction = fields.Float(data_key="releaseHeightFraction")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_release_elevation_for_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetReleaseElevationForScenarioSchema class."""

        return _SetReleaseElevationForScenarioCalculationRequest(**data)


class _VesselReliefValveCalculationRequestSchema(Schema):
    """Schema for the VesselReliefValve calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    relief_valve = fields.Nested(ReliefValveSchema, data_key="reliefValve")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_relief_valve_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselReliefValveSchema class."""

        return _VesselReliefValveCalculationRequest(**data)


class _ConcentrationAtPointCalculationRequestSchema(Schema):
    """Schema for the ConcentrationAtPoint calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_concentration_at_point_calculation_request(self, data, **kwargs):
        """Post-processing of the ConcentrationAtPointSchema class."""

        return _ConcentrationAtPointCalculationRequest(**data)


class _VesselStateCalculationRequestSchema(Schema):
    """Schema for the VesselState calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    material_state = fields.Nested(StateSchema, data_key="materialState")

    @post_load
    def make_vessel_state_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselStateSchema class."""

        return _VesselStateCalculationRequest(**data)


class _DistanceToRadiationCalculationRequestSchema(Schema):
    """Schema for the DistanceToRadiation calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_distance_to_radiation_calculation_request(self, data, **kwargs):
        """Post-processing of the DistanceToRadiationSchema class."""

        return _DistanceToRadiationCalculationRequest(**data)


class _ConvertCompositionMassToMoleCalculationRequestSchema(Schema):
    """Schema for the ConvertCompositionMassToMole calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mixture = fields.Nested(MaterialSchema, data_key="mixture")
    composition_mass = fields.List(fields.Float, allow_none=True, many=True, data_key="compositionMass")
    composition_mass_count = fields.Int(data_key="compositionMassCount")

    @post_load
    def make_convert_composition_mass_to_mole_calculation_request(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMassToMoleSchema class."""

        return _ConvertCompositionMassToMoleCalculationRequest(**data)


class _LongPipeBreachCalculationRequestSchema(Schema):
    """Schema for the LongPipeBreach calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pipe = fields.Nested(PipeSchema, data_key="pipe")
    pipe_breach = fields.Nested(PipeBreachSchema, data_key="pipeBreach")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_long_pipe_breach_calculation_request(self, data, **kwargs):
        """Post-processing of the LongPipeBreachSchema class."""

        return _LongPipeBreachCalculationRequest(**data)


class _RadiationAtPointsCalculationRequestSchema(Schema):
    """Schema for the RadiationAtPoints calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_radiation_at_points_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsSchema class."""

        return _RadiationAtPointsCalculationRequest(**data)


class _VesselLeakLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselLeakLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_leak_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakLinkedRunSchema class."""

        return _VesselLeakLinkedRunCalculationRequest(**data)


class _SetPhaseToReleaseForLeakScenarioCalculationRequestSchema(Schema):
    """Schema for the SetPhaseToReleaseForLeakScenario calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    phase_to_release = fields.Enum(Phase, by_value=True, data_key="phaseToRelease")
    release_elevation = fields.Float(data_key="releaseElevation")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_phase_to_release_for_leak_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLeakScenarioSchema class."""

        return _SetPhaseToReleaseForLeakScenarioCalculationRequest(**data)


class _VesselLeakFlammableLinkedRunH2CalculationRequestSchema(Schema):
    """Schema for the VesselLeakFlammableLinkedRunH2 calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionOutputConfigs")
    dispersion_output_config_count = fields.Int(data_key="dispersionOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_leak_flammable_linked_run_h2_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakFlammableLinkedRunH2Schema class."""

        return _VesselLeakFlammableLinkedRunH2CalculationRequest(**data)


class _LoadMassInventoryVesselForLeakScenarioCalculationRequestSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLeakScenario calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    mass = fields.Float(data_key="mass")
    pressure = fields.Float(data_key="pressure")
    temperature = fields.Float(data_key="temperature")
    hole_size = fields.Float(data_key="holeSize")
    release_elevation = fields.Float(data_key="releaseElevation")
    release_angle = fields.Float(data_key="releaseAngle")

    @post_load
    def make_load_mass_inventory_vessel_for_leak_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLeakScenarioSchema class."""

        return _LoadMassInventoryVesselForLeakScenarioCalculationRequest(**data)


class _MaxDistanceToConcCalculationRequestSchema(Schema):
    """Schema for the MaxDistanceToConc calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_max_distance_to_conc_calculation_request(self, data, **kwargs):
        """Post-processing of the MaxDistanceToConcSchema class."""

        return _MaxDistanceToConcCalculationRequest(**data)


class _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequestSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLineRuptureScenario calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    mass = fields.Float(data_key="mass")
    pressure = fields.Float(data_key="pressure")
    temperature = fields.Float(data_key="temperature")
    pipe_diameter = fields.Float(data_key="pipeDiameter")
    pipe_length = fields.Float(data_key="pipeLength")
    release_elevation = fields.Float(data_key="releaseElevation")
    release_angle = fields.Float(data_key="releaseAngle")

    @post_load
    def make_load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLineRuptureScenarioSchema class."""

        return _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest(**data)


class _ReliefValveMinTemperatureCalculationRequestSchema(Schema):
    """Schema for the ReliefValveMinTemperature calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    pressure = fields.Float(data_key="pressure")

    @post_load
    def make_relief_valve_min_temperature_calculation_request(self, data, **kwargs):
        """Post-processing of the ReliefValveMinTemperatureSchema class."""

        return _ReliefValveMinTemperatureCalculationRequest(**data)


class _VesselLineRuptureCalculationRequestSchema(Schema):
    """Schema for the VesselLineRupture calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    line_rupture = fields.Nested(LineRuptureSchema, data_key="lineRupture")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_line_rupture_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureSchema class."""

        return _VesselLineRuptureCalculationRequest(**data)


class _DistancesAndEllipsesToRadiationLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevels calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_distances_and_ellipses_to_radiation_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsCalculationRequest(**data)


class _RadiationAtAPointCalculationRequestSchema(Schema):
    """Schema for the RadiationAtAPoint calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_at_apoint_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointSchema class."""

        return _RadiationAtAPointCalculationRequest(**data)


class _TankFireCalculationRequestSchema(Schema):
    """Schema for the TankFire calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    atmospheric_storage_tank = fields.Nested(AtmosphericStorageTankSchema, data_key="atmosphericStorageTank")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")

    @post_load
    def make_tank_fire_calculation_request(self, data, **kwargs):
        """Post-processing of the TankFireSchema class."""

        return _TankFireCalculationRequest(**data)


class _VesselCatastrophicRuptureCalculationRequestSchema(Schema):
    """Schema for the VesselCatastrophicRupture calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_catastrophic_rupture_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselCatastrophicRuptureSchema class."""

        return _VesselCatastrophicRuptureCalculationRequest(**data)


class _RadiationContourCalculationRequestSchema(Schema):
    """Schema for the RadiationContour calculation request, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_contour_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationContourSchema class."""

        return _RadiationContourCalculationRequest(**data)



class _LateExplosionCalculationResponseSchema(Schema):
    """Schema for the LateExplosion calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    explosion_unif_conf_overpressure_result = fields.Nested(ExplosionOverpressureResultSchema, data_key="explosionUnifConfOverpressureResult")
    explosion_unconf_overpressure_result = fields.Nested(ExplosionOverpressureResultSchema, data_key="explosionUnconfOverpressureResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_late_explosion_calculation_response(self, data, **kwargs):
        """Post-processing of the LateExplosionSchema class."""

        return _LateExplosionCalculationResponse(**data)


class _VesselLeakFlammableLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselLeakFlammableLinkedRun calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    njet_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nJetContourPoints")
    area_ellipse_jet = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipseJet")
    distances_to_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToConcentration")
    concentrations_used = fields.List(fields.Float, allow_none=True, many=True, data_key="concentrationsUsed")
    conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="concContourPoints")
    nconc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nConcContourPoints")
    area_footprint_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    npool_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nPoolContourPoints")
    area_ellipse_pool = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipsePool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_leak_flammable_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakFlammableLinkedRunSchema class."""

        return _VesselLeakFlammableLinkedRunCalculationResponse(**data)


class _SideviewAtTimeCalculationResponseSchema(Schema):
    """Schema for the SideviewAtTime calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_sideview_at_time_calculation_response(self, data, **kwargs):
        """Post-processing of the SideviewAtTimeSchema class."""

        return _SideviewAtTimeCalculationResponse(**data)


class _SetPhaseToReleaseForReliefValveScenarioCalculationResponseSchema(Schema):
    """Schema for the SetPhaseToReleaseForReliefValveScenario calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    zcoord_updated = fields.Float(data_key="zCoordUpdated")
    pipe_height_fraction_updated = fields.Float(data_key="pipeHeightFractionUpdated")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_set_phase_to_release_for_relief_valve_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForReliefValveScenarioSchema class."""

        return _SetPhaseToReleaseForReliefValveScenarioCalculationResponse(**data)


class _DistancesAndFootprintsToConcentrationLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesAndFootprintsToConcentrationLevels calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    concs_used = fields.List(fields.Float, allow_none=True, many=True, data_key="concsUsed")
    ncontour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nContourPoints")
    areas_contour = fields.List(fields.Float, allow_none=True, many=True, data_key="areasContour")
    distances_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesConcentration")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_distances_and_footprints_to_concentration_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesAndFootprintsToConcentrationLevelsSchema class."""

        return _DistancesAndFootprintsToConcentrationLevelsCalculationResponse(**data)


class _VesselLeakMaxFlammableCloudCalculationResponseSchema(Schema):
    """Schema for the VesselLeakMaxFlammableCloud calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel_leak_max_flammable_cloud_results = fields.Nested(VesselLeakMaxFlammableCloudResultsSchema, data_key="vesselLeakMaxFlammableCloudResults")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_leak_max_flammable_cloud_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakMaxFlammableCloudSchema class."""

        return _VesselLeakMaxFlammableCloudCalculationResponse(**data)


class _PoolFireCalculationResponseSchema(Schema):
    """Schema for the PoolFire calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_pool_fire_calculation_response(self, data, **kwargs):
        """Post-processing of the PoolFireSchema class."""

        return _PoolFireCalculationResponse(**data)


class _DistancesToRadiationLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesToRadiationLevels calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances = fields.List(fields.Float, allow_none=True, many=True, data_key="distances")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_distances_to_radiation_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesToRadiationLevelsSchema class."""

        return _DistancesToRadiationLevelsCalculationResponse(**data)


class _FlashCalculationResponseSchema(Schema):
    """Schema for the Flash calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flash_result = fields.Nested(FlashResultSchema, data_key="flashResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_flash_calculation_response(self, data, **kwargs):
        """Post-processing of the FlashSchema class."""

        return _FlashCalculationResponse(**data)


class _VesselLeakFlamToxSimpleLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselLeakFlamToxSimpleLinkedRun calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    njet_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nJetContourPoints")
    area_ellipse_jet = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipseJet")
    distances_to_flam_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float, allow_none=True, many=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    nflam_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    npool_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nPoolContourPoints")
    area_ellipse_pool = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipsePool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float, allow_none=True, many=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    ntoxic_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_leak_flam_tox_simple_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakFlamToxSimpleLinkedRunSchema class."""

        return _VesselLeakFlamToxSimpleLinkedRunCalculationResponse(**data)


class _MaxConcDistanceCalculationResponseSchema(Schema):
    """Schema for the MaxConcDistance calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    concentration_records = fields.Nested(ConcentrationRecordSchema, allow_none=True, many=True, data_key="concentrationRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_max_conc_distance_calculation_response(self, data, **kwargs):
        """Post-processing of the MaxConcDistanceSchema class."""

        return _MaxConcDistanceCalculationResponse(**data)


class _MixtureConstantPropertiesCalculationResponseSchema(Schema):
    """Schema for the MixtureConstantProperties calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mix_constant_prop_result = fields.Nested(MixtureConstantPropertiesResultSchema, data_key="mixConstantPropResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_mixture_constant_properties_calculation_response(self, data, **kwargs):
        """Post-processing of the MixtureConstantPropertiesSchema class."""

        return _MixtureConstantPropertiesCalculationResponse(**data)


class _UserDefinedSourceLinkedRunCalculationResponseSchema(Schema):
    """Schema for the UserDefinedSourceLinkedRun calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances_to_jet_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    njet_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float, allow_none=True, many=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float, allow_none=True, many=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    nflam_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    npool_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float, allow_none=True, many=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float, allow_none=True, many=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    ntoxic_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_user_defined_source_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the UserDefinedSourceLinkedRunSchema class."""

        return _UserDefinedSourceLinkedRunCalculationResponse(**data)


class _UDSSetLiqFracFromTemperatureCalculationResponseSchema(Schema):
    """Schema for the UDSSetLiqFracFromTemperature calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    liquid_fraction = fields.Float(data_key="liquidFraction")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_uds_set_liq_frac_from_temperature_calculation_response(self, data, **kwargs):
        """Post-processing of the UDSSetLiqFracFromTemperatureSchema class."""

        return _UDSSetLiqFracFromTemperatureCalculationResponse(**data)


class _RadiationTransectCalculationResponseSchema(Schema):
    """Schema for the RadiationTransect calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation_records = fields.Nested(RadiationRecordSchema, allow_none=True, many=True, data_key="radiationRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_radiation_transect_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationTransectSchema class."""

        return _RadiationTransectCalculationResponse(**data)


class _RadiationTransectForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the RadiationTransectForPoolFires calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation_records = fields.Nested(RadiationRecordSchema, allow_none=True, many=True, data_key="radiationRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_radiation_transect_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationTransectForPoolFiresSchema class."""

        return _RadiationTransectForPoolFiresCalculationResponse(**data)


class _VesselLeakCalculationResponseSchema(Schema):
    """Schema for the VesselLeak calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_leak_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakSchema class."""

        return _VesselLeakCalculationResponse(**data)


class _VesselLineRuptureLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselLineRuptureLinkedRun calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    njet_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float, allow_none=True, many=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float, allow_none=True, many=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    nflam_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    npool_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float, allow_none=True, many=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float, allow_none=True, many=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    ntoxic_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_line_rupture_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureLinkedRunSchema class."""

        return _VesselLineRuptureLinkedRunCalculationResponse(**data)


class _SetMixingLayerHeightCalculationResponseSchema(Schema):
    """Schema for the SetMixingLayerHeight calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    updated_weather = fields.Nested(WeatherSchema, data_key="updatedWeather")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_set_mixing_layer_height_calculation_response(self, data, **kwargs):
        """Post-processing of the SetMixingLayerHeightSchema class."""

        return _SetMixingLayerHeightCalculationResponse(**data)


class _UDSSetTemperatureFromLiqFracCalculationResponseSchema(Schema):
    """Schema for the UDSSetTemperatureFromLiqFrac calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    temperature = fields.Float(data_key="temperature")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_uds_set_temperature_from_liq_frac_calculation_response(self, data, **kwargs):
        """Post-processing of the UDSSetTemperatureFromLiqFracSchema class."""

        return _UDSSetTemperatureFromLiqFracCalculationResponse(**data)


class _LoadMassInventoryVesselForReliefValveScenarioCalculationResponseSchema(Schema):
    """Schema for the LoadMassInventoryVesselForReliefValveScenario calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    relief_valve = fields.Nested(ReliefValveSchema, data_key="reliefValve")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForReliefValveScenarioSchema class."""

        return _LoadMassInventoryVesselForReliefValveScenarioCalculationResponse(**data)


class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevelsForPoolFires calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances = fields.List(fields.Float, allow_none=True, many=True, data_key="distances")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    ncontour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nContourPoints")
    areas = fields.List(fields.Float, allow_none=True, many=True, data_key="areas")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsForPoolFiresSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse(**data)


class _GetMassFromVesselCalculationResponseSchema(Schema):
    """Schema for the GetMassFromVessel calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mass_inventory = fields.Float(data_key="massInventory")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_get_mass_from_vessel_calculation_response(self, data, **kwargs):
        """Post-processing of the GetMassFromVesselSchema class."""

        return _GetMassFromVesselCalculationResponse(**data)


class _UDSTemperatureLimitsCalculationResponseSchema(Schema):
    """Schema for the UDSTemperatureLimits calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    min_temperature = fields.Float(data_key="minTemperature")
    max_temperature = fields.Float(data_key="maxTemperature")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_uds_temperature_limits_calculation_response(self, data, **kwargs):
        """Post-processing of the UDSTemperatureLimitsSchema class."""

        return _UDSTemperatureLimitsCalculationResponse(**data)


class _MaxConcFootprintCalculationResponseSchema(Schema):
    """Schema for the MaxConcFootprint calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_max_conc_footprint_calculation_response(self, data, **kwargs):
        """Post-processing of the MaxConcFootprintSchema class."""

        return _MaxConcFootprintCalculationResponse(**data)


class _DistancesToConcLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesToConcLevels calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.List(fields.Float, allow_none=True, many=True, data_key="concUsed")
    distances = fields.List(fields.Float, allow_none=True, many=True, data_key="distances")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_distances_to_conc_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesToConcLevelsSchema class."""

        return _DistancesToConcLevelsCalculationResponse(**data)


class _JetFireCalculationResponseSchema(Schema):
    """Schema for the JetFire calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_jet_fire_calculation_response(self, data, **kwargs):
        """Post-processing of the JetFireSchema class."""

        return _JetFireCalculationResponse(**data)


class _RadiationAtAPointForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the RadiationAtAPointForPoolFires calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.Float(data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_radiation_at_apoint_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointForPoolFiresSchema class."""

        return _RadiationAtAPointForPoolFiresCalculationResponse(**data)


class _ConvertCompositionMoleToMassCalculationResponseSchema(Schema):
    """Schema for the ConvertCompositionMoleToMass calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    composition_mass = fields.List(fields.Float, allow_none=True, many=True, data_key="compositionMass")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_convert_composition_mole_to_mass_calculation_response(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMoleToMassSchema class."""

        return _ConvertCompositionMoleToMassCalculationResponse(**data)


class _FireballCalculationResponseSchema(Schema):
    """Schema for the Fireball calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_fireball_calculation_response(self, data, **kwargs):
        """Post-processing of the FireballSchema class."""

        return _FireballCalculationResponse(**data)


class _FlareStackDesignerCalculationResponseSchema(Schema):
    """Schema for the FlareStackDesigner calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    design_solution = fields.Float(data_key="designSolution")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_flare_stack_designer_calculation_response(self, data, **kwargs):
        """Post-processing of the FlareStackDesignerSchema class."""

        return _FlareStackDesignerCalculationResponse(**data)


class _LateExplosionToOPLevelsCalculationResponseSchema(Schema):
    """Schema for the LateExplosionToOPLevels calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    explosion_unif_conf_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionUnifConfOverpressureResults")
    explosion_unconf_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionUnconfOverpressureResults")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_late_explosion_to_oplevels_calculation_response(self, data, **kwargs):
        """Post-processing of the LateExplosionToOPLevelsSchema class."""

        return _LateExplosionToOPLevelsCalculationResponse(**data)


class _LethalityDistanceCalculationResponseSchema(Schema):
    """Schema for the LethalityDistance calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    toxic_records = fields.Nested(ToxicRecordSchema, allow_none=True, many=True, data_key="toxicRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_lethality_distance_calculation_response(self, data, **kwargs):
        """Post-processing of the LethalityDistanceSchema class."""

        return _LethalityDistanceCalculationResponse(**data)


class _RadiationAtPointsForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the RadiationAtPointsForPoolFires calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_radiation_at_points_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsForPoolFiresSchema class."""

        return _RadiationAtPointsForPoolFiresCalculationResponse(**data)


class _VesselReliefValveLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselReliefValveLinkedRun calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    njet_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float, allow_none=True, many=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float, allow_none=True, many=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    nflam_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    npool_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float, allow_none=True, many=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float, allow_none=True, many=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    ntoxic_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_relief_valve_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselReliefValveLinkedRunSchema class."""

        return _VesselReliefValveLinkedRunCalculationResponse(**data)


class _DispersionCalculationResponseSchema(Schema):
    """Schema for the Dispersion calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    pool_records = fields.Nested(PoolRecordSchema, allow_none=True, many=True, data_key="poolRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_dispersion_calculation_response(self, data, **kwargs):
        """Post-processing of the DispersionSchema class."""

        return _DispersionCalculationResponse(**data)


class _SetPhaseToReleaseForLineRuptureScenarioCalculationResponseSchema(Schema):
    """Schema for the SetPhaseToReleaseForLineRuptureScenario calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    zcoord_updated = fields.Float(data_key="zCoordUpdated")
    pipe_height_fraction_updated = fields.Float(data_key="pipeHeightFractionUpdated")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_set_phase_to_release_for_line_rupture_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLineRuptureScenarioSchema class."""

        return _SetPhaseToReleaseForLineRuptureScenarioCalculationResponse(**data)


class _SetReleaseElevationForScenarioCalculationResponseSchema(Schema):
    """Schema for the SetReleaseElevationForScenario calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    updated_vessel = fields.Nested(VesselSchema, data_key="updatedVessel")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_set_release_elevation_for_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetReleaseElevationForScenarioSchema class."""

        return _SetReleaseElevationForScenarioCalculationResponse(**data)


class _VesselReliefValveCalculationResponseSchema(Schema):
    """Schema for the VesselReliefValve calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_relief_valve_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselReliefValveSchema class."""

        return _VesselReliefValveCalculationResponse(**data)


class _ConcentrationAtPointCalculationResponseSchema(Schema):
    """Schema for the ConcentrationAtPoint calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    concentration = fields.Float(data_key="concentration")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_concentration_at_point_calculation_response(self, data, **kwargs):
        """Post-processing of the ConcentrationAtPointSchema class."""

        return _ConcentrationAtPointCalculationResponse(**data)


class _VesselStateCalculationResponseSchema(Schema):
    """Schema for the VesselState calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel_conditions = fields.Enum(VesselConditions, by_value=True, data_key="vesselConditions")
    output_state = fields.Nested(StateSchema, data_key="outputState")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_state_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselStateSchema class."""

        return _VesselStateCalculationResponse(**data)


class _DistanceToRadiationCalculationResponseSchema(Schema):
    """Schema for the DistanceToRadiation calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distance = fields.Float(data_key="distance")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_distance_to_radiation_calculation_response(self, data, **kwargs):
        """Post-processing of the DistanceToRadiationSchema class."""

        return _DistanceToRadiationCalculationResponse(**data)


class _ConvertCompositionMassToMoleCalculationResponseSchema(Schema):
    """Schema for the ConvertCompositionMassToMole calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    composition_mole = fields.List(fields.Float, allow_none=True, many=True, data_key="compositionMole")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_convert_composition_mass_to_mole_calculation_response(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMassToMoleSchema class."""

        return _ConvertCompositionMassToMoleCalculationResponse(**data)


class _LongPipeBreachCalculationResponseSchema(Schema):
    """Schema for the LongPipeBreach calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_long_pipe_breach_calculation_response(self, data, **kwargs):
        """Post-processing of the LongPipeBreachSchema class."""

        return _LongPipeBreachCalculationResponse(**data)


class _RadiationAtPointsCalculationResponseSchema(Schema):
    """Schema for the RadiationAtPoints calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_radiation_at_points_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsSchema class."""

        return _RadiationAtPointsCalculationResponse(**data)


class _VesselLeakLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselLeakLinkedRun calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    njet_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nJetContourPoints")
    area_ellipse_jet = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipseJet")
    distances_to_flam_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float, allow_none=True, many=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    nflam_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    npool_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nPoolContourPoints")
    area_ellipse_pool = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipsePool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float, allow_none=True, many=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    ntoxic_conc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_leak_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakLinkedRunSchema class."""

        return _VesselLeakLinkedRunCalculationResponse(**data)


class _SetPhaseToReleaseForLeakScenarioCalculationResponseSchema(Schema):
    """Schema for the SetPhaseToReleaseForLeakScenario calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    zcoord_updated = fields.Float(data_key="zCoordUpdated")
    hole_height_fraction_updated = fields.Float(data_key="holeHeightFractionUpdated")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_set_phase_to_release_for_leak_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLeakScenarioSchema class."""

        return _SetPhaseToReleaseForLeakScenarioCalculationResponse(**data)


class _VesselLeakFlammableLinkedRunH2CalculationResponseSchema(Schema):
    """Schema for the VesselLeakFlammableLinkedRunH2 calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    njet_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nJetContourPoints")
    area_ellipse_jet = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipseJet")
    distances_to_concentration = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToConcentration")
    concentrations_used = fields.List(fields.Float, allow_none=True, many=True, data_key="concentrationsUsed")
    conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="concContourPoints")
    nconc_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nConcContourPoints")
    area_footprint_conc = fields.List(fields.Float, allow_none=True, many=True, data_key="areaFootprintConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float, allow_none=True, many=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    npool_contour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nPoolContourPoints")
    area_ellipse_pool = fields.List(fields.Float, allow_none=True, many=True, data_key="areaEllipsePool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_leak_flammable_linked_run_h2_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakFlammableLinkedRunH2Schema class."""

        return _VesselLeakFlammableLinkedRunH2CalculationResponse(**data)


class _LoadMassInventoryVesselForLeakScenarioCalculationResponseSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLeakScenario calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_load_mass_inventory_vessel_for_leak_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLeakScenarioSchema class."""

        return _LoadMassInventoryVesselForLeakScenarioCalculationResponse(**data)


class _MaxDistanceToConcCalculationResponseSchema(Schema):
    """Schema for the MaxDistanceToConc calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    distance = fields.Float(data_key="distance")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_max_distance_to_conc_calculation_response(self, data, **kwargs):
        """Post-processing of the MaxDistanceToConcSchema class."""

        return _MaxDistanceToConcCalculationResponse(**data)


class _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponseSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLineRuptureScenario calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    line_rupture = fields.Nested(LineRuptureSchema, data_key="lineRupture")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLineRuptureScenarioSchema class."""

        return _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse(**data)


class _ReliefValveMinTemperatureCalculationResponseSchema(Schema):
    """Schema for the ReliefValveMinTemperature calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    min_temperature = fields.Float(data_key="minTemperature")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_relief_valve_min_temperature_calculation_response(self, data, **kwargs):
        """Post-processing of the ReliefValveMinTemperatureSchema class."""

        return _ReliefValveMinTemperatureCalculationResponse(**data)


class _VesselLineRuptureCalculationResponseSchema(Schema):
    """Schema for the VesselLineRupture calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_line_rupture_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureSchema class."""

        return _VesselLineRuptureCalculationResponse(**data)


class _DistancesAndEllipsesToRadiationLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevels calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances = fields.List(fields.Float, allow_none=True, many=True, data_key="distances")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    ncontour_points = fields.List(fields.Int, allow_none=True, many=True, data_key="nContourPoints")
    areas = fields.List(fields.Float, allow_none=True, many=True, data_key="areas")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_distances_and_ellipses_to_radiation_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsCalculationResponse(**data)


class _RadiationAtAPointCalculationResponseSchema(Schema):
    """Schema for the RadiationAtAPoint calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.Float(data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_radiation_at_apoint_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointSchema class."""

        return _RadiationAtAPointCalculationResponse(**data)


class _TankFireCalculationResponseSchema(Schema):
    """Schema for the TankFire calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_tank_fire_calculation_response(self, data, **kwargs):
        """Post-processing of the TankFireSchema class."""

        return _TankFireCalculationResponse(**data)


class _VesselCatastrophicRuptureCalculationResponseSchema(Schema):
    """Schema for the VesselCatastrophicRupture calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_vessel_catastrophic_rupture_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselCatastrophicRuptureSchema class."""

        return _VesselCatastrophicRuptureCalculationResponse(**data)


class _RadiationContourCalculationResponseSchema(Schema):
    """Schema for the RadiationContour calculation response, used by marshmallow in json serialization/deserialization"""
    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")

    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")

    @post_load
    def make_radiation_contour_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationContourSchema class."""

        return _RadiationContourCalculationResponse(**data)


class _LateExplosionCalculationRequest(_CalculationRequestBase):
    """
    _LateExplosion calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material with post-discharge composition.
	scalar_udm_outputs : ScalarUdmOutputs 
		Dispersion scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Cloud definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		Substrate.
	dispersion_output_config : DispersionOutputConfig 
		Specification of cloud view.
	explosion_output_config : ExplosionOutputConfig 
		Explosion output configuration.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_config: ExplosionOutputConfig, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _LateExplosionCalculationRequest class"""
        super().__init__()

        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_config = explosion_output_config
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters


class LateExplosionCalculation(_CalculationBase):
    """
    LateExplosion calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material with post-discharge composition.
	scalar_udm_outputs : ScalarUdmOutputs 
		Dispersion scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Cloud definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		Substrate.
	dispersion_output_config : DispersionOutputConfig 
		Specification of cloud view.
	explosion_output_config : ExplosionOutputConfig 
		Explosion output configuration.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	explosion_unif_conf_overpressure_result : ExplosionOverpressureResult 
		Uniform confined explosion overpressure result.
	explosion_unconf_overpressure_result : ExplosionOverpressureResult 
		Unconfined explosion overpressure result.
	result_code : ResultCode 
		Eror code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_config: ExplosionOutputConfig, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the LateExplosionCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_config = explosion_output_config
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.explosion_unif_conf_overpressure_result = None
        self.explosion_unconf_overpressure_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Late explosion calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        LateExplosionCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LateExplosionCalculationRequest object.
        late_explosion_calculation_request = _LateExplosionCalculationRequest(self.material, self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.explosion_output_config, self.explosion_parameters, self.explosion_confined_volumes, self.explosion_confined_volume_count, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        late_explosion_calculation_request_schema = _LateExplosionCalculationRequestSchema()

        request_json = late_explosion_calculation_request_schema.dumps(late_explosion_calculation_request)
        url = get_analytics_api_target() + 'calculatelateexplosion?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            late_explosion_calculation_response_schema = _LateExplosionCalculationResponseSchema()
            late_explosion_calculation_response = late_explosion_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(late_explosion_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.explosion_unif_conf_overpressure_result = late_explosion_calculation_response.explosion_unif_conf_overpressure_result
                self.explosion_unconf_overpressure_result = late_explosion_calculation_response.explosion_unconf_overpressure_result
                self.result_code = late_explosion_calculation_response.result_code
                self.messages = late_explosion_calculation_response.messages
                self.calculation_elapsed_time = late_explosion_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(late_explosion_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the LateExplosion calculation object"""

        parts = ['* LateExplosion']

        parts.append(f'explosion_unif_conf_overpressure_result: {str(self.explosion_unif_conf_overpressure_result)}')
        parts.append(f'explosion_unconf_overpressure_result: {str(self.explosion_unconf_overpressure_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _LateExplosionCalculationResponse(_CalculationResponseBase):
    """
    LateExplosion calculation response class.

    Attributes
    ----------
	explosion_unif_conf_overpressure_result : ExplosionOverpressureResult 
		Uniform confined explosion overpressure result.
	explosion_unconf_overpressure_result : ExplosionOverpressureResult 
		Unconfined explosion overpressure result.
	result_code : ResultCode 
		Eror code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, explosion_unif_conf_overpressure_result: ExplosionOverpressureResult, explosion_unconf_overpressure_result: ExplosionOverpressureResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the LateExplosionCalculationResponse class"""
        super().__init__()

        self.explosion_unif_conf_overpressure_result = explosion_unif_conf_overpressure_result
        self.explosion_unconf_overpressure_result = explosion_unconf_overpressure_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Late explosion calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'explosion_unif_conf_overpressure_result' in data and data['explosion_unif_conf_overpressure_result'] is not None:
            self.explosion_unif_conf_overpressure_result.initialise_from_dictionary(data['explosion_unif_conf_overpressure_result'])
        
        if 'explosion_unconf_overpressure_result' in data and data['explosion_unconf_overpressure_result'] is not None:
            self.explosion_unconf_overpressure_result.initialise_from_dictionary(data['explosion_unconf_overpressure_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLeakFlammableLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakFlammableLinkedRun calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Concentration levels.
	dispersion_output_config_count : int 
		Number of concentration levels.
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
    """
    
    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: DispersionParameters, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselLeakFlammableLinkedRunCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count


class VesselLeakFlammableLinkedRunCalculation(_CalculationBase):
    """
    VesselLeakFlammableLinkedRun calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Concentration levels.
	dispersion_output_config_count : int 
		Number of concentration levels.
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.

    Calculation outputs:
    
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Ellipses to jet fire radiation levels.
	njet_contour_points : list[int] 
		Number of contour points for jet fire ellipses per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire ellipses.
	distances_to_concentration : list[float] 
		Distances to concentration levels.
	concentrations_used : list[float] 
		Concentration levels.
	conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels.
	nconc_contour_points : list[int] 
		Number of contour points per concentration level.
	area_footprint_conc : list[float] 
		Areas of maximum concentration footprints.
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Ellipses to pool fire radiation levels.
	npool_contour_points : list[int] 
		Number of contour points for pool fire ellipses per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire ellipses.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion overpressure results.
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: DispersionParameters, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselLeakFlammableLinkedRunCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.njet_contour_points = None
        self.area_ellipse_jet = None
        self.distances_to_concentration = None
        self.concentrations_used = None
        self.conc_contour_points = None
        self.nconc_contour_points = None
        self.area_footprint_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.npool_contour_points = None
        self.area_ellipse_pool = None
        self.explosion_overpressure_results = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel leak flammable linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLeakFlammableLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakFlammableLinkedRunCalculationRequest object.
        vessel_leak_flammable_linked_run_calculation_request = _VesselLeakFlammableLinkedRunCalculationRequest(self.vessel, self.leak, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_output_configs, self.dispersion_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the appropriate schema and use that to serialize to json.
        vessel_leak_flammable_linked_run_calculation_request_schema = _VesselLeakFlammableLinkedRunCalculationRequestSchema()

        request_json = vessel_leak_flammable_linked_run_calculation_request_schema.dumps(vessel_leak_flammable_linked_run_calculation_request)
        url = get_analytics_api_target() + 'vesselleakflammablelinkedrun?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_leak_flammable_linked_run_calculation_response_schema = _VesselLeakFlammableLinkedRunCalculationResponseSchema()
            vessel_leak_flammable_linked_run_calculation_response = vessel_leak_flammable_linked_run_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_leak_flammable_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_leak_flammable_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_leak_flammable_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_leak_flammable_linked_run_calculation_response.jet_contour_points
                self.njet_contour_points = vessel_leak_flammable_linked_run_calculation_response.njet_contour_points
                self.area_ellipse_jet = vessel_leak_flammable_linked_run_calculation_response.area_ellipse_jet
                self.distances_to_concentration = vessel_leak_flammable_linked_run_calculation_response.distances_to_concentration
                self.concentrations_used = vessel_leak_flammable_linked_run_calculation_response.concentrations_used
                self.conc_contour_points = vessel_leak_flammable_linked_run_calculation_response.conc_contour_points
                self.nconc_contour_points = vessel_leak_flammable_linked_run_calculation_response.nconc_contour_points
                self.area_footprint_conc = vessel_leak_flammable_linked_run_calculation_response.area_footprint_conc
                self.distances_to_pool_fire_radiation = vessel_leak_flammable_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_leak_flammable_linked_run_calculation_response.pool_contour_points
                self.npool_contour_points = vessel_leak_flammable_linked_run_calculation_response.npool_contour_points
                self.area_ellipse_pool = vessel_leak_flammable_linked_run_calculation_response.area_ellipse_pool
                self.explosion_overpressure_results = vessel_leak_flammable_linked_run_calculation_response.explosion_overpressure_results
                self.jet_fire_flame_result = vessel_leak_flammable_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_leak_flammable_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_leak_flammable_linked_run_calculation_response.result_code
                self.messages = vessel_leak_flammable_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_flammable_linked_run_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_leak_flammable_linked_run_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakFlammableLinkedRun calculation object"""

        parts = ['* VesselLeakFlammableLinkedRun']

        parts.append(f'discharge_record: {str(self.discharge_record)}')
        parts.append(f'*** distances_to_jet_fire_radiation')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.append(f'*** jet_contour_points')
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.append(f'*** njet_contour_points')
        parts.extend(['njet_contour_points_element' for njet_contour_points_element in self.njet_contour_points] if self.njet_contour_points else [f'njet_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_jet')
        parts.extend(['area_ellipse_jet_element' for area_ellipse_jet_element in self.area_ellipse_jet] if self.area_ellipse_jet else [f'area_ellipse_jet does not contain any elements'])
        parts.append(f'*** distances_to_concentration')
        parts.extend(['distances_to_concentration_element' for distances_to_concentration_element in self.distances_to_concentration] if self.distances_to_concentration else [f'distances_to_concentration does not contain any elements'])
        parts.append(f'*** concentrations_used')
        parts.extend(['concentrations_used_element' for concentrations_used_element in self.concentrations_used] if self.concentrations_used else [f'concentrations_used does not contain any elements'])
        parts.append(f'*** conc_contour_points')
        parts.extend(['conc_contour_points_element' for conc_contour_points_element in self.conc_contour_points] if self.conc_contour_points else [f'conc_contour_points does not contain any elements'])
        parts.append(f'*** nconc_contour_points')
        parts.extend(['nconc_contour_points_element' for nconc_contour_points_element in self.nconc_contour_points] if self.nconc_contour_points else [f'nconc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_conc')
        parts.extend(['area_footprint_conc_element' for area_footprint_conc_element in self.area_footprint_conc] if self.area_footprint_conc else [f'area_footprint_conc does not contain any elements'])
        parts.append(f'*** distances_to_pool_fire_radiation')
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.append(f'*** pool_contour_points')
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.append(f'*** npool_contour_points')
        parts.extend(['npool_contour_points_element' for npool_contour_points_element in self.npool_contour_points] if self.npool_contour_points else [f'npool_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_pool')
        parts.extend(['area_ellipse_pool_element' for area_ellipse_pool_element in self.area_ellipse_pool] if self.area_ellipse_pool else [f'area_ellipse_pool does not contain any elements'])
        parts.append(f'*** explosion_overpressure_results')
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.append(f'jet_fire_flame_result: {str(self.jet_fire_flame_result)}')
        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLeakFlammableLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    VesselLeakFlammableLinkedRun calculation response class.

    Attributes
    ----------
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Ellipses to jet fire radiation levels.
	njet_contour_points : list[int] 
		Number of contour points for jet fire ellipses per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire ellipses.
	distances_to_concentration : list[float] 
		Distances to concentration levels.
	concentrations_used : list[float] 
		Concentration levels.
	conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels.
	nconc_contour_points : list[int] 
		Number of contour points per concentration level.
	area_footprint_conc : list[float] 
		Areas of maximum concentration footprints.
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Ellipses to pool fire radiation levels.
	npool_contour_points : list[int] 
		Number of contour points for pool fire ellipses per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire ellipses.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion overpressure results.
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], njet_contour_points: list[int], area_ellipse_jet: list[float], distances_to_concentration: list[float], concentrations_used: list[float], conc_contour_points: list[LocalPosition], nconc_contour_points: list[int], area_footprint_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], npool_contour_points: list[int], area_ellipse_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLeakFlammableLinkedRunCalculationResponse class"""
        super().__init__()

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation if distances_to_jet_fire_radiation is not None else []
        self.jet_contour_points = jet_contour_points if jet_contour_points is not None else []
        self.njet_contour_points = njet_contour_points if njet_contour_points is not None else []
        self.area_ellipse_jet = area_ellipse_jet if area_ellipse_jet is not None else []
        self.distances_to_concentration = distances_to_concentration if distances_to_concentration is not None else []
        self.concentrations_used = concentrations_used if concentrations_used is not None else []
        self.conc_contour_points = conc_contour_points if conc_contour_points is not None else []
        self.nconc_contour_points = nconc_contour_points if nconc_contour_points is not None else []
        self.area_footprint_conc = area_footprint_conc if area_footprint_conc is not None else []
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation if distances_to_pool_fire_radiation is not None else []
        self.pool_contour_points = pool_contour_points if pool_contour_points is not None else []
        self.npool_contour_points = npool_contour_points if npool_contour_points is not None else []
        self.area_ellipse_pool = area_ellipse_pool if area_ellipse_pool is not None else []
        self.explosion_overpressure_results = explosion_overpressure_results if explosion_overpressure_results is not None else []
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel leak flammable linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'discharge_record' in data and data['discharge_record'] is not None:
            self.discharge_record.initialise_from_dictionary(data['discharge_record'])
        
        if 'jet_contour_points' in data and data['jet_contour_points'] is not None:
            self.jet_contour_points = [record.initialise_from_dictionary(record) for record in data['jet_contour_points']]
        else:
            self.jet_contour_points = []
        
        if 'conc_contour_points' in data and data['conc_contour_points'] is not None:
            self.conc_contour_points = [record.initialise_from_dictionary(record) for record in data['conc_contour_points']]
        else:
            self.conc_contour_points = []
        
        if 'pool_contour_points' in data and data['pool_contour_points'] is not None:
            self.pool_contour_points = [record.initialise_from_dictionary(record) for record in data['pool_contour_points']]
        else:
            self.pool_contour_points = []
        
        if 'explosion_overpressure_results' in data and data['explosion_overpressure_results'] is not None:
            self.explosion_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_overpressure_results']]
        else:
            self.explosion_overpressure_results = []
        
        if 'jet_fire_flame_result' in data and data['jet_fire_flame_result'] is not None:
            self.jet_fire_flame_result.initialise_from_dictionary(data['jet_fire_flame_result'])
        
        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _SideviewAtTimeCalculationRequest(_CalculationRequestBase):
    """
    _SideviewAtTime calculation request class.
    
    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _SideviewAtTimeCalculationRequest class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters


class SideviewAtTimeCalculation(_CalculationBase):
    """
    SideviewAtTime calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	conc_used : float 
		Concentration of interest.
	contour_points : list[LocalPosition] 
		Array of sideview results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the SideviewAtTimeCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.contour_points = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Sideview at time calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        SideviewAtTimeCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SideviewAtTimeCalculationRequest object.
        sideview_at_time_calculation_request = _SideviewAtTimeCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        sideview_at_time_calculation_request_schema = _SideviewAtTimeCalculationRequestSchema()

        request_json = sideview_at_time_calculation_request_schema.dumps(sideview_at_time_calculation_request)
        url = get_analytics_api_target() + 'calculatesideviewattime?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            sideview_at_time_calculation_response_schema = _SideviewAtTimeCalculationResponseSchema()
            sideview_at_time_calculation_response = sideview_at_time_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(sideview_at_time_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = sideview_at_time_calculation_response.conc_used
                self.contour_points = sideview_at_time_calculation_response.contour_points
                self.result_code = sideview_at_time_calculation_response.result_code
                self.messages = sideview_at_time_calculation_response.messages
                self.calculation_elapsed_time = sideview_at_time_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(sideview_at_time_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the SideviewAtTime calculation object"""

        parts = ['* SideviewAtTime']

        parts.append(f'ConcUsed : {self.conc_used}')
        parts.append(f'*** contour_points')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _SideviewAtTimeCalculationResponse(_CalculationResponseBase):
    """
    SideviewAtTime calculation response class.

    Attributes
    ----------
	conc_used : float 
		Concentration of interest.
	contour_points : list[LocalPosition] 
		Array of sideview results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, conc_used: float, contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the SideviewAtTimeCalculationResponse class"""
        super().__init__()

        self.conc_used = conc_used
        self.contour_points = contour_points if contour_points is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Sideview at time calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'conc_used' in data and data['conc_used'] is not None:
            self.conc_used
        
        if 'contour_points' in data and data['contour_points'] is not None:
            self.contour_points = [record.initialise_from_dictionary(record) for record in data['contour_points']]
        else:
            self.contour_points = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _SetPhaseToReleaseForReliefValveScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetPhaseToReleaseForReliefValveScenario calculation request class.
    
    Attributes
    ----------
	phase_to_release : Phase 
		Requested fluid phase to release.
	release_elevation : float 
		Release point elevation above ground.
	vessel : Vessel 
		Vessel definition input.
    """
    
    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the _SetPhaseToReleaseForReliefValveScenarioCalculationRequest class"""
        super().__init__()

        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel


class SetPhaseToReleaseForReliefValveScenarioCalculation(_CalculationBase):
    """
    SetPhaseToReleaseForReliefValveScenario calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	phase_to_release : Phase 
		Requested fluid phase to release.
	release_elevation : float 
		Release point elevation above ground.
	vessel : Vessel 
		Vessel definition input.

    Calculation outputs:
    
	zcoord_updated : float 
		Updated z-coordinate of vessel to accommodate requested phase to release.
	pipe_height_fraction_updated : float 
		Updated pipe height fraction to accommodate requested phase to release.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the SetPhaseToReleaseForReliefValveScenarioCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

        # Calculation outputs.
        self.zcoord_updated = None
        self.pipe_height_fraction_updated = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Set phase to release for relief valve scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        SetPhaseToReleaseForReliefValveScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetPhaseToReleaseForReliefValveScenarioCalculationRequest object.
        set_phase_to_release_for_relief_valve_scenario_calculation_request = _SetPhaseToReleaseForReliefValveScenarioCalculationRequest(self.phase_to_release, self.release_elevation, self.vessel)

        # Get the appropriate schema and use that to serialize to json.
        set_phase_to_release_for_relief_valve_scenario_calculation_request_schema = _SetPhaseToReleaseForReliefValveScenarioCalculationRequestSchema()

        request_json = set_phase_to_release_for_relief_valve_scenario_calculation_request_schema.dumps(set_phase_to_release_for_relief_valve_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/setphasetoreleaseforreliefvalvescenario?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            set_phase_to_release_for_relief_valve_scenario_calculation_response_schema = _SetPhaseToReleaseForReliefValveScenarioCalculationResponseSchema()
            set_phase_to_release_for_relief_valve_scenario_calculation_response = set_phase_to_release_for_relief_valve_scenario_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(set_phase_to_release_for_relief_valve_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.zcoord_updated = set_phase_to_release_for_relief_valve_scenario_calculation_response.zcoord_updated
                self.pipe_height_fraction_updated = set_phase_to_release_for_relief_valve_scenario_calculation_response.pipe_height_fraction_updated
                self.result_code = set_phase_to_release_for_relief_valve_scenario_calculation_response.result_code
                self.messages = set_phase_to_release_for_relief_valve_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_phase_to_release_for_relief_valve_scenario_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(set_phase_to_release_for_relief_valve_scenario_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the SetPhaseToReleaseForReliefValveScenario calculation object"""

        parts = ['* SetPhaseToReleaseForReliefValveScenario']

        parts.append(f'ZCoordUpdated : {self.zcoord_updated}')
        parts.append(f'PipeHeightFractionUpdated : {self.pipe_height_fraction_updated}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _SetPhaseToReleaseForReliefValveScenarioCalculationResponse(_CalculationResponseBase):
    """
    SetPhaseToReleaseForReliefValveScenario calculation response class.

    Attributes
    ----------
	zcoord_updated : float 
		Updated z-coordinate of vessel to accommodate requested phase to release.
	pipe_height_fraction_updated : float 
		Updated pipe height fraction to accommodate requested phase to release.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, zcoord_updated: float, pipe_height_fraction_updated: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the SetPhaseToReleaseForReliefValveScenarioCalculationResponse class"""
        super().__init__()

        self.zcoord_updated = zcoord_updated
        self.pipe_height_fraction_updated = pipe_height_fraction_updated
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Set phase to release for relief valve scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'zcoord_updated' in data and data['zcoord_updated'] is not None:
            self.zcoord_updated
        
        if 'pipe_height_fraction_updated' in data and data['pipe_height_fraction_updated'] is not None:
            self.pipe_height_fraction_updated
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _DistancesAndFootprintsToConcentrationLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesAndFootprintsToConcentrationLevels calculation request class.
    
    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs (i.e. one per scenario/weather).
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Dispersion view configurations.
	dispersion_output_config_count : int 
		Number of dispersion view configurations.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	material : Material 
		Material with post-discharge composition.
    """
    
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, dispersion_parameters: DispersionParameters, material: Material):
        """Initializes a new instance of the _DistancesAndFootprintsToConcentrationLevelsCalculationRequest class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.dispersion_parameters = dispersion_parameters
        self.material = material


class DistancesAndFootprintsToConcentrationLevelsCalculation(_CalculationBase):
    """
    DistancesAndFootprintsToConcentrationLevels calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs (i.e. one per scenario/weather).
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Dispersion view configurations.
	dispersion_output_config_count : int 
		Number of dispersion view configurations.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	material : Material 
		Material with post-discharge composition.

    Calculation outputs:
    
	concs_used : list[float] 
		Concentrations of interest.
	ncontour_points : list[int] 
		Number of contour points per concentration level.
	areas_contour : list[float] 
		Areas of footprint contours.
	distances_concentration : list[float] 
		Maximum distances downwind per concentration level.
	contour_points : list[LocalPosition] 
		Contour points of maximum footprints to concentration level.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, dispersion_parameters: DispersionParameters, material: Material):
        """Initializes a new instance of the DistancesAndFootprintsToConcentrationLevelsCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.dispersion_parameters = dispersion_parameters
        self.material = material

        # Calculation outputs.
        self.concs_used = None
        self.ncontour_points = None
        self.areas_contour = None
        self.distances_concentration = None
        self.contour_points = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Distances and footprints to concentration levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        DistancesAndFootprintsToConcentrationLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesAndFootprintsToConcentrationLevelsCalculationRequest object.
        distances_and_footprints_to_concentration_levels_calculation_request = _DistancesAndFootprintsToConcentrationLevelsCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_configs, self.dispersion_output_config_count, self.dispersion_parameters, self.material)

        # Get the appropriate schema and use that to serialize to json.
        distances_and_footprints_to_concentration_levels_calculation_request_schema = _DistancesAndFootprintsToConcentrationLevelsCalculationRequestSchema()

        request_json = distances_and_footprints_to_concentration_levels_calculation_request_schema.dumps(distances_and_footprints_to_concentration_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancesandfootprintstoconcentrationlevels?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            distances_and_footprints_to_concentration_levels_calculation_response_schema = _DistancesAndFootprintsToConcentrationLevelsCalculationResponseSchema()
            distances_and_footprints_to_concentration_levels_calculation_response = distances_and_footprints_to_concentration_levels_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(distances_and_footprints_to_concentration_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.concs_used = distances_and_footprints_to_concentration_levels_calculation_response.concs_used
                self.ncontour_points = distances_and_footprints_to_concentration_levels_calculation_response.ncontour_points
                self.areas_contour = distances_and_footprints_to_concentration_levels_calculation_response.areas_contour
                self.distances_concentration = distances_and_footprints_to_concentration_levels_calculation_response.distances_concentration
                self.contour_points = distances_and_footprints_to_concentration_levels_calculation_response.contour_points
                self.result_code = distances_and_footprints_to_concentration_levels_calculation_response.result_code
                self.messages = distances_and_footprints_to_concentration_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_and_footprints_to_concentration_levels_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(distances_and_footprints_to_concentration_levels_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesAndFootprintsToConcentrationLevels calculation object"""

        parts = ['* DistancesAndFootprintsToConcentrationLevels']

        parts.append(f'*** concs_used')
        parts.extend(['concs_used_element' for concs_used_element in self.concs_used] if self.concs_used else [f'concs_used does not contain any elements'])
        parts.append(f'*** ncontour_points')
        parts.extend(['ncontour_points_element' for ncontour_points_element in self.ncontour_points] if self.ncontour_points else [f'ncontour_points does not contain any elements'])
        parts.append(f'*** areas_contour')
        parts.extend(['areas_contour_element' for areas_contour_element in self.areas_contour] if self.areas_contour else [f'areas_contour does not contain any elements'])
        parts.append(f'*** distances_concentration')
        parts.extend(['distances_concentration_element' for distances_concentration_element in self.distances_concentration] if self.distances_concentration else [f'distances_concentration does not contain any elements'])
        parts.append(f'*** contour_points')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _DistancesAndFootprintsToConcentrationLevelsCalculationResponse(_CalculationResponseBase):
    """
    DistancesAndFootprintsToConcentrationLevels calculation response class.

    Attributes
    ----------
	concs_used : list[float] 
		Concentrations of interest.
	ncontour_points : list[int] 
		Number of contour points per concentration level.
	areas_contour : list[float] 
		Areas of footprint contours.
	distances_concentration : list[float] 
		Maximum distances downwind per concentration level.
	contour_points : list[LocalPosition] 
		Contour points of maximum footprints to concentration level.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, concs_used: list[float], ncontour_points: list[int], areas_contour: list[float], distances_concentration: list[float], contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the DistancesAndFootprintsToConcentrationLevelsCalculationResponse class"""
        super().__init__()

        self.concs_used = concs_used if concs_used is not None else []
        self.ncontour_points = ncontour_points if ncontour_points is not None else []
        self.areas_contour = areas_contour if areas_contour is not None else []
        self.distances_concentration = distances_concentration if distances_concentration is not None else []
        self.contour_points = contour_points if contour_points is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Distances and footprints to concentration levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'contour_points' in data and data['contour_points'] is not None:
            self.contour_points = [record.initialise_from_dictionary(record) for record in data['contour_points']]
        else:
            self.contour_points = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLeakMaxFlammableCloudCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakMaxFlammableCloud calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	leak : Leak 
		Leak failure case.
	weather : Weather 
		Weather.
	substrate : Substrate 
		The dispersing surface.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	dispersion_output_config : DispersionOutputConfig 
		Options for controlling dispersion results (here used to set height of interest only).
    """
    
    def __init__(self, vessel: Vessel, leak: Leak, weather: Weather, substrate: Substrate, discharge_parameters: DischargeParameters, dispersion_parameters: DispersionParameters, dispersion_output_config: DispersionOutputConfig):
        """Initializes a new instance of the _VesselLeakMaxFlammableCloudCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.weather = weather
        self.substrate = substrate
        self.discharge_parameters = discharge_parameters
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_output_config = dispersion_output_config


class VesselLeakMaxFlammableCloudCalculation(_CalculationBase):
    """
    VesselLeakMaxFlammableCloud calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	leak : Leak 
		Leak failure case.
	weather : Weather 
		Weather.
	substrate : Substrate 
		The dispersing surface.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	dispersion_output_config : DispersionOutputConfig 
		Options for controlling dispersion results (here used to set height of interest only).

    Calculation outputs:
    
	vessel_leak_max_flammable_cloud_results : VesselLeakMaxFlammableCloudResults 
		Collated discharge and flammable cloud characterisation results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, weather: Weather, substrate: Substrate, discharge_parameters: DischargeParameters, dispersion_parameters: DispersionParameters, dispersion_output_config: DispersionOutputConfig):
        """Initializes a new instance of the VesselLeakMaxFlammableCloudCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.weather = weather
        self.substrate = substrate
        self.discharge_parameters = discharge_parameters
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_output_config = dispersion_output_config

        # Calculation outputs.
        self.vessel_leak_max_flammable_cloud_results = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel leak max flammable cloud calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLeakMaxFlammableCloudCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakMaxFlammableCloudCalculationRequest object.
        vessel_leak_max_flammable_cloud_calculation_request = _VesselLeakMaxFlammableCloudCalculationRequest(self.vessel, self.leak, self.weather, self.substrate, self.discharge_parameters, self.dispersion_parameters, self.dispersion_output_config)

        # Get the appropriate schema and use that to serialize to json.
        vessel_leak_max_flammable_cloud_calculation_request_schema = _VesselLeakMaxFlammableCloudCalculationRequestSchema()

        request_json = vessel_leak_max_flammable_cloud_calculation_request_schema.dumps(vessel_leak_max_flammable_cloud_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselleakmaxflammablecloud?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_leak_max_flammable_cloud_calculation_response_schema = _VesselLeakMaxFlammableCloudCalculationResponseSchema()
            vessel_leak_max_flammable_cloud_calculation_response = vessel_leak_max_flammable_cloud_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_leak_max_flammable_cloud_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel_leak_max_flammable_cloud_results = vessel_leak_max_flammable_cloud_calculation_response.vessel_leak_max_flammable_cloud_results
                self.result_code = vessel_leak_max_flammable_cloud_calculation_response.result_code
                self.messages = vessel_leak_max_flammable_cloud_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_max_flammable_cloud_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_leak_max_flammable_cloud_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakMaxFlammableCloud calculation object"""

        parts = ['* VesselLeakMaxFlammableCloud']

        parts.append(f'vessel_leak_max_flammable_cloud_results: {str(self.vessel_leak_max_flammable_cloud_results)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLeakMaxFlammableCloudCalculationResponse(_CalculationResponseBase):
    """
    VesselLeakMaxFlammableCloud calculation response class.

    Attributes
    ----------
	vessel_leak_max_flammable_cloud_results : VesselLeakMaxFlammableCloudResults 
		Collated discharge and flammable cloud characterisation results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, vessel_leak_max_flammable_cloud_results: VesselLeakMaxFlammableCloudResults, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLeakMaxFlammableCloudCalculationResponse class"""
        super().__init__()

        self.vessel_leak_max_flammable_cloud_results = vessel_leak_max_flammable_cloud_results
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel leak max flammable cloud calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'vessel_leak_max_flammable_cloud_results' in data and data['vessel_leak_max_flammable_cloud_results'] is not None:
            self.vessel_leak_max_flammable_cloud_results.initialise_from_dictionary(data['vessel_leak_max_flammable_cloud_results'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _PoolFireCalculationRequest(_CalculationRequestBase):
    """
    _PoolFire calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material with post-discharge composition.
	pool_records : list[PoolRecord] 
		Pool / source term definition.
	pool_record_count : int 
		Number of pool records.
	weather : Weather 
		Weather.
	substrate : Substrate 
		Substrate.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
    """
    
    def __init__(self, material: Material, pool_records: list[PoolRecord], pool_record_count: int, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the _PoolFireCalculationRequest class"""
        super().__init__()

        self.material = material
        self.pool_records = pool_records
        self.pool_record_count = pool_record_count
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters


class PoolFireCalculation(_CalculationBase):
    """
    PoolFire calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material with post-discharge composition.
	pool_records : list[PoolRecord] 
		Pool / source term definition.
	pool_record_count : int 
		Number of pool records.
	weather : Weather 
		Weather.
	substrate : Substrate 
		Substrate.
	flammable_parameters : FlammableParameters 
		Flammable parameters.

    Calculation outputs:
    
	pool_fire_flame_result : PoolFireFlameResult 
		Flame scalar result.
	flame_records : list[FlameRecord] 
		Array of pool fire flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, pool_records: list[PoolRecord], pool_record_count: int, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the PoolFireCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.pool_records = pool_records
        self.pool_record_count = pool_record_count
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

        # Calculation outputs.
        self.pool_fire_flame_result = None
        self.flame_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Pool fire calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        PoolFireCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _PoolFireCalculationRequest object.
        pool_fire_calculation_request = _PoolFireCalculationRequest(self.material, self.pool_records, self.pool_record_count, self.weather, self.substrate, self.flammable_parameters)

        # Get the appropriate schema and use that to serialize to json.
        pool_fire_calculation_request_schema = _PoolFireCalculationRequestSchema()

        request_json = pool_fire_calculation_request_schema.dumps(pool_fire_calculation_request)
        url = get_analytics_api_target() + 'calculatepoolfire?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            pool_fire_calculation_response_schema = _PoolFireCalculationResponseSchema()
            pool_fire_calculation_response = pool_fire_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(pool_fire_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.pool_fire_flame_result = pool_fire_calculation_response.pool_fire_flame_result
                self.flame_records = pool_fire_calculation_response.flame_records
                self.result_code = pool_fire_calculation_response.result_code
                self.messages = pool_fire_calculation_response.messages
                self.calculation_elapsed_time = pool_fire_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(pool_fire_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the PoolFire calculation object"""

        parts = ['* PoolFire']

        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'*** flame_records')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _PoolFireCalculationResponse(_CalculationResponseBase):
    """
    PoolFire calculation response class.

    Attributes
    ----------
	pool_fire_flame_result : PoolFireFlameResult 
		Flame scalar result.
	flame_records : list[FlameRecord] 
		Array of pool fire flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the PoolFireCalculationResponse class"""
        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records if flame_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Pool fire calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'flame_records' in data and data['flame_records'] is not None:
            self.flame_records = [record.initialise_from_dictionary(record) for record in data['flame_records']]
        else:
            self.flame_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _DistancesToRadiationLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesToRadiationLevels calculation request class.
    
    Attributes
    ----------
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Flammable output configurations.
	flammable_output_config_count : int 
		Number of flammable output configurations.
    """
    
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _DistancesToRadiationLevelsCalculationRequest class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count


class DistancesToRadiationLevelsCalculation(_CalculationBase):
    """
    DistancesToRadiationLevels calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Flammable output configurations.
	flammable_output_config_count : int 
		Number of flammable output configurations.

    Calculation outputs:
    
	distances : list[float] 
		Distances to radiation level.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the DistancesToRadiationLevelsCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.distances = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Distances to radiation levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        DistancesToRadiationLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesToRadiationLevelsCalculationRequest object.
        distances_to_radiation_levels_calculation_request = _DistancesToRadiationLevelsCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the appropriate schema and use that to serialize to json.
        distances_to_radiation_levels_calculation_request_schema = _DistancesToRadiationLevelsCalculationRequestSchema()

        request_json = distances_to_radiation_levels_calculation_request_schema.dumps(distances_to_radiation_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancestoradiationlevels?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            distances_to_radiation_levels_calculation_response_schema = _DistancesToRadiationLevelsCalculationResponseSchema()
            distances_to_radiation_levels_calculation_response = distances_to_radiation_levels_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(distances_to_radiation_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances = distances_to_radiation_levels_calculation_response.distances
                self.result_code = distances_to_radiation_levels_calculation_response.result_code
                self.messages = distances_to_radiation_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_to_radiation_levels_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(distances_to_radiation_levels_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesToRadiationLevels calculation object"""

        parts = ['* DistancesToRadiationLevels']

        parts.append(f'*** distances')
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _DistancesToRadiationLevelsCalculationResponse(_CalculationResponseBase):
    """
    DistancesToRadiationLevels calculation response class.

    Attributes
    ----------
	distances : list[float] 
		Distances to radiation level.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, distances: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the DistancesToRadiationLevelsCalculationResponse class"""
        super().__init__()

        self.distances = distances if distances is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Distances to radiation levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _FlashCalculationRequest(_CalculationRequestBase):
    """
    _Flash calculation request class.
    
    Attributes
    ----------
	material : Material 
		User-defined input material, pure component or mixture (max 20 components).
	material_state : State 
		Describes the fluid pressure, temperature, liquid fraction.
    """
    
    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the _FlashCalculationRequest class"""
        super().__init__()

        self.material = material
        self.material_state = material_state


class FlashCalculation(_CalculationBase):
    """
    Flash calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		User-defined input material, pure component or mixture (max 20 components).
	material_state : State 
		Describes the fluid pressure, temperature, liquid fraction.

    Calculation outputs:
    
	flash_result : FlashResult 
		Fluid properties at given conditions.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the FlashCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.material_state = material_state

        # Calculation outputs.
        self.flash_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Flash calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        FlashCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _FlashCalculationRequest object.
        flash_calculation_request = _FlashCalculationRequest(self.material, self.material_state)

        # Get the appropriate schema and use that to serialize to json.
        flash_calculation_request_schema = _FlashCalculationRequestSchema()

        request_json = flash_calculation_request_schema.dumps(flash_calculation_request)
        url = get_analytics_api_target() + 'calculateflash?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            flash_calculation_response_schema = _FlashCalculationResponseSchema()
            flash_calculation_response = flash_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(flash_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.flash_result = flash_calculation_response.flash_result
                self.result_code = flash_calculation_response.result_code
                self.messages = flash_calculation_response.messages
                self.calculation_elapsed_time = flash_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(flash_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the Flash calculation object"""

        parts = ['* Flash']

        parts.append(f'flash_result: {str(self.flash_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _FlashCalculationResponse(_CalculationResponseBase):
    """
    Flash calculation response class.

    Attributes
    ----------
	flash_result : FlashResult 
		Fluid properties at given conditions.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, flash_result: FlashResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the FlashCalculationResponse class"""
        super().__init__()

        self.flash_result = flash_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Flash calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'flash_result' in data and data['flash_result'] is not None:
            self.flash_result.initialise_from_dictionary(data['flash_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLeakFlamToxSimpleLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakFlamToxSimpleLinkedRun calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	mole_fraction_toxic : float 
		Mole fraction of toxic component.
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
    """
    
    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, mole_fraction_toxic: float, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselLeakFlamToxSimpleLinkedRunCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.mole_fraction_toxic = mole_fraction_toxic
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count


class VesselLeakFlamToxSimpleLinkedRunCalculation(_CalculationBase):
    """
    VesselLeakFlamToxSimpleLinkedRun calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	mole_fraction_toxic : float 
		Mole fraction of toxic component.
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.

    Calculation outputs:
    
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, mole_fraction_toxic: float, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselLeakFlamToxSimpleLinkedRunCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.mole_fraction_toxic = mole_fraction_toxic
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.njet_contour_points = None
        self.area_ellipse_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.nflam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.npool_contour_points = None
        self.area_ellipse_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.ntoxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel leak flam tox simple linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLeakFlamToxSimpleLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakFlamToxSimpleLinkedRunCalculationRequest object.
        vessel_leak_flam_tox_simple_linked_run_calculation_request = _VesselLeakFlamToxSimpleLinkedRunCalculationRequest(self.vessel, self.leak, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.mole_fraction_toxic, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the appropriate schema and use that to serialize to json.
        vessel_leak_flam_tox_simple_linked_run_calculation_request_schema = _VesselLeakFlamToxSimpleLinkedRunCalculationRequestSchema()

        request_json = vessel_leak_flam_tox_simple_linked_run_calculation_request_schema.dumps(vessel_leak_flam_tox_simple_linked_run_calculation_request)
        url = get_analytics_api_target() + 'vesselleakflamtoxsimplelinkedrun?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_leak_flam_tox_simple_linked_run_calculation_response_schema = _VesselLeakFlamToxSimpleLinkedRunCalculationResponseSchema()
            vessel_leak_flam_tox_simple_linked_run_calculation_response = vessel_leak_flam_tox_simple_linked_run_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_leak_flam_tox_simple_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_leak_flam_tox_simple_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_leak_flam_tox_simple_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.jet_contour_points
                self.njet_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.njet_contour_points
                self.area_ellipse_jet = vessel_leak_flam_tox_simple_linked_run_calculation_response.area_ellipse_jet
                self.distances_to_flam_concentration = vessel_leak_flam_tox_simple_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = vessel_leak_flam_tox_simple_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.flam_conc_contour_points
                self.nflam_conc_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.nflam_conc_contour_points
                self.area_footprint_flam_conc = vessel_leak_flam_tox_simple_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = vessel_leak_flam_tox_simple_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.pool_contour_points
                self.npool_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.npool_contour_points
                self.area_ellipse_pool = vessel_leak_flam_tox_simple_linked_run_calculation_response.area_ellipse_pool
                self.explosion_overpressure_results = vessel_leak_flam_tox_simple_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = vessel_leak_flam_tox_simple_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = vessel_leak_flam_tox_simple_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.toxic_conc_contour_points
                self.ntoxic_conc_contour_points = vessel_leak_flam_tox_simple_linked_run_calculation_response.ntoxic_conc_contour_points
                self.area_footprint_toxic_conc = vessel_leak_flam_tox_simple_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = vessel_leak_flam_tox_simple_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_leak_flam_tox_simple_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_leak_flam_tox_simple_linked_run_calculation_response.result_code
                self.messages = vessel_leak_flam_tox_simple_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_flam_tox_simple_linked_run_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_leak_flam_tox_simple_linked_run_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakFlamToxSimpleLinkedRun calculation object"""

        parts = ['* VesselLeakFlamToxSimpleLinkedRun']

        parts.append(f'discharge_record: {str(self.discharge_record)}')
        parts.append(f'*** distances_to_jet_fire_radiation')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.append(f'*** jet_contour_points')
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.append(f'*** njet_contour_points')
        parts.extend(['njet_contour_points_element' for njet_contour_points_element in self.njet_contour_points] if self.njet_contour_points else [f'njet_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_jet')
        parts.extend(['area_ellipse_jet_element' for area_ellipse_jet_element in self.area_ellipse_jet] if self.area_ellipse_jet else [f'area_ellipse_jet does not contain any elements'])
        parts.append(f'*** distances_to_flam_concentration')
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.append(f'*** flam_concentrations_used')
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.append(f'*** flam_conc_contour_points')
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.append(f'*** nflam_conc_contour_points')
        parts.extend(['nflam_conc_contour_points_element' for nflam_conc_contour_points_element in self.nflam_conc_contour_points] if self.nflam_conc_contour_points else [f'nflam_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_flam_conc')
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.append(f'*** distances_to_pool_fire_radiation')
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.append(f'*** pool_contour_points')
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.append(f'*** npool_contour_points')
        parts.extend(['npool_contour_points_element' for npool_contour_points_element in self.npool_contour_points] if self.npool_contour_points else [f'npool_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_pool')
        parts.extend(['area_ellipse_pool_element' for area_ellipse_pool_element in self.area_ellipse_pool] if self.area_ellipse_pool else [f'area_ellipse_pool does not contain any elements'])
        parts.append(f'*** explosion_overpressure_results')
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.append(f'*** distances_to_toxic_concentration')
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.append(f'*** toxic_concentration_used')
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.append(f'*** toxic_conc_contour_points')
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** ntoxic_conc_contour_points')
        parts.extend(['ntoxic_conc_contour_points_element' for ntoxic_conc_contour_points_element in self.ntoxic_conc_contour_points] if self.ntoxic_conc_contour_points else [f'ntoxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_toxic_conc')
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append(f'jet_fire_flame_result: {str(self.jet_fire_flame_result)}')
        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLeakFlamToxSimpleLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    VesselLeakFlamToxSimpleLinkedRun calculation response class.

    Attributes
    ----------
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], njet_contour_points: list[int], area_ellipse_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], nflam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], npool_contour_points: list[int], area_ellipse_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], ntoxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLeakFlamToxSimpleLinkedRunCalculationResponse class"""
        super().__init__()

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation if distances_to_jet_fire_radiation is not None else []
        self.jet_contour_points = jet_contour_points if jet_contour_points is not None else []
        self.njet_contour_points = njet_contour_points if njet_contour_points is not None else []
        self.area_ellipse_jet = area_ellipse_jet if area_ellipse_jet is not None else []
        self.distances_to_flam_concentration = distances_to_flam_concentration if distances_to_flam_concentration is not None else []
        self.flam_concentrations_used = flam_concentrations_used if flam_concentrations_used is not None else []
        self.flam_conc_contour_points = flam_conc_contour_points if flam_conc_contour_points is not None else []
        self.nflam_conc_contour_points = nflam_conc_contour_points if nflam_conc_contour_points is not None else []
        self.area_footprint_flam_conc = area_footprint_flam_conc if area_footprint_flam_conc is not None else []
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation if distances_to_pool_fire_radiation is not None else []
        self.pool_contour_points = pool_contour_points if pool_contour_points is not None else []
        self.npool_contour_points = npool_contour_points if npool_contour_points is not None else []
        self.area_ellipse_pool = area_ellipse_pool if area_ellipse_pool is not None else []
        self.explosion_overpressure_results = explosion_overpressure_results if explosion_overpressure_results is not None else []
        self.distances_to_toxic_concentration = distances_to_toxic_concentration if distances_to_toxic_concentration is not None else []
        self.toxic_concentration_used = toxic_concentration_used if toxic_concentration_used is not None else []
        self.toxic_conc_contour_points = toxic_conc_contour_points if toxic_conc_contour_points is not None else []
        self.ntoxic_conc_contour_points = ntoxic_conc_contour_points if ntoxic_conc_contour_points is not None else []
        self.area_footprint_toxic_conc = area_footprint_toxic_conc if area_footprint_toxic_conc is not None else []
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel leak flam tox simple linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'discharge_record' in data and data['discharge_record'] is not None:
            self.discharge_record.initialise_from_dictionary(data['discharge_record'])
        
        if 'jet_contour_points' in data and data['jet_contour_points'] is not None:
            self.jet_contour_points = [record.initialise_from_dictionary(record) for record in data['jet_contour_points']]
        else:
            self.jet_contour_points = []
        
        if 'flam_conc_contour_points' in data and data['flam_conc_contour_points'] is not None:
            self.flam_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['flam_conc_contour_points']]
        else:
            self.flam_conc_contour_points = []
        
        if 'pool_contour_points' in data and data['pool_contour_points'] is not None:
            self.pool_contour_points = [record.initialise_from_dictionary(record) for record in data['pool_contour_points']]
        else:
            self.pool_contour_points = []
        
        if 'explosion_overpressure_results' in data and data['explosion_overpressure_results'] is not None:
            self.explosion_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_overpressure_results']]
        else:
            self.explosion_overpressure_results = []
        
        if 'toxic_conc_contour_points' in data and data['toxic_conc_contour_points'] is not None:
            self.toxic_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['toxic_conc_contour_points']]
        else:
            self.toxic_conc_contour_points = []
        
        if 'jet_fire_flame_result' in data and data['jet_fire_flame_result'] is not None:
            self.jet_fire_flame_result.initialise_from_dictionary(data['jet_fire_flame_result'])
        
        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _MaxConcDistanceCalculationRequest(_CalculationRequestBase):
    """
    _MaxConcDistance calculation request class.
    
    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _MaxConcDistanceCalculationRequest class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters


class MaxConcDistanceCalculation(_CalculationBase):
    """
    MaxConcDistance calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	conc_used : float 
		Concentration of interest.
	concentration_records : list[ConcentrationRecord] 
		Array of maximum concentration at x, y, z coordinates.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the MaxConcDistanceCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.concentration_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Max conc distance calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        MaxConcDistanceCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MaxConcDistanceCalculationRequest object.
        max_conc_distance_calculation_request = _MaxConcDistanceCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        max_conc_distance_calculation_request_schema = _MaxConcDistanceCalculationRequestSchema()

        request_json = max_conc_distance_calculation_request_schema.dumps(max_conc_distance_calculation_request)
        url = get_analytics_api_target() + 'calculatemaxconcdistance?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            max_conc_distance_calculation_response_schema = _MaxConcDistanceCalculationResponseSchema()
            max_conc_distance_calculation_response = max_conc_distance_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(max_conc_distance_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = max_conc_distance_calculation_response.conc_used
                self.concentration_records = max_conc_distance_calculation_response.concentration_records
                self.result_code = max_conc_distance_calculation_response.result_code
                self.messages = max_conc_distance_calculation_response.messages
                self.calculation_elapsed_time = max_conc_distance_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(max_conc_distance_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the MaxConcDistance calculation object"""

        parts = ['* MaxConcDistance']

        parts.append(f'ConcUsed : {self.conc_used}')
        parts.append(f'*** concentration_records')
        parts.extend(['concentration_records_element' for concentration_records_element in self.concentration_records] if self.concentration_records else [f'concentration_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _MaxConcDistanceCalculationResponse(_CalculationResponseBase):
    """
    MaxConcDistance calculation response class.

    Attributes
    ----------
	conc_used : float 
		Concentration of interest.
	concentration_records : list[ConcentrationRecord] 
		Array of maximum concentration at x, y, z coordinates.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, conc_used: float, concentration_records: list[ConcentrationRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the MaxConcDistanceCalculationResponse class"""
        super().__init__()

        self.conc_used = conc_used
        self.concentration_records = concentration_records if concentration_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Max conc distance calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'conc_used' in data and data['conc_used'] is not None:
            self.conc_used
        
        if 'concentration_records' in data and data['concentration_records'] is not None:
            self.concentration_records = [record.initialise_from_dictionary(record) for record in data['concentration_records']]
        else:
            self.concentration_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _MixtureConstantPropertiesCalculationRequest(_CalculationRequestBase):
    """
    _MixtureConstantProperties calculation request class.
    
    Attributes
    ----------
	material : Material 
		User-defined input material (max 20 components).
    """
    
    def __init__(self, material: Material):
        """Initializes a new instance of the _MixtureConstantPropertiesCalculationRequest class"""
        super().__init__()

        self.material = material


class MixtureConstantPropertiesCalculation(_CalculationBase):
    """
    MixtureConstantProperties calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		User-defined input material (max 20 components).

    Calculation outputs:
    
	mix_constant_prop_result : MixtureConstantPropertiesResult 
		Constant properties of the mixture.
	result_code : ResultCode 
		Response code.

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material):
        """Initializes a new instance of the MixtureConstantPropertiesCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material

        # Calculation outputs.
        self.mix_constant_prop_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Mixture constant properties calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        MixtureConstantPropertiesCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MixtureConstantPropertiesCalculationRequest object.
        mixture_constant_properties_calculation_request = _MixtureConstantPropertiesCalculationRequest(self.material)

        # Get the appropriate schema and use that to serialize to json.
        mixture_constant_properties_calculation_request_schema = _MixtureConstantPropertiesCalculationRequestSchema()

        request_json = mixture_constant_properties_calculation_request_schema.dumps(mixture_constant_properties_calculation_request)
        url = get_analytics_api_target() + 'constantmixtureproperties?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            mixture_constant_properties_calculation_response_schema = _MixtureConstantPropertiesCalculationResponseSchema()
            mixture_constant_properties_calculation_response = mixture_constant_properties_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(mixture_constant_properties_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.mix_constant_prop_result = mixture_constant_properties_calculation_response.mix_constant_prop_result
                self.result_code = mixture_constant_properties_calculation_response.result_code
                self.messages = mixture_constant_properties_calculation_response.messages
                self.calculation_elapsed_time = mixture_constant_properties_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(mixture_constant_properties_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the MixtureConstantProperties calculation object"""

        parts = ['* MixtureConstantProperties']

        parts.append(f'mix_constant_prop_result: {str(self.mix_constant_prop_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _MixtureConstantPropertiesCalculationResponse(_CalculationResponseBase):
    """
    MixtureConstantProperties calculation response class.

    Attributes
    ----------
	mix_constant_prop_result : MixtureConstantPropertiesResult 
		Constant properties of the mixture.
	result_code : ResultCode 
		Response code.
    """

    def __init__(self, mix_constant_prop_result: MixtureConstantPropertiesResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the MixtureConstantPropertiesCalculationResponse class"""
        super().__init__()

        self.mix_constant_prop_result = mix_constant_prop_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Mixture constant properties calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'mix_constant_prop_result' in data and data['mix_constant_prop_result'] is not None:
            self.mix_constant_prop_result.initialise_from_dictionary(data['mix_constant_prop_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _UserDefinedSourceLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _UserDefinedSourceLinkedRun calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material.
	discharge_result : DischargeResult 
		Scalar discharge data.
	discharge_records : list[DischargeRecord] 
		Discharge records.
	discharge_record_count : int 
		Number of discharge records.
	phase_to_be_released : Phase 
		Phase to be released (Vapour, Two-phase or Liquid).
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
    """
    
    def __init__(self, material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, phase_to_be_released: Phase, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _UserDefinedSourceLinkedRunCalculationRequest class"""
        super().__init__()

        self.material = material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.phase_to_be_released = phase_to_be_released
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count


class UserDefinedSourceLinkedRunCalculation(_CalculationBase):
    """
    UserDefinedSourceLinkedRun calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material.
	discharge_result : DischargeResult 
		Scalar discharge data.
	discharge_records : list[DischargeRecord] 
		Discharge records.
	discharge_record_count : int 
		Number of discharge records.
	phase_to_be_released : Phase 
		Phase to be released (Vapour, Two-phase or Liquid).
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.

    Calculation outputs:
    
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_contour_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_contour_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, phase_to_be_released: Phase, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the UserDefinedSourceLinkedRunCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.phase_to_be_released = phase_to_be_released
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.njet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.nflam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.npool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.ntoxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the User defined source linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        UserDefinedSourceLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _UserDefinedSourceLinkedRunCalculationRequest object.
        user_defined_source_linked_run_calculation_request = _UserDefinedSourceLinkedRunCalculationRequest(self.material, self.discharge_result, self.discharge_records, self.discharge_record_count, self.phase_to_be_released, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the appropriate schema and use that to serialize to json.
        user_defined_source_linked_run_calculation_request_schema = _UserDefinedSourceLinkedRunCalculationRequestSchema()

        request_json = user_defined_source_linked_run_calculation_request_schema.dumps(user_defined_source_linked_run_calculation_request)
        url = get_analytics_api_target() + 'calculateuserdefinedsourcelinkedrun?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            user_defined_source_linked_run_calculation_response_schema = _UserDefinedSourceLinkedRunCalculationResponseSchema()
            user_defined_source_linked_run_calculation_response = user_defined_source_linked_run_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(user_defined_source_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances_to_jet_fire_radiation = user_defined_source_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = user_defined_source_linked_run_calculation_response.jet_contour_points
                self.njet_contour_points = user_defined_source_linked_run_calculation_response.njet_contour_points
                self.area_contour_jet = user_defined_source_linked_run_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = user_defined_source_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = user_defined_source_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = user_defined_source_linked_run_calculation_response.flam_conc_contour_points
                self.nflam_conc_contour_points = user_defined_source_linked_run_calculation_response.nflam_conc_contour_points
                self.area_footprint_flam_conc = user_defined_source_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = user_defined_source_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = user_defined_source_linked_run_calculation_response.pool_contour_points
                self.npool_contour_points = user_defined_source_linked_run_calculation_response.npool_contour_points
                self.area_contour_pool = user_defined_source_linked_run_calculation_response.area_contour_pool
                self.explosion_overpressure_results = user_defined_source_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = user_defined_source_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = user_defined_source_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = user_defined_source_linked_run_calculation_response.toxic_conc_contour_points
                self.ntoxic_conc_contour_points = user_defined_source_linked_run_calculation_response.ntoxic_conc_contour_points
                self.area_footprint_toxic_conc = user_defined_source_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = user_defined_source_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = user_defined_source_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = user_defined_source_linked_run_calculation_response.result_code
                self.messages = user_defined_source_linked_run_calculation_response.messages
                self.calculation_elapsed_time = user_defined_source_linked_run_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(user_defined_source_linked_run_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the UserDefinedSourceLinkedRun calculation object"""

        parts = ['* UserDefinedSourceLinkedRun']

        parts.append(f'*** distances_to_jet_fire_radiation')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.append(f'*** jet_contour_points')
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.append(f'*** njet_contour_points')
        parts.extend(['njet_contour_points_element' for njet_contour_points_element in self.njet_contour_points] if self.njet_contour_points else [f'njet_contour_points does not contain any elements'])
        parts.append(f'*** area_contour_jet')
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.append(f'*** distances_to_flam_concentration')
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.append(f'*** flam_concentrations_used')
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.append(f'*** flam_conc_contour_points')
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.append(f'*** nflam_conc_contour_points')
        parts.extend(['nflam_conc_contour_points_element' for nflam_conc_contour_points_element in self.nflam_conc_contour_points] if self.nflam_conc_contour_points else [f'nflam_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_flam_conc')
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.append(f'*** distances_to_pool_fire_radiation')
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.append(f'*** pool_contour_points')
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.append(f'*** npool_contour_points')
        parts.extend(['npool_contour_points_element' for npool_contour_points_element in self.npool_contour_points] if self.npool_contour_points else [f'npool_contour_points does not contain any elements'])
        parts.append(f'*** area_contour_pool')
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.append(f'*** explosion_overpressure_results')
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.append(f'*** distances_to_toxic_concentration')
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.append(f'*** toxic_concentration_used')
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.append(f'*** toxic_conc_contour_points')
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** ntoxic_conc_contour_points')
        parts.extend(['ntoxic_conc_contour_points_element' for ntoxic_conc_contour_points_element in self.ntoxic_conc_contour_points] if self.ntoxic_conc_contour_points else [f'ntoxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_toxic_conc')
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append(f'jet_fire_flame_result: {str(self.jet_fire_flame_result)}')
        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _UserDefinedSourceLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    UserDefinedSourceLinkedRun calculation response class.

    Attributes
    ----------
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_contour_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_contour_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], njet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], nflam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], npool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], ntoxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the UserDefinedSourceLinkedRunCalculationResponse class"""
        super().__init__()

        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation if distances_to_jet_fire_radiation is not None else []
        self.jet_contour_points = jet_contour_points if jet_contour_points is not None else []
        self.njet_contour_points = njet_contour_points if njet_contour_points is not None else []
        self.area_contour_jet = area_contour_jet if area_contour_jet is not None else []
        self.distances_to_flam_concentration = distances_to_flam_concentration if distances_to_flam_concentration is not None else []
        self.flam_concentrations_used = flam_concentrations_used if flam_concentrations_used is not None else []
        self.flam_conc_contour_points = flam_conc_contour_points if flam_conc_contour_points is not None else []
        self.nflam_conc_contour_points = nflam_conc_contour_points if nflam_conc_contour_points is not None else []
        self.area_footprint_flam_conc = area_footprint_flam_conc if area_footprint_flam_conc is not None else []
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation if distances_to_pool_fire_radiation is not None else []
        self.pool_contour_points = pool_contour_points if pool_contour_points is not None else []
        self.npool_contour_points = npool_contour_points if npool_contour_points is not None else []
        self.area_contour_pool = area_contour_pool if area_contour_pool is not None else []
        self.explosion_overpressure_results = explosion_overpressure_results if explosion_overpressure_results is not None else []
        self.distances_to_toxic_concentration = distances_to_toxic_concentration if distances_to_toxic_concentration is not None else []
        self.toxic_concentration_used = toxic_concentration_used if toxic_concentration_used is not None else []
        self.toxic_conc_contour_points = toxic_conc_contour_points if toxic_conc_contour_points is not None else []
        self.ntoxic_conc_contour_points = ntoxic_conc_contour_points if ntoxic_conc_contour_points is not None else []
        self.area_footprint_toxic_conc = area_footprint_toxic_conc if area_footprint_toxic_conc is not None else []
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the User defined source linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'jet_contour_points' in data and data['jet_contour_points'] is not None:
            self.jet_contour_points = [record.initialise_from_dictionary(record) for record in data['jet_contour_points']]
        else:
            self.jet_contour_points = []
        
        if 'flam_conc_contour_points' in data and data['flam_conc_contour_points'] is not None:
            self.flam_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['flam_conc_contour_points']]
        else:
            self.flam_conc_contour_points = []
        
        if 'pool_contour_points' in data and data['pool_contour_points'] is not None:
            self.pool_contour_points = [record.initialise_from_dictionary(record) for record in data['pool_contour_points']]
        else:
            self.pool_contour_points = []
        
        if 'explosion_overpressure_results' in data and data['explosion_overpressure_results'] is not None:
            self.explosion_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_overpressure_results']]
        else:
            self.explosion_overpressure_results = []
        
        if 'toxic_conc_contour_points' in data and data['toxic_conc_contour_points'] is not None:
            self.toxic_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['toxic_conc_contour_points']]
        else:
            self.toxic_conc_contour_points = []
        
        if 'jet_fire_flame_result' in data and data['jet_fire_flame_result'] is not None:
            self.jet_fire_flame_result.initialise_from_dictionary(data['jet_fire_flame_result'])
        
        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _UDSSetLiqFracFromTemperatureCalculationRequest(_CalculationRequestBase):
    """
    _UDSSetLiqFracFromTemperature calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material.
	phase_to_be_released : Phase 
		Phase to be released (should be Two-Phase, if not this method simply returns).
	temperature : float 
		Input temperature.
    """
    
    def __init__(self, material: Material, phase_to_be_released: Phase, temperature: float):
        """Initializes a new instance of the _UDSSetLiqFracFromTemperatureCalculationRequest class"""
        super().__init__()

        self.material = material
        self.phase_to_be_released = phase_to_be_released
        self.temperature = temperature


class UDSSetLiqFracFromTemperatureCalculation(_CalculationBase):
    """
    UDSSetLiqFracFromTemperature calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material.
	phase_to_be_released : Phase 
		Phase to be released (should be Two-Phase, if not this method simply returns).
	temperature : float 
		Input temperature.

    Calculation outputs:
    
	liquid_fraction : float 
		Calculated liquid fraction.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, phase_to_be_released: Phase, temperature: float):
        """Initializes a new instance of the UDSSetLiqFracFromTemperatureCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.phase_to_be_released = phase_to_be_released
        self.temperature = temperature

        # Calculation outputs.
        self.liquid_fraction = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the UDS set liq frac from temperature calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        UDSSetLiqFracFromTemperatureCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _UDSSetLiqFracFromTemperatureCalculationRequest object.
        uds_set_liq_frac_from_temperature_calculation_request = _UDSSetLiqFracFromTemperatureCalculationRequest(self.material, self.phase_to_be_released, self.temperature)

        # Get the appropriate schema and use that to serialize to json.
        uds_set_liq_frac_from_temperature_calculation_request_schema = _UDSSetLiqFracFromTemperatureCalculationRequestSchema()

        request_json = uds_set_liq_frac_from_temperature_calculation_request_schema.dumps(uds_set_liq_frac_from_temperature_calculation_request)
        url = get_analytics_api_target() + 'utilities/udssetliquidfractionfromtemperature?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            uds_set_liq_frac_from_temperature_calculation_response_schema = _UDSSetLiqFracFromTemperatureCalculationResponseSchema()
            uds_set_liq_frac_from_temperature_calculation_response = uds_set_liq_frac_from_temperature_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(uds_set_liq_frac_from_temperature_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.liquid_fraction = uds_set_liq_frac_from_temperature_calculation_response.liquid_fraction
                self.result_code = uds_set_liq_frac_from_temperature_calculation_response.result_code
                self.messages = uds_set_liq_frac_from_temperature_calculation_response.messages
                self.calculation_elapsed_time = uds_set_liq_frac_from_temperature_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(uds_set_liq_frac_from_temperature_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the UDSSetLiqFracFromTemperature calculation object"""

        parts = ['* UDSSetLiqFracFromTemperature']

        parts.append(f'LiquidFraction : {self.liquid_fraction}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _UDSSetLiqFracFromTemperatureCalculationResponse(_CalculationResponseBase):
    """
    UDSSetLiqFracFromTemperature calculation response class.

    Attributes
    ----------
	liquid_fraction : float 
		Calculated liquid fraction.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, liquid_fraction: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the UDSSetLiqFracFromTemperatureCalculationResponse class"""
        super().__init__()

        self.liquid_fraction = liquid_fraction
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the UDS set liq frac from temperature calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'liquid_fraction' in data and data['liquid_fraction'] is not None:
            self.liquid_fraction
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _RadiationTransectCalculationRequest(_CalculationRequestBase):
    """
    _RadiationTransect calculation request class.
    
    Attributes
    ----------
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.
    """
    
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationTransectCalculationRequest class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config


class RadiationTransectCalculation(_CalculationBase):
    """
    RadiationTransect calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.

    Calculation outputs:
    
	radiation_records : list[RadiationRecord] 
		Array of radiation results along transect.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationTransectCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Radiation transect calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        RadiationTransectCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationTransectCalculationRequest object.
        radiation_transect_calculation_request = _RadiationTransectCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the appropriate schema and use that to serialize to json.
        radiation_transect_calculation_request_schema = _RadiationTransectCalculationRequestSchema()

        request_json = radiation_transect_calculation_request_schema.dumps(radiation_transect_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationtransect?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            radiation_transect_calculation_response_schema = _RadiationTransectCalculationResponseSchema()
            radiation_transect_calculation_response = radiation_transect_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(radiation_transect_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation_records = radiation_transect_calculation_response.radiation_records
                self.result_code = radiation_transect_calculation_response.result_code
                self.messages = radiation_transect_calculation_response.messages
                self.calculation_elapsed_time = radiation_transect_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(radiation_transect_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationTransect calculation object"""

        parts = ['* RadiationTransect']

        parts.append(f'*** radiation_records')
        parts.extend(['radiation_records_element' for radiation_records_element in self.radiation_records] if self.radiation_records else [f'radiation_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _RadiationTransectCalculationResponse(_CalculationResponseBase):
    """
    RadiationTransect calculation response class.

    Attributes
    ----------
	radiation_records : list[RadiationRecord] 
		Array of radiation results along transect.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, radiation_records: list[RadiationRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the RadiationTransectCalculationResponse class"""
        super().__init__()

        self.radiation_records = radiation_records if radiation_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Radiation transect calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'radiation_records' in data and data['radiation_records'] is not None:
            self.radiation_records = [record.initialise_from_dictionary(record) for record in data['radiation_records']]
        else:
            self.radiation_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _RadiationTransectForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _RadiationTransectForPoolFires calculation request class.
    
    Attributes
    ----------
	pool_fire_flame_result : PoolFireFlameResult 
		Pool fire flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.
    """
    
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationTransectForPoolFiresCalculationRequest class"""
        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config


class RadiationTransectForPoolFiresCalculation(_CalculationBase):
    """
    RadiationTransectForPoolFires calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	pool_fire_flame_result : PoolFireFlameResult 
		Pool fire flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.

    Calculation outputs:
    
	radiation_records : list[RadiationRecord] 
		Array of radiation results along transect.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationTransectForPoolFiresCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Radiation transect for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        RadiationTransectForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationTransectForPoolFiresCalculationRequest object.
        radiation_transect_for_pool_fires_calculation_request = _RadiationTransectForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the appropriate schema and use that to serialize to json.
        radiation_transect_for_pool_fires_calculation_request_schema = _RadiationTransectForPoolFiresCalculationRequestSchema()

        request_json = radiation_transect_for_pool_fires_calculation_request_schema.dumps(radiation_transect_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationtransectforpoolfires?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            radiation_transect_for_pool_fires_calculation_response_schema = _RadiationTransectForPoolFiresCalculationResponseSchema()
            radiation_transect_for_pool_fires_calculation_response = radiation_transect_for_pool_fires_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(radiation_transect_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation_records = radiation_transect_for_pool_fires_calculation_response.radiation_records
                self.result_code = radiation_transect_for_pool_fires_calculation_response.result_code
                self.messages = radiation_transect_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = radiation_transect_for_pool_fires_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(radiation_transect_for_pool_fires_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationTransectForPoolFires calculation object"""

        parts = ['* RadiationTransectForPoolFires']

        parts.append(f'*** radiation_records')
        parts.extend(['radiation_records_element' for radiation_records_element in self.radiation_records] if self.radiation_records else [f'radiation_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _RadiationTransectForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    RadiationTransectForPoolFires calculation response class.

    Attributes
    ----------
	radiation_records : list[RadiationRecord] 
		Array of radiation results along transect.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, radiation_records: list[RadiationRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the RadiationTransectForPoolFiresCalculationResponse class"""
        super().__init__()

        self.radiation_records = radiation_records if radiation_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Radiation transect for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'radiation_records' in data and data['radiation_records'] is not None:
            self.radiation_records = [record.initialise_from_dictionary(record) for record in data['radiation_records']]
        else:
            self.radiation_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLeakCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeak calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	leak : Leak 
		Leak failure case.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
    """
    
    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselLeakCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters


class VesselLeakCalculation(_CalculationBase):
    """
    VesselLeak calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	leak : Leak 
		Leak failure case.
	discharge_parameters : DischargeParameters 
		Discharge parameters.

    Calculation outputs:
    
	exit_material : Material 
		Composition of the released material (may differ from storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselLeakCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel leak calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLeakCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakCalculationRequest object.
        vessel_leak_calculation_request = _VesselLeakCalculationRequest(self.vessel, self.leak, self.discharge_parameters)

        # Get the appropriate schema and use that to serialize to json.
        vessel_leak_calculation_request_schema = _VesselLeakCalculationRequestSchema()

        request_json = vessel_leak_calculation_request_schema.dumps(vessel_leak_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselleak?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_leak_calculation_response_schema = _VesselLeakCalculationResponseSchema()
            vessel_leak_calculation_response = vessel_leak_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_leak_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_leak_calculation_response.exit_material
                self.discharge_result = vessel_leak_calculation_response.discharge_result
                self.discharge_records = vessel_leak_calculation_response.discharge_records
                self.result_code = vessel_leak_calculation_response.result_code
                self.messages = vessel_leak_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_leak_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeak calculation object"""

        parts = ['* VesselLeak']

        parts.append(f'exit_material: {str(self.exit_material)}')
        parts.append(f'discharge_result: {str(self.discharge_result)}')
        parts.append(f'*** discharge_records')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLeakCalculationResponse(_CalculationResponseBase):
    """
    VesselLeak calculation response class.

    Attributes
    ----------
	exit_material : Material 
		Composition of the released material (may differ from storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLeakCalculationResponse class"""
        super().__init__()

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records if discharge_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel leak calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'exit_material' in data and data['exit_material'] is not None:
            self.exit_material.initialise_from_dictionary(data['exit_material'])
        
        if 'discharge_result' in data and data['discharge_result'] is not None:
            self.discharge_result.initialise_from_dictionary(data['discharge_result'])
        
        if 'discharge_records' in data and data['discharge_records'] is not None:
            self.discharge_records = [record.initialise_from_dictionary(record) for record in data['discharge_records']]
        else:
            self.discharge_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLineRuptureLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselLineRuptureLinkedRun calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	line_rupture : LineRupture 
		Line rupture.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
    """
    
    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselLineRuptureLinkedRunCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count


class VesselLineRuptureLinkedRunCalculation(_CalculationBase):
    """
    VesselLineRuptureLinkedRun calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel definition.
	line_rupture : LineRupture 
		Line rupture.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.

    Calculation outputs:
    
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_contour_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_contour_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion overpressure results.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselLineRuptureLinkedRunCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.njet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.nflam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.npool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.ntoxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel line rupture linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLineRuptureLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLineRuptureLinkedRunCalculationRequest object.
        vessel_line_rupture_linked_run_calculation_request = _VesselLineRuptureLinkedRunCalculationRequest(self.vessel, self.line_rupture, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the appropriate schema and use that to serialize to json.
        vessel_line_rupture_linked_run_calculation_request_schema = _VesselLineRuptureLinkedRunCalculationRequestSchema()

        request_json = vessel_line_rupture_linked_run_calculation_request_schema.dumps(vessel_line_rupture_linked_run_calculation_request)
        url = get_analytics_api_target() + 'calculatevessellinerupturelinkedrun?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_line_rupture_linked_run_calculation_response_schema = _VesselLineRuptureLinkedRunCalculationResponseSchema()
            vessel_line_rupture_linked_run_calculation_response = vessel_line_rupture_linked_run_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_line_rupture_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_line_rupture_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_line_rupture_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_line_rupture_linked_run_calculation_response.jet_contour_points
                self.njet_contour_points = vessel_line_rupture_linked_run_calculation_response.njet_contour_points
                self.area_contour_jet = vessel_line_rupture_linked_run_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = vessel_line_rupture_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = vessel_line_rupture_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.flam_conc_contour_points
                self.nflam_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.nflam_conc_contour_points
                self.area_footprint_flam_conc = vessel_line_rupture_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = vessel_line_rupture_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_line_rupture_linked_run_calculation_response.pool_contour_points
                self.npool_contour_points = vessel_line_rupture_linked_run_calculation_response.npool_contour_points
                self.area_contour_pool = vessel_line_rupture_linked_run_calculation_response.area_contour_pool
                self.explosion_overpressure_results = vessel_line_rupture_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = vessel_line_rupture_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = vessel_line_rupture_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.toxic_conc_contour_points
                self.ntoxic_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.ntoxic_conc_contour_points
                self.area_footprint_toxic_conc = vessel_line_rupture_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = vessel_line_rupture_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_line_rupture_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_line_rupture_linked_run_calculation_response.result_code
                self.messages = vessel_line_rupture_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_line_rupture_linked_run_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_line_rupture_linked_run_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLineRuptureLinkedRun calculation object"""

        parts = ['* VesselLineRuptureLinkedRun']

        parts.append(f'discharge_record: {str(self.discharge_record)}')
        parts.append(f'*** distances_to_jet_fire_radiation')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.append(f'*** jet_contour_points')
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.append(f'*** njet_contour_points')
        parts.extend(['njet_contour_points_element' for njet_contour_points_element in self.njet_contour_points] if self.njet_contour_points else [f'njet_contour_points does not contain any elements'])
        parts.append(f'*** area_contour_jet')
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.append(f'*** distances_to_flam_concentration')
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.append(f'*** flam_concentrations_used')
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.append(f'*** flam_conc_contour_points')
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.append(f'*** nflam_conc_contour_points')
        parts.extend(['nflam_conc_contour_points_element' for nflam_conc_contour_points_element in self.nflam_conc_contour_points] if self.nflam_conc_contour_points else [f'nflam_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_flam_conc')
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.append(f'*** distances_to_pool_fire_radiation')
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.append(f'*** pool_contour_points')
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.append(f'*** npool_contour_points')
        parts.extend(['npool_contour_points_element' for npool_contour_points_element in self.npool_contour_points] if self.npool_contour_points else [f'npool_contour_points does not contain any elements'])
        parts.append(f'*** area_contour_pool')
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.append(f'*** explosion_overpressure_results')
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.append(f'*** distances_to_toxic_concentration')
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.append(f'*** toxic_concentration_used')
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.append(f'*** toxic_conc_contour_points')
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** ntoxic_conc_contour_points')
        parts.extend(['ntoxic_conc_contour_points_element' for ntoxic_conc_contour_points_element in self.ntoxic_conc_contour_points] if self.ntoxic_conc_contour_points else [f'ntoxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_toxic_conc')
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append(f'jet_fire_flame_result: {str(self.jet_fire_flame_result)}')
        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLineRuptureLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    VesselLineRuptureLinkedRun calculation response class.

    Attributes
    ----------
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_contour_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_contour_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion overpressure results.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], njet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], nflam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], npool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], ntoxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLineRuptureLinkedRunCalculationResponse class"""
        super().__init__()

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation if distances_to_jet_fire_radiation is not None else []
        self.jet_contour_points = jet_contour_points if jet_contour_points is not None else []
        self.njet_contour_points = njet_contour_points if njet_contour_points is not None else []
        self.area_contour_jet = area_contour_jet if area_contour_jet is not None else []
        self.distances_to_flam_concentration = distances_to_flam_concentration if distances_to_flam_concentration is not None else []
        self.flam_concentrations_used = flam_concentrations_used if flam_concentrations_used is not None else []
        self.flam_conc_contour_points = flam_conc_contour_points if flam_conc_contour_points is not None else []
        self.nflam_conc_contour_points = nflam_conc_contour_points if nflam_conc_contour_points is not None else []
        self.area_footprint_flam_conc = area_footprint_flam_conc if area_footprint_flam_conc is not None else []
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation if distances_to_pool_fire_radiation is not None else []
        self.pool_contour_points = pool_contour_points if pool_contour_points is not None else []
        self.npool_contour_points = npool_contour_points if npool_contour_points is not None else []
        self.area_contour_pool = area_contour_pool if area_contour_pool is not None else []
        self.explosion_overpressure_results = explosion_overpressure_results if explosion_overpressure_results is not None else []
        self.distances_to_toxic_concentration = distances_to_toxic_concentration if distances_to_toxic_concentration is not None else []
        self.toxic_concentration_used = toxic_concentration_used if toxic_concentration_used is not None else []
        self.toxic_conc_contour_points = toxic_conc_contour_points if toxic_conc_contour_points is not None else []
        self.ntoxic_conc_contour_points = ntoxic_conc_contour_points if ntoxic_conc_contour_points is not None else []
        self.area_footprint_toxic_conc = area_footprint_toxic_conc if area_footprint_toxic_conc is not None else []
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel line rupture linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'discharge_record' in data and data['discharge_record'] is not None:
            self.discharge_record.initialise_from_dictionary(data['discharge_record'])
        
        if 'jet_contour_points' in data and data['jet_contour_points'] is not None:
            self.jet_contour_points = [record.initialise_from_dictionary(record) for record in data['jet_contour_points']]
        else:
            self.jet_contour_points = []
        
        if 'flam_conc_contour_points' in data and data['flam_conc_contour_points'] is not None:
            self.flam_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['flam_conc_contour_points']]
        else:
            self.flam_conc_contour_points = []
        
        if 'pool_contour_points' in data and data['pool_contour_points'] is not None:
            self.pool_contour_points = [record.initialise_from_dictionary(record) for record in data['pool_contour_points']]
        else:
            self.pool_contour_points = []
        
        if 'explosion_overpressure_results' in data and data['explosion_overpressure_results'] is not None:
            self.explosion_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_overpressure_results']]
        else:
            self.explosion_overpressure_results = []
        
        if 'toxic_conc_contour_points' in data and data['toxic_conc_contour_points'] is not None:
            self.toxic_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['toxic_conc_contour_points']]
        else:
            self.toxic_conc_contour_points = []
        
        if 'jet_fire_flame_result' in data and data['jet_fire_flame_result'] is not None:
            self.jet_fire_flame_result.initialise_from_dictionary(data['jet_fire_flame_result'])
        
        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _SetMixingLayerHeightCalculationRequest(_CalculationRequestBase):
    """
    _SetMixingLayerHeight calculation request class.
    
    Attributes
    ----------
	weather : Weather 
		Weather data.
    """
    
    def __init__(self, weather: Weather):
        """Initializes a new instance of the _SetMixingLayerHeightCalculationRequest class"""
        super().__init__()

        self.weather = weather


class SetMixingLayerHeightCalculation(_CalculationBase):
    """
    SetMixingLayerHeight calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	weather : Weather 
		Weather data.

    Calculation outputs:
    
	updated_weather : Weather 
		Updated weather data.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, weather: Weather):
        """Initializes a new instance of the SetMixingLayerHeightCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.weather = weather

        # Calculation outputs.
        self.updated_weather = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Set mixing layer height calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        SetMixingLayerHeightCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetMixingLayerHeightCalculationRequest object.
        set_mixing_layer_height_calculation_request = _SetMixingLayerHeightCalculationRequest(self.weather)

        # Get the appropriate schema and use that to serialize to json.
        set_mixing_layer_height_calculation_request_schema = _SetMixingLayerHeightCalculationRequestSchema()

        request_json = set_mixing_layer_height_calculation_request_schema.dumps(set_mixing_layer_height_calculation_request)
        url = get_analytics_api_target() + 'utilities/setmixinglayerheight?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            set_mixing_layer_height_calculation_response_schema = _SetMixingLayerHeightCalculationResponseSchema()
            set_mixing_layer_height_calculation_response = set_mixing_layer_height_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(set_mixing_layer_height_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.updated_weather = set_mixing_layer_height_calculation_response.updated_weather
                self.result_code = set_mixing_layer_height_calculation_response.result_code
                self.messages = set_mixing_layer_height_calculation_response.messages
                self.calculation_elapsed_time = set_mixing_layer_height_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(set_mixing_layer_height_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the SetMixingLayerHeight calculation object"""

        parts = ['* SetMixingLayerHeight']

        parts.append(f'updated_weather: {str(self.updated_weather)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _SetMixingLayerHeightCalculationResponse(_CalculationResponseBase):
    """
    SetMixingLayerHeight calculation response class.

    Attributes
    ----------
	updated_weather : Weather 
		Updated weather data.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, updated_weather: Weather, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the SetMixingLayerHeightCalculationResponse class"""
        super().__init__()

        self.updated_weather = updated_weather
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Set mixing layer height calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'updated_weather' in data and data['updated_weather'] is not None:
            self.updated_weather.initialise_from_dictionary(data['updated_weather'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _UDSSetTemperatureFromLiqFracCalculationRequest(_CalculationRequestBase):
    """
    _UDSSetTemperatureFromLiqFrac calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material.
	phase_to_be_released : Phase 
		Phase to be released (should be Two-Phase, if not this method simply returns).
	liquid_fraction : float 
		Input liquid fraction.
    """
    
    def __init__(self, material: Material, phase_to_be_released: Phase, liquid_fraction: float):
        """Initializes a new instance of the _UDSSetTemperatureFromLiqFracCalculationRequest class"""
        super().__init__()

        self.material = material
        self.phase_to_be_released = phase_to_be_released
        self.liquid_fraction = liquid_fraction


class UDSSetTemperatureFromLiqFracCalculation(_CalculationBase):
    """
    UDSSetTemperatureFromLiqFrac calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material.
	phase_to_be_released : Phase 
		Phase to be released (should be Two-Phase, if not this method simply returns).
	liquid_fraction : float 
		Input liquid fraction.

    Calculation outputs:
    
	temperature : float 
		Calculated temperature.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, phase_to_be_released: Phase, liquid_fraction: float):
        """Initializes a new instance of the UDSSetTemperatureFromLiqFracCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.phase_to_be_released = phase_to_be_released
        self.liquid_fraction = liquid_fraction

        # Calculation outputs.
        self.temperature = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the UDS set temperature from liq frac calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        UDSSetTemperatureFromLiqFracCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _UDSSetTemperatureFromLiqFracCalculationRequest object.
        uds_set_temperature_from_liq_frac_calculation_request = _UDSSetTemperatureFromLiqFracCalculationRequest(self.material, self.phase_to_be_released, self.liquid_fraction)

        # Get the appropriate schema and use that to serialize to json.
        uds_set_temperature_from_liq_frac_calculation_request_schema = _UDSSetTemperatureFromLiqFracCalculationRequestSchema()

        request_json = uds_set_temperature_from_liq_frac_calculation_request_schema.dumps(uds_set_temperature_from_liq_frac_calculation_request)
        url = get_analytics_api_target() + 'utilities/udssettemperaturefromliquidfraction?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            uds_set_temperature_from_liq_frac_calculation_response_schema = _UDSSetTemperatureFromLiqFracCalculationResponseSchema()
            uds_set_temperature_from_liq_frac_calculation_response = uds_set_temperature_from_liq_frac_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(uds_set_temperature_from_liq_frac_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.temperature = uds_set_temperature_from_liq_frac_calculation_response.temperature
                self.result_code = uds_set_temperature_from_liq_frac_calculation_response.result_code
                self.messages = uds_set_temperature_from_liq_frac_calculation_response.messages
                self.calculation_elapsed_time = uds_set_temperature_from_liq_frac_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(uds_set_temperature_from_liq_frac_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the UDSSetTemperatureFromLiqFrac calculation object"""

        parts = ['* UDSSetTemperatureFromLiqFrac']

        parts.append(f'Temperature : {self.temperature}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _UDSSetTemperatureFromLiqFracCalculationResponse(_CalculationResponseBase):
    """
    UDSSetTemperatureFromLiqFrac calculation response class.

    Attributes
    ----------
	temperature : float 
		Calculated temperature.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, temperature: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the UDSSetTemperatureFromLiqFracCalculationResponse class"""
        super().__init__()

        self.temperature = temperature
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the UDS set temperature from liq frac calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'temperature' in data and data['temperature'] is not None:
            self.temperature
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest(_CalculationRequestBase):
    """
    _LoadMassInventoryVesselForReliefValveScenario calculation request class.
    
    Attributes
    ----------
	material : Material 
		Vessel material.
	mass : float 
		Total vessel mass inventory.
	pressure : float 
		Vessel pressure in absolute scale.
	temperature : float 
		Vessel temperature.
	constriction_size : float 
		Constriction size.
	pipe_diameter : float 
		Pipe diameter.
	pipe_length : float 
		Pipe length.
	release_elevation : float 
		Release elevation.
	release_angle : float 
		Release angle.
    """
    
    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, constriction_size: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest class"""
        super().__init__()

        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.constriction_size = constriction_size
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle


class LoadMassInventoryVesselForReliefValveScenarioCalculation(_CalculationBase):
    """
    LoadMassInventoryVesselForReliefValveScenario calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Vessel material.
	mass : float 
		Total vessel mass inventory.
	pressure : float 
		Vessel pressure in absolute scale.
	temperature : float 
		Vessel temperature.
	constriction_size : float 
		Constriction size.
	pipe_diameter : float 
		Pipe diameter.
	pipe_length : float 
		Pipe length.
	release_elevation : float 
		Release elevation.
	release_angle : float 
		Release angle.

    Calculation outputs:
    
	vessel : Vessel 
		Vessel definition.
	relief_valve : ReliefValve 
		Relief valve.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, constriction_size: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the LoadMassInventoryVesselForReliefValveScenarioCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.constriction_size = constriction_size
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle

        # Calculation outputs.
        self.vessel = None
        self.relief_valve = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Load mass inventory vessel for relief valve scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        LoadMassInventoryVesselForReliefValveScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest object.
        load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request = _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest(self.material, self.mass, self.pressure, self.temperature, self.constriction_size, self.pipe_diameter, self.pipe_length, self.release_elevation, self.release_angle)

        # Get the appropriate schema and use that to serialize to json.
        load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request_schema = _LoadMassInventoryVesselForReliefValveScenarioCalculationRequestSchema()

        request_json = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request_schema.dumps(load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/loadmassinventoryvesselforreliefvalvescenario?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response_schema = _LoadMassInventoryVesselForReliefValveScenarioCalculationResponseSchema()
            load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.vessel
                self.relief_valve = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.relief_valve
                self.result_code = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.result_code
                self.messages = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.messages
                self.calculation_elapsed_time = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the LoadMassInventoryVesselForReliefValveScenario calculation object"""

        parts = ['* LoadMassInventoryVesselForReliefValveScenario']

        parts.append(f'vessel: {str(self.vessel)}')
        parts.append(f'relief_valve: {str(self.relief_valve)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _LoadMassInventoryVesselForReliefValveScenarioCalculationResponse(_CalculationResponseBase):
    """
    LoadMassInventoryVesselForReliefValveScenario calculation response class.

    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	relief_valve : ReliefValve 
		Relief valve.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the LoadMassInventoryVesselForReliefValveScenarioCalculationResponse class"""
        super().__init__()

        self.vessel = vessel
        self.relief_valve = relief_valve
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Load mass inventory vessel for relief valve scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'vessel' in data and data['vessel'] is not None:
            self.vessel.initialise_from_dictionary(data['vessel'])
        
        if 'relief_valve' in data and data['relief_valve'] is not None:
            self.relief_valve.initialise_from_dictionary(data['relief_valve'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _DistancesAndEllipsesToRadiationLevelsForPoolFires calculation request class.
    
    Attributes
    ----------
	pool_fire_flame_result : PoolFireFlameResult 
		Scalar pool fire flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings of radiation calculations.
	flammable_output_config_count : int 
		Number of radiation levels.
    """
    
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest class"""
        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count


class DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation(_CalculationBase):
    """
    DistancesAndEllipsesToRadiationLevelsForPoolFires calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	pool_fire_flame_result : PoolFireFlameResult 
		Scalar pool fire flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings of radiation calculations.
	flammable_output_config_count : int 
		Number of radiation levels.

    Calculation outputs:
    
	distances : list[float] 
		Distances to radiation levels.
	contour_points : list[LocalPosition] 
		Contour points of radiation ellipses to radiation levels.
	ncontour_points : list[int] 
		Number of contour points per radiation level.
	areas : list[float] 
		Area of the ellipse to radiation levels.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.distances = None
        self.contour_points = None
        self.ncontour_points = None
        self.areas = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Distances and ellipses to radiation levels for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest object.
        distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request = _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the appropriate schema and use that to serialize to json.
        distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request_schema = _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequestSchema()

        request_json = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request_schema.dumps(distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancesandellipsestoradiationlevelsforpoolfires?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response_schema = _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponseSchema()
            distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.distances
                self.contour_points = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.contour_points
                self.ncontour_points = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.ncontour_points
                self.areas = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.areas
                self.result_code = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.result_code
                self.messages = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesAndEllipsesToRadiationLevelsForPoolFires calculation object"""

        parts = ['* DistancesAndEllipsesToRadiationLevelsForPoolFires']

        parts.append(f'*** distances')
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.append(f'*** contour_points')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'*** ncontour_points')
        parts.extend(['ncontour_points_element' for ncontour_points_element in self.ncontour_points] if self.ncontour_points else [f'ncontour_points does not contain any elements'])
        parts.append(f'*** areas')
        parts.extend(['areas_element' for areas_element in self.areas] if self.areas else [f'areas does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    DistancesAndEllipsesToRadiationLevelsForPoolFires calculation response class.

    Attributes
    ----------
	distances : list[float] 
		Distances to radiation levels.
	contour_points : list[LocalPosition] 
		Contour points of radiation ellipses to radiation levels.
	ncontour_points : list[int] 
		Number of contour points per radiation level.
	areas : list[float] 
		Area of the ellipse to radiation levels.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, distances: list[float], contour_points: list[LocalPosition], ncontour_points: list[int], areas: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse class"""
        super().__init__()

        self.distances = distances if distances is not None else []
        self.contour_points = contour_points if contour_points is not None else []
        self.ncontour_points = ncontour_points if ncontour_points is not None else []
        self.areas = areas if areas is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Distances and ellipses to radiation levels for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'contour_points' in data and data['contour_points'] is not None:
            self.contour_points = [record.initialise_from_dictionary(record) for record in data['contour_points']]
        else:
            self.contour_points = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _GetMassFromVesselCalculationRequest(_CalculationRequestBase):
    """
    _GetMassFromVessel calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel (pressurised).
    """
    
    def __init__(self, vessel: Vessel):
        """Initializes a new instance of the _GetMassFromVesselCalculationRequest class"""
        super().__init__()

        self.vessel = vessel


class GetMassFromVesselCalculation(_CalculationBase):
    """
    GetMassFromVessel calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel (pressurised).

    Calculation outputs:
    
	mass_inventory : float 
		Mass inventory in the vessel (kg).
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel):
        """Initializes a new instance of the GetMassFromVesselCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel

        # Calculation outputs.
        self.mass_inventory = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Get mass from vessel calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        GetMassFromVesselCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _GetMassFromVesselCalculationRequest object.
        get_mass_from_vessel_calculation_request = _GetMassFromVesselCalculationRequest(self.vessel)

        # Get the appropriate schema and use that to serialize to json.
        get_mass_from_vessel_calculation_request_schema = _GetMassFromVesselCalculationRequestSchema()

        request_json = get_mass_from_vessel_calculation_request_schema.dumps(get_mass_from_vessel_calculation_request)
        url = get_analytics_api_target() + 'utilities/getmassfromvessel?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            get_mass_from_vessel_calculation_response_schema = _GetMassFromVesselCalculationResponseSchema()
            get_mass_from_vessel_calculation_response = get_mass_from_vessel_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(get_mass_from_vessel_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.mass_inventory = get_mass_from_vessel_calculation_response.mass_inventory
                self.result_code = get_mass_from_vessel_calculation_response.result_code
                self.messages = get_mass_from_vessel_calculation_response.messages
                self.calculation_elapsed_time = get_mass_from_vessel_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(get_mass_from_vessel_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the GetMassFromVessel calculation object"""

        parts = ['* GetMassFromVessel']

        parts.append(f'MassInventory : {self.mass_inventory}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _GetMassFromVesselCalculationResponse(_CalculationResponseBase):
    """
    GetMassFromVessel calculation response class.

    Attributes
    ----------
	mass_inventory : float 
		Mass inventory in the vessel (kg).
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, mass_inventory: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the GetMassFromVesselCalculationResponse class"""
        super().__init__()

        self.mass_inventory = mass_inventory
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Get mass from vessel calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'mass_inventory' in data and data['mass_inventory'] is not None:
            self.mass_inventory
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _UDSTemperatureLimitsCalculationRequest(_CalculationRequestBase):
    """
    _UDSTemperatureLimits calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material.
	phase_to_be_released : Phase 
		Phase to be released (Vapour, Two-phase or Liquid).
    """
    
    def __init__(self, material: Material, phase_to_be_released: Phase):
        """Initializes a new instance of the _UDSTemperatureLimitsCalculationRequest class"""
        super().__init__()

        self.material = material
        self.phase_to_be_released = phase_to_be_released


class UDSTemperatureLimitsCalculation(_CalculationBase):
    """
    UDSTemperatureLimits calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material.
	phase_to_be_released : Phase 
		Phase to be released (Vapour, Two-phase or Liquid).

    Calculation outputs:
    
	min_temperature : float 
		Lower temperature limit to ensure consistency.
	max_temperature : float 
		Upper temperature limit to ensure consistency.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, phase_to_be_released: Phase):
        """Initializes a new instance of the UDSTemperatureLimitsCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.phase_to_be_released = phase_to_be_released

        # Calculation outputs.
        self.min_temperature = None
        self.max_temperature = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the UDS temperature limits calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        UDSTemperatureLimitsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _UDSTemperatureLimitsCalculationRequest object.
        uds_temperature_limits_calculation_request = _UDSTemperatureLimitsCalculationRequest(self.material, self.phase_to_be_released)

        # Get the appropriate schema and use that to serialize to json.
        uds_temperature_limits_calculation_request_schema = _UDSTemperatureLimitsCalculationRequestSchema()

        request_json = uds_temperature_limits_calculation_request_schema.dumps(uds_temperature_limits_calculation_request)
        url = get_analytics_api_target() + 'utilities/udstemperaturelimitscalculation?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            uds_temperature_limits_calculation_response_schema = _UDSTemperatureLimitsCalculationResponseSchema()
            uds_temperature_limits_calculation_response = uds_temperature_limits_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(uds_temperature_limits_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.min_temperature = uds_temperature_limits_calculation_response.min_temperature
                self.max_temperature = uds_temperature_limits_calculation_response.max_temperature
                self.result_code = uds_temperature_limits_calculation_response.result_code
                self.messages = uds_temperature_limits_calculation_response.messages
                self.calculation_elapsed_time = uds_temperature_limits_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(uds_temperature_limits_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the UDSTemperatureLimits calculation object"""

        parts = ['* UDSTemperatureLimits']

        parts.append(f'MinTemperature : {self.min_temperature}')
        parts.append(f'MaxTemperature : {self.max_temperature}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _UDSTemperatureLimitsCalculationResponse(_CalculationResponseBase):
    """
    UDSTemperatureLimits calculation response class.

    Attributes
    ----------
	min_temperature : float 
		Lower temperature limit to ensure consistency.
	max_temperature : float 
		Upper temperature limit to ensure consistency.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, min_temperature: float, max_temperature: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the UDSTemperatureLimitsCalculationResponse class"""
        super().__init__()

        self.min_temperature = min_temperature
        self.max_temperature = max_temperature
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the UDS temperature limits calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'min_temperature' in data and data['min_temperature'] is not None:
            self.min_temperature
        
        if 'max_temperature' in data and data['max_temperature'] is not None:
            self.max_temperature
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _MaxConcFootprintCalculationRequest(_CalculationRequestBase):
    """
    _MaxConcFootprint calculation request class.
    
    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _MaxConcFootprintCalculationRequest class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters


class MaxConcFootprintCalculation(_CalculationBase):
    """
    MaxConcFootprint calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	conc_used : float 
		Concentration of interest.
	contour_points : list[LocalPosition] 
		Array of footprint results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the MaxConcFootprintCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.contour_points = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Max conc footprint calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        MaxConcFootprintCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MaxConcFootprintCalculationRequest object.
        max_conc_footprint_calculation_request = _MaxConcFootprintCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        max_conc_footprint_calculation_request_schema = _MaxConcFootprintCalculationRequestSchema()

        request_json = max_conc_footprint_calculation_request_schema.dumps(max_conc_footprint_calculation_request)
        url = get_analytics_api_target() + 'calculatemaxconcfootprint?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            max_conc_footprint_calculation_response_schema = _MaxConcFootprintCalculationResponseSchema()
            max_conc_footprint_calculation_response = max_conc_footprint_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(max_conc_footprint_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = max_conc_footprint_calculation_response.conc_used
                self.contour_points = max_conc_footprint_calculation_response.contour_points
                self.result_code = max_conc_footprint_calculation_response.result_code
                self.messages = max_conc_footprint_calculation_response.messages
                self.calculation_elapsed_time = max_conc_footprint_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(max_conc_footprint_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the MaxConcFootprint calculation object"""

        parts = ['* MaxConcFootprint']

        parts.append(f'ConcUsed : {self.conc_used}')
        parts.append(f'*** contour_points')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _MaxConcFootprintCalculationResponse(_CalculationResponseBase):
    """
    MaxConcFootprint calculation response class.

    Attributes
    ----------
	conc_used : float 
		Concentration of interest.
	contour_points : list[LocalPosition] 
		Array of footprint results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, conc_used: float, contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the MaxConcFootprintCalculationResponse class"""
        super().__init__()

        self.conc_used = conc_used
        self.contour_points = contour_points if contour_points is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Max conc footprint calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'conc_used' in data and data['conc_used'] is not None:
            self.conc_used
        
        if 'contour_points' in data and data['contour_points'] is not None:
            self.contour_points = [record.initialise_from_dictionary(record) for record in data['contour_points']]
        else:
            self.contour_points = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _DistancesToConcLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesToConcLevels calculation request class.
    
    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Concentration levels.
	dispersion_output_config_count : int 
		Number of concentration levels.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _DistancesToConcLevelsCalculationRequest class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.material = material
        self.dispersion_parameters = dispersion_parameters


class DistancesToConcLevelsCalculation(_CalculationBase):
    """
    DistancesToConcLevels calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Concentration levels.
	dispersion_output_config_count : int 
		Number of concentration levels.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	conc_used : list[float] 
		Concentrations of interest.
	distances : list[float] 
		Distances to concentration of interest.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the DistancesToConcLevelsCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.distances = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Distances to conc levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        DistancesToConcLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesToConcLevelsCalculationRequest object.
        distances_to_conc_levels_calculation_request = _DistancesToConcLevelsCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_configs, self.dispersion_output_config_count, self.material, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        distances_to_conc_levels_calculation_request_schema = _DistancesToConcLevelsCalculationRequestSchema()

        request_json = distances_to_conc_levels_calculation_request_schema.dumps(distances_to_conc_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancestoconclevels?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            distances_to_conc_levels_calculation_response_schema = _DistancesToConcLevelsCalculationResponseSchema()
            distances_to_conc_levels_calculation_response = distances_to_conc_levels_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(distances_to_conc_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = distances_to_conc_levels_calculation_response.conc_used
                self.distances = distances_to_conc_levels_calculation_response.distances
                self.result_code = distances_to_conc_levels_calculation_response.result_code
                self.messages = distances_to_conc_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_to_conc_levels_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(distances_to_conc_levels_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesToConcLevels calculation object"""

        parts = ['* DistancesToConcLevels']

        parts.append(f'*** conc_used')
        parts.extend(['conc_used_element' for conc_used_element in self.conc_used] if self.conc_used else [f'conc_used does not contain any elements'])
        parts.append(f'*** distances')
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _DistancesToConcLevelsCalculationResponse(_CalculationResponseBase):
    """
    DistancesToConcLevels calculation response class.

    Attributes
    ----------
	conc_used : list[float] 
		Concentrations of interest.
	distances : list[float] 
		Distances to concentration of interest.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, conc_used: list[float], distances: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the DistancesToConcLevelsCalculationResponse class"""
        super().__init__()

        self.conc_used = conc_used if conc_used is not None else []
        self.distances = distances if distances is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Distances to conc levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _JetFireCalculationRequest(_CalculationRequestBase):
    """
    _JetFire calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material with post-discharge composition.
	discharge_records : list[DischargeRecord] 
		Discharge / source term definition.
	discharge_record_count : int 
		Number of discharge records.
	discharge_result : DischargeResult 
		Discharge / source term definition.
	weather : Weather 
		Weather.
	substrate : Substrate 
		Substrate.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
    """
    
    def __init__(self, material: Material, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the _JetFireCalculationRequest class"""
        super().__init__()

        self.material = material
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters


class JetFireCalculation(_CalculationBase):
    """
    JetFire calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material with post-discharge composition.
	discharge_records : list[DischargeRecord] 
		Discharge / source term definition.
	discharge_record_count : int 
		Number of discharge records.
	discharge_result : DischargeResult 
		Discharge / source term definition.
	weather : Weather 
		Weather.
	substrate : Substrate 
		Substrate.
	flammable_parameters : FlammableParameters 
		Flammable parameters.

    Calculation outputs:
    
	flame_result : FlameResult 
		Flame scalar results.
	flame_records : list[FlameRecord] 
		Array of jet fire flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the JetFireCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

        # Calculation outputs.
        self.flame_result = None
        self.flame_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Jet fire calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        JetFireCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _JetFireCalculationRequest object.
        jet_fire_calculation_request = _JetFireCalculationRequest(self.material, self.discharge_records, self.discharge_record_count, self.discharge_result, self.weather, self.substrate, self.flammable_parameters)

        # Get the appropriate schema and use that to serialize to json.
        jet_fire_calculation_request_schema = _JetFireCalculationRequestSchema()

        request_json = jet_fire_calculation_request_schema.dumps(jet_fire_calculation_request)
        url = get_analytics_api_target() + 'calculatejetfire?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            jet_fire_calculation_response_schema = _JetFireCalculationResponseSchema()
            jet_fire_calculation_response = jet_fire_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(jet_fire_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.flame_result = jet_fire_calculation_response.flame_result
                self.flame_records = jet_fire_calculation_response.flame_records
                self.result_code = jet_fire_calculation_response.result_code
                self.messages = jet_fire_calculation_response.messages
                self.calculation_elapsed_time = jet_fire_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(jet_fire_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the JetFire calculation object"""

        parts = ['* JetFire']

        parts.append(f'flame_result: {str(self.flame_result)}')
        parts.append(f'*** flame_records')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _JetFireCalculationResponse(_CalculationResponseBase):
    """
    JetFire calculation response class.

    Attributes
    ----------
	flame_result : FlameResult 
		Flame scalar results.
	flame_records : list[FlameRecord] 
		Array of jet fire flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the JetFireCalculationResponse class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records if flame_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Jet fire calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'flame_result' in data and data['flame_result'] is not None:
            self.flame_result.initialise_from_dictionary(data['flame_result'])
        
        if 'flame_records' in data and data['flame_records'] is not None:
            self.flame_records = [record.initialise_from_dictionary(record) for record in data['flame_records']]
        else:
            self.flame_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _RadiationAtAPointForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtAPointForPoolFires calculation request class.
    
    Attributes
    ----------
	pool_fire_flame_result : PoolFireFlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.
    """
    
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationAtAPointForPoolFiresCalculationRequest class"""
        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config


class RadiationAtAPointForPoolFiresCalculation(_CalculationBase):
    """
    RadiationAtAPointForPoolFires calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	pool_fire_flame_result : PoolFireFlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.

    Calculation outputs:
    
	radiation : float 
		Radiation at a point.
	result_code : ResultCode 
		Response code.

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationAtAPointForPoolFiresCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Radiation at a point for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        RadiationAtAPointForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtAPointForPoolFiresCalculationRequest object.
        radiation_at_apoint_for_pool_fires_calculation_request = _RadiationAtAPointForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the appropriate schema and use that to serialize to json.
        radiation_at_apoint_for_pool_fires_calculation_request_schema = _RadiationAtAPointForPoolFiresCalculationRequestSchema()

        request_json = radiation_at_apoint_for_pool_fires_calculation_request_schema.dumps(radiation_at_apoint_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatapointforpoolfires?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            radiation_at_apoint_for_pool_fires_calculation_response_schema = _RadiationAtAPointForPoolFiresCalculationResponseSchema()
            radiation_at_apoint_for_pool_fires_calculation_response = radiation_at_apoint_for_pool_fires_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(radiation_at_apoint_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_apoint_for_pool_fires_calculation_response.radiation
                self.result_code = radiation_at_apoint_for_pool_fires_calculation_response.result_code
                self.messages = radiation_at_apoint_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_apoint_for_pool_fires_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(radiation_at_apoint_for_pool_fires_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtAPointForPoolFires calculation object"""

        parts = ['* RadiationAtAPointForPoolFires']

        parts.append(f'Radiation : {self.radiation}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _RadiationAtAPointForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    RadiationAtAPointForPoolFires calculation response class.

    Attributes
    ----------
	radiation : float 
		Radiation at a point.
	result_code : ResultCode 
		Response code.
    """

    def __init__(self, radiation: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the RadiationAtAPointForPoolFiresCalculationResponse class"""
        super().__init__()

        self.radiation = radiation
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Radiation at a point for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'radiation' in data and data['radiation'] is not None:
            self.radiation
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _ConvertCompositionMoleToMassCalculationRequest(_CalculationRequestBase):
    """
    _ConvertCompositionMoleToMass calculation request class.
    
    Attributes
    ----------
	mixture : Material 
		Mixture to have composition converted.
	composition_moles : list[float] 
		Input composition of mixture in mole basis.
	composition_moles_count : int 
		Number of components in mixture.
    """
    
    def __init__(self, mixture: Material, composition_moles: list[float], composition_moles_count: int):
        """Initializes a new instance of the _ConvertCompositionMoleToMassCalculationRequest class"""
        super().__init__()

        self.mixture = mixture
        self.composition_moles = composition_moles
        self.composition_moles_count = composition_moles_count


class ConvertCompositionMoleToMassCalculation(_CalculationBase):
    """
    ConvertCompositionMoleToMass calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	mixture : Material 
		Mixture to have composition converted.
	composition_moles : list[float] 
		Input composition of mixture in mole basis.
	composition_moles_count : int 
		Number of components in mixture.

    Calculation outputs:
    
	composition_mass : list[float] 
		Output composition of mixture in mass basis.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, mixture: Material, composition_moles: list[float], composition_moles_count: int):
        """Initializes a new instance of the ConvertCompositionMoleToMassCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.mixture = mixture
        self.composition_moles = composition_moles
        self.composition_moles_count = composition_moles_count

        # Calculation outputs.
        self.composition_mass = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Convert composition mole to mass calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        ConvertCompositionMoleToMassCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ConvertCompositionMoleToMassCalculationRequest object.
        convert_composition_mole_to_mass_calculation_request = _ConvertCompositionMoleToMassCalculationRequest(self.mixture, self.composition_moles, self.composition_moles_count)

        # Get the appropriate schema and use that to serialize to json.
        convert_composition_mole_to_mass_calculation_request_schema = _ConvertCompositionMoleToMassCalculationRequestSchema()

        request_json = convert_composition_mole_to_mass_calculation_request_schema.dumps(convert_composition_mole_to_mass_calculation_request)
        url = get_analytics_api_target() + 'utilities/convertcompositionmoletomass?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            convert_composition_mole_to_mass_calculation_response_schema = _ConvertCompositionMoleToMassCalculationResponseSchema()
            convert_composition_mole_to_mass_calculation_response = convert_composition_mole_to_mass_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(convert_composition_mole_to_mass_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.composition_mass = convert_composition_mole_to_mass_calculation_response.composition_mass
                self.result_code = convert_composition_mole_to_mass_calculation_response.result_code
                self.messages = convert_composition_mole_to_mass_calculation_response.messages
                self.calculation_elapsed_time = convert_composition_mole_to_mass_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(convert_composition_mole_to_mass_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the ConvertCompositionMoleToMass calculation object"""

        parts = ['* ConvertCompositionMoleToMass']

        parts.append(f'*** composition_mass')
        parts.extend(['composition_mass_element' for composition_mass_element in self.composition_mass] if self.composition_mass else [f'composition_mass does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _ConvertCompositionMoleToMassCalculationResponse(_CalculationResponseBase):
    """
    ConvertCompositionMoleToMass calculation response class.

    Attributes
    ----------
	composition_mass : list[float] 
		Output composition of mixture in mass basis.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, composition_mass: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the ConvertCompositionMoleToMassCalculationResponse class"""
        super().__init__()

        self.composition_mass = composition_mass if composition_mass is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Convert composition mole to mass calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _FireballCalculationRequest(_CalculationRequestBase):
    """
    _Fireball calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material with post-discharge composition.
	state : State 
		The thermodynamic conditions.
	discharge_records : list[DischargeRecord] 
		Discharge / source term definition.
	discharge_record_count : int 
		Number of discharge records.
	discharge_result : DischargeResult 
		Discharge / source term definition.
	weather : Weather 
		Weather.
    """
    
    def __init__(self, material: Material, state: State, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather):
        """Initializes a new instance of the _FireballCalculationRequest class"""
        super().__init__()

        self.material = material
        self.state = state
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather


class FireballCalculation(_CalculationBase):
    """
    Fireball calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material with post-discharge composition.
	state : State 
		The thermodynamic conditions.
	discharge_records : list[DischargeRecord] 
		Discharge / source term definition.
	discharge_record_count : int 
		Number of discharge records.
	discharge_result : DischargeResult 
		Discharge / source term definition.
	weather : Weather 
		Weather.

    Calculation outputs:
    
	flame_result : FlameResult 
		Flame scalar result.
	flame_records : list[FlameRecord] 
		Array of fireball flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, state: State, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather):
        """Initializes a new instance of the FireballCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.state = state
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather

        # Calculation outputs.
        self.flame_result = None
        self.flame_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Fireball calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        FireballCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _FireballCalculationRequest object.
        fireball_calculation_request = _FireballCalculationRequest(self.material, self.state, self.discharge_records, self.discharge_record_count, self.discharge_result, self.weather)

        # Get the appropriate schema and use that to serialize to json.
        fireball_calculation_request_schema = _FireballCalculationRequestSchema()

        request_json = fireball_calculation_request_schema.dumps(fireball_calculation_request)
        url = get_analytics_api_target() + 'calculatefireball?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            fireball_calculation_response_schema = _FireballCalculationResponseSchema()
            fireball_calculation_response = fireball_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(fireball_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.flame_result = fireball_calculation_response.flame_result
                self.flame_records = fireball_calculation_response.flame_records
                self.result_code = fireball_calculation_response.result_code
                self.messages = fireball_calculation_response.messages
                self.calculation_elapsed_time = fireball_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(fireball_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the Fireball calculation object"""

        parts = ['* Fireball']

        parts.append(f'flame_result: {str(self.flame_result)}')
        parts.append(f'*** flame_records')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _FireballCalculationResponse(_CalculationResponseBase):
    """
    Fireball calculation response class.

    Attributes
    ----------
	flame_result : FlameResult 
		Flame scalar result.
	flame_records : list[FlameRecord] 
		Array of fireball flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the FireballCalculationResponse class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records if flame_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Fireball calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'flame_result' in data and data['flame_result'] is not None:
            self.flame_result.initialise_from_dictionary(data['flame_result'])
        
        if 'flame_records' in data and data['flame_records'] is not None:
            self.flame_records = [record.initialise_from_dictionary(record) for record in data['flame_records']]
        else:
            self.flame_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _FlareStackDesignerCalculationRequest(_CalculationRequestBase):
    """
    _FlareStackDesigner calculation request class.
    
    Attributes
    ----------
	flare_stack : FlareStack 
		Flare stack asset.
	flare_stack_constraint : Constraint 
		Data that defines the design requirements.
	weather : Weather 
		Weather.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		Substrate data.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Defines the flammable results of interest.
    """
    
    def __init__(self, flare_stack: FlareStack, flare_stack_constraint: Constraint, weather: Weather, discharge_parameters: DischargeParameters, substrate: Substrate, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _FlareStackDesignerCalculationRequest class"""
        super().__init__()

        self.flare_stack = flare_stack
        self.flare_stack_constraint = flare_stack_constraint
        self.weather = weather
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config


class FlareStackDesignerCalculation(_CalculationBase):
    """
    FlareStackDesigner calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flare_stack : FlareStack 
		Flare stack asset.
	flare_stack_constraint : Constraint 
		Data that defines the design requirements.
	weather : Weather 
		Weather.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		Substrate data.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Defines the flammable results of interest.

    Calculation outputs:
    
	design_solution : float 
		Value of design variable that satisfies the design target.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flare_stack: FlareStack, flare_stack_constraint: Constraint, weather: Weather, discharge_parameters: DischargeParameters, substrate: Substrate, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the FlareStackDesignerCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flare_stack = flare_stack
        self.flare_stack_constraint = flare_stack_constraint
        self.weather = weather
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.design_solution = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Flare stack designer calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        FlareStackDesignerCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _FlareStackDesignerCalculationRequest object.
        flare_stack_designer_calculation_request = _FlareStackDesignerCalculationRequest(self.flare_stack, self.flare_stack_constraint, self.weather, self.discharge_parameters, self.substrate, self.flammable_parameters, self.flammable_output_config)

        # Get the appropriate schema and use that to serialize to json.
        flare_stack_designer_calculation_request_schema = _FlareStackDesignerCalculationRequestSchema()

        request_json = flare_stack_designer_calculation_request_schema.dumps(flare_stack_designer_calculation_request)
        url = get_analytics_api_target() + 'calculateflarestackdesigner?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            flare_stack_designer_calculation_response_schema = _FlareStackDesignerCalculationResponseSchema()
            flare_stack_designer_calculation_response = flare_stack_designer_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(flare_stack_designer_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.design_solution = flare_stack_designer_calculation_response.design_solution
                self.result_code = flare_stack_designer_calculation_response.result_code
                self.messages = flare_stack_designer_calculation_response.messages
                self.calculation_elapsed_time = flare_stack_designer_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(flare_stack_designer_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the FlareStackDesigner calculation object"""

        parts = ['* FlareStackDesigner']

        parts.append(f'DesignSolution : {self.design_solution}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _FlareStackDesignerCalculationResponse(_CalculationResponseBase):
    """
    FlareStackDesigner calculation response class.

    Attributes
    ----------
	design_solution : float 
		Value of design variable that satisfies the design target.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, design_solution: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the FlareStackDesignerCalculationResponse class"""
        super().__init__()

        self.design_solution = design_solution
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Flare stack designer calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'design_solution' in data and data['design_solution'] is not None:
            self.design_solution
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _LateExplosionToOPLevelsCalculationRequest(_CalculationRequestBase):
    """
    _LateExplosionToOPLevels calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material with post-discharge composition.
	scalar_udm_outputs : ScalarUdmOutputs 
		Dispersion scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Cloud definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		Substrate.
	dispersion_output_config : DispersionOutputConfig 
		Specification of cloud view.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Explosion output configurations.
	explosion_output_config_count : int 
		Number of explosion output configurations.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _LateExplosionToOPLevelsCalculationRequest class"""
        super().__init__()

        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters


class LateExplosionToOPLevelsCalculation(_CalculationBase):
    """
    LateExplosionToOPLevels calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material with post-discharge composition.
	scalar_udm_outputs : ScalarUdmOutputs 
		Dispersion scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Cloud definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		Substrate.
	dispersion_output_config : DispersionOutputConfig 
		Specification of cloud view.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Explosion output configurations.
	explosion_output_config_count : int 
		Number of explosion output configurations.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	explosion_unif_conf_overpressure_results : list[ExplosionOverpressureResult] 
		Uniform confined explosion overpressure results.
	explosion_unconf_overpressure_results : list[ExplosionOverpressureResult] 
		Unconfined explosion overpressure results.
	result_code : ResultCode 
		Eror code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the LateExplosionToOPLevelsCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.explosion_unif_conf_overpressure_results = None
        self.explosion_unconf_overpressure_results = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Late explosion to o p levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        LateExplosionToOPLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LateExplosionToOPLevelsCalculationRequest object.
        late_explosion_to_oplevels_calculation_request = _LateExplosionToOPLevelsCalculationRequest(self.material, self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_parameters, self.explosion_confined_volumes, self.explosion_confined_volume_count, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        late_explosion_to_oplevels_calculation_request_schema = _LateExplosionToOPLevelsCalculationRequestSchema()

        request_json = late_explosion_to_oplevels_calculation_request_schema.dumps(late_explosion_to_oplevels_calculation_request)
        url = get_analytics_api_target() + 'calculatelateexplosiontooplevels?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            late_explosion_to_oplevels_calculation_response_schema = _LateExplosionToOPLevelsCalculationResponseSchema()
            late_explosion_to_oplevels_calculation_response = late_explosion_to_oplevels_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(late_explosion_to_oplevels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.explosion_unif_conf_overpressure_results = late_explosion_to_oplevels_calculation_response.explosion_unif_conf_overpressure_results
                self.explosion_unconf_overpressure_results = late_explosion_to_oplevels_calculation_response.explosion_unconf_overpressure_results
                self.result_code = late_explosion_to_oplevels_calculation_response.result_code
                self.messages = late_explosion_to_oplevels_calculation_response.messages
                self.calculation_elapsed_time = late_explosion_to_oplevels_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(late_explosion_to_oplevels_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the LateExplosionToOPLevels calculation object"""

        parts = ['* LateExplosionToOPLevels']

        parts.append(f'*** explosion_unif_conf_overpressure_results')
        parts.extend(['explosion_unif_conf_overpressure_results_element' for explosion_unif_conf_overpressure_results_element in self.explosion_unif_conf_overpressure_results] if self.explosion_unif_conf_overpressure_results else [f'explosion_unif_conf_overpressure_results does not contain any elements'])
        parts.append(f'*** explosion_unconf_overpressure_results')
        parts.extend(['explosion_unconf_overpressure_results_element' for explosion_unconf_overpressure_results_element in self.explosion_unconf_overpressure_results] if self.explosion_unconf_overpressure_results else [f'explosion_unconf_overpressure_results does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _LateExplosionToOPLevelsCalculationResponse(_CalculationResponseBase):
    """
    LateExplosionToOPLevels calculation response class.

    Attributes
    ----------
	explosion_unif_conf_overpressure_results : list[ExplosionOverpressureResult] 
		Uniform confined explosion overpressure results.
	explosion_unconf_overpressure_results : list[ExplosionOverpressureResult] 
		Unconfined explosion overpressure results.
	result_code : ResultCode 
		Eror code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, explosion_unif_conf_overpressure_results: list[ExplosionOverpressureResult], explosion_unconf_overpressure_results: list[ExplosionOverpressureResult], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the LateExplosionToOPLevelsCalculationResponse class"""
        super().__init__()

        self.explosion_unif_conf_overpressure_results = explosion_unif_conf_overpressure_results if explosion_unif_conf_overpressure_results is not None else []
        self.explosion_unconf_overpressure_results = explosion_unconf_overpressure_results if explosion_unconf_overpressure_results is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Late explosion to o p levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'explosion_unif_conf_overpressure_results' in data and data['explosion_unif_conf_overpressure_results'] is not None:
            self.explosion_unif_conf_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_unif_conf_overpressure_results']]
        else:
            self.explosion_unif_conf_overpressure_results = []
        
        if 'explosion_unconf_overpressure_results' in data and data['explosion_unconf_overpressure_results'] is not None:
            self.explosion_unconf_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_unconf_overpressure_results']]
        else:
            self.explosion_unconf_overpressure_results = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _LethalityDistanceCalculationRequest(_CalculationRequestBase):
    """
    _LethalityDistance calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material with post-discharge composition.
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _LethalityDistanceCalculationRequest class"""
        super().__init__()

        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.dispersion_parameters = dispersion_parameters


class LethalityDistanceCalculation(_CalculationBase):
    """
    LethalityDistance calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material with post-discharge composition.
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	toxic_records : list[ToxicRecord] 
		Array of toxic results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the LethalityDistanceCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.toxic_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Lethality distance calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        LethalityDistanceCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LethalityDistanceCalculationRequest object.
        lethality_distance_calculation_request = _LethalityDistanceCalculationRequest(self.material, self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        lethality_distance_calculation_request_schema = _LethalityDistanceCalculationRequestSchema()

        request_json = lethality_distance_calculation_request_schema.dumps(lethality_distance_calculation_request)
        url = get_analytics_api_target() + 'calculatelethalitydistance?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            lethality_distance_calculation_response_schema = _LethalityDistanceCalculationResponseSchema()
            lethality_distance_calculation_response = lethality_distance_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(lethality_distance_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.toxic_records = lethality_distance_calculation_response.toxic_records
                self.result_code = lethality_distance_calculation_response.result_code
                self.messages = lethality_distance_calculation_response.messages
                self.calculation_elapsed_time = lethality_distance_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(lethality_distance_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the LethalityDistance calculation object"""

        parts = ['* LethalityDistance']

        parts.append(f'*** toxic_records')
        parts.extend(['toxic_records_element' for toxic_records_element in self.toxic_records] if self.toxic_records else [f'toxic_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _LethalityDistanceCalculationResponse(_CalculationResponseBase):
    """
    LethalityDistance calculation response class.

    Attributes
    ----------
	toxic_records : list[ToxicRecord] 
		Array of toxic results.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, toxic_records: list[ToxicRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the LethalityDistanceCalculationResponse class"""
        super().__init__()

        self.toxic_records = toxic_records if toxic_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Lethality distance calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'toxic_records' in data and data['toxic_records'] is not None:
            self.toxic_records = [record.initialise_from_dictionary(record) for record in data['toxic_records']]
        else:
            self.toxic_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _RadiationAtPointsForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtPointsForPoolFires calculation request class.
    
    Attributes
    ----------
	pool_fire_flame_result : PoolFireFlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings for radiation coordinates.
	flammable_output_config_count : int 
		Number of radiation coordinates.
    """
    
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _RadiationAtPointsForPoolFiresCalculationRequest class"""
        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count


class RadiationAtPointsForPoolFiresCalculation(_CalculationBase):
    """
    RadiationAtPointsForPoolFires calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	pool_fire_flame_result : PoolFireFlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings for radiation coordinates.
	flammable_output_config_count : int 
		Number of radiation coordinates.

    Calculation outputs:
    
	radiation : list[float] 
		Array of radiation at a point.
	result_code : ResultCode 
		Response code.

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the RadiationAtPointsForPoolFiresCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.radiation = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Radiation at points for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        RadiationAtPointsForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtPointsForPoolFiresCalculationRequest object.
        radiation_at_points_for_pool_fires_calculation_request = _RadiationAtPointsForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the appropriate schema and use that to serialize to json.
        radiation_at_points_for_pool_fires_calculation_request_schema = _RadiationAtPointsForPoolFiresCalculationRequestSchema()

        request_json = radiation_at_points_for_pool_fires_calculation_request_schema.dumps(radiation_at_points_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatpointsforpoolfires?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            radiation_at_points_for_pool_fires_calculation_response_schema = _RadiationAtPointsForPoolFiresCalculationResponseSchema()
            radiation_at_points_for_pool_fires_calculation_response = radiation_at_points_for_pool_fires_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(radiation_at_points_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_points_for_pool_fires_calculation_response.radiation
                self.result_code = radiation_at_points_for_pool_fires_calculation_response.result_code
                self.messages = radiation_at_points_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_points_for_pool_fires_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(radiation_at_points_for_pool_fires_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtPointsForPoolFires calculation object"""

        parts = ['* RadiationAtPointsForPoolFires']

        parts.append(f'*** radiation')
        parts.extend(['radiation_element' for radiation_element in self.radiation] if self.radiation else [f'radiation does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _RadiationAtPointsForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    RadiationAtPointsForPoolFires calculation response class.

    Attributes
    ----------
	radiation : list[float] 
		Array of radiation at a point.
	result_code : ResultCode 
		Response code.
    """

    def __init__(self, radiation: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the RadiationAtPointsForPoolFiresCalculationResponse class"""
        super().__init__()

        self.radiation = radiation if radiation is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Radiation at points for pool fires calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselReliefValveLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselReliefValveLinkedRun calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	relief_valve : ReliefValve 
		Relief valve.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
    """
    
    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselReliefValveLinkedRunCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count


class VesselReliefValveLinkedRunCalculation(_CalculationBase):
    """
    VesselReliefValveLinkedRun calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel definition.
	relief_valve : ReliefValve 
		Relief valve.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.

    Calculation outputs:
    
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_contour_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_contour_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion overpressure results.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselReliefValveLinkedRunCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.njet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.nflam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.npool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.ntoxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel relief valve linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselReliefValveLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselReliefValveLinkedRunCalculationRequest object.
        vessel_relief_valve_linked_run_calculation_request = _VesselReliefValveLinkedRunCalculationRequest(self.vessel, self.relief_valve, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the appropriate schema and use that to serialize to json.
        vessel_relief_valve_linked_run_calculation_request_schema = _VesselReliefValveLinkedRunCalculationRequestSchema()

        request_json = vessel_relief_valve_linked_run_calculation_request_schema.dumps(vessel_relief_valve_linked_run_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselreliefvalvelinkedrun?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_relief_valve_linked_run_calculation_response_schema = _VesselReliefValveLinkedRunCalculationResponseSchema()
            vessel_relief_valve_linked_run_calculation_response = vessel_relief_valve_linked_run_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_relief_valve_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_relief_valve_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_relief_valve_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_relief_valve_linked_run_calculation_response.jet_contour_points
                self.njet_contour_points = vessel_relief_valve_linked_run_calculation_response.njet_contour_points
                self.area_contour_jet = vessel_relief_valve_linked_run_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = vessel_relief_valve_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = vessel_relief_valve_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.flam_conc_contour_points
                self.nflam_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.nflam_conc_contour_points
                self.area_footprint_flam_conc = vessel_relief_valve_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = vessel_relief_valve_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_relief_valve_linked_run_calculation_response.pool_contour_points
                self.npool_contour_points = vessel_relief_valve_linked_run_calculation_response.npool_contour_points
                self.area_contour_pool = vessel_relief_valve_linked_run_calculation_response.area_contour_pool
                self.explosion_overpressure_results = vessel_relief_valve_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = vessel_relief_valve_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = vessel_relief_valve_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.toxic_conc_contour_points
                self.ntoxic_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.ntoxic_conc_contour_points
                self.area_footprint_toxic_conc = vessel_relief_valve_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = vessel_relief_valve_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_relief_valve_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_relief_valve_linked_run_calculation_response.result_code
                self.messages = vessel_relief_valve_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_relief_valve_linked_run_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_relief_valve_linked_run_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselReliefValveLinkedRun calculation object"""

        parts = ['* VesselReliefValveLinkedRun']

        parts.append(f'discharge_record: {str(self.discharge_record)}')
        parts.append(f'*** distances_to_jet_fire_radiation')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.append(f'*** jet_contour_points')
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.append(f'*** njet_contour_points')
        parts.extend(['njet_contour_points_element' for njet_contour_points_element in self.njet_contour_points] if self.njet_contour_points else [f'njet_contour_points does not contain any elements'])
        parts.append(f'*** area_contour_jet')
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.append(f'*** distances_to_flam_concentration')
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.append(f'*** flam_concentrations_used')
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.append(f'*** flam_conc_contour_points')
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.append(f'*** nflam_conc_contour_points')
        parts.extend(['nflam_conc_contour_points_element' for nflam_conc_contour_points_element in self.nflam_conc_contour_points] if self.nflam_conc_contour_points else [f'nflam_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_flam_conc')
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.append(f'*** distances_to_pool_fire_radiation')
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.append(f'*** pool_contour_points')
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.append(f'*** npool_contour_points')
        parts.extend(['npool_contour_points_element' for npool_contour_points_element in self.npool_contour_points] if self.npool_contour_points else [f'npool_contour_points does not contain any elements'])
        parts.append(f'*** area_contour_pool')
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.append(f'*** explosion_overpressure_results')
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.append(f'*** distances_to_toxic_concentration')
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.append(f'*** toxic_concentration_used')
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.append(f'*** toxic_conc_contour_points')
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** ntoxic_conc_contour_points')
        parts.extend(['ntoxic_conc_contour_points_element' for ntoxic_conc_contour_points_element in self.ntoxic_conc_contour_points] if self.ntoxic_conc_contour_points else [f'ntoxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_toxic_conc')
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append(f'jet_fire_flame_result: {str(self.jet_fire_flame_result)}')
        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselReliefValveLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    VesselReliefValveLinkedRun calculation response class.

    Attributes
    ----------
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_contour_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_contour_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion overpressure results.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], njet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], nflam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], npool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], ntoxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselReliefValveLinkedRunCalculationResponse class"""
        super().__init__()

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation if distances_to_jet_fire_radiation is not None else []
        self.jet_contour_points = jet_contour_points if jet_contour_points is not None else []
        self.njet_contour_points = njet_contour_points if njet_contour_points is not None else []
        self.area_contour_jet = area_contour_jet if area_contour_jet is not None else []
        self.distances_to_flam_concentration = distances_to_flam_concentration if distances_to_flam_concentration is not None else []
        self.flam_concentrations_used = flam_concentrations_used if flam_concentrations_used is not None else []
        self.flam_conc_contour_points = flam_conc_contour_points if flam_conc_contour_points is not None else []
        self.nflam_conc_contour_points = nflam_conc_contour_points if nflam_conc_contour_points is not None else []
        self.area_footprint_flam_conc = area_footprint_flam_conc if area_footprint_flam_conc is not None else []
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation if distances_to_pool_fire_radiation is not None else []
        self.pool_contour_points = pool_contour_points if pool_contour_points is not None else []
        self.npool_contour_points = npool_contour_points if npool_contour_points is not None else []
        self.area_contour_pool = area_contour_pool if area_contour_pool is not None else []
        self.explosion_overpressure_results = explosion_overpressure_results if explosion_overpressure_results is not None else []
        self.distances_to_toxic_concentration = distances_to_toxic_concentration if distances_to_toxic_concentration is not None else []
        self.toxic_concentration_used = toxic_concentration_used if toxic_concentration_used is not None else []
        self.toxic_conc_contour_points = toxic_conc_contour_points if toxic_conc_contour_points is not None else []
        self.ntoxic_conc_contour_points = ntoxic_conc_contour_points if ntoxic_conc_contour_points is not None else []
        self.area_footprint_toxic_conc = area_footprint_toxic_conc if area_footprint_toxic_conc is not None else []
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel relief valve linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'discharge_record' in data and data['discharge_record'] is not None:
            self.discharge_record.initialise_from_dictionary(data['discharge_record'])
        
        if 'jet_contour_points' in data and data['jet_contour_points'] is not None:
            self.jet_contour_points = [record.initialise_from_dictionary(record) for record in data['jet_contour_points']]
        else:
            self.jet_contour_points = []
        
        if 'flam_conc_contour_points' in data and data['flam_conc_contour_points'] is not None:
            self.flam_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['flam_conc_contour_points']]
        else:
            self.flam_conc_contour_points = []
        
        if 'pool_contour_points' in data and data['pool_contour_points'] is not None:
            self.pool_contour_points = [record.initialise_from_dictionary(record) for record in data['pool_contour_points']]
        else:
            self.pool_contour_points = []
        
        if 'explosion_overpressure_results' in data and data['explosion_overpressure_results'] is not None:
            self.explosion_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_overpressure_results']]
        else:
            self.explosion_overpressure_results = []
        
        if 'toxic_conc_contour_points' in data and data['toxic_conc_contour_points'] is not None:
            self.toxic_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['toxic_conc_contour_points']]
        else:
            self.toxic_conc_contour_points = []
        
        if 'jet_fire_flame_result' in data and data['jet_fire_flame_result'] is not None:
            self.jet_fire_flame_result.initialise_from_dictionary(data['jet_fire_flame_result'])
        
        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _DispersionCalculationRequest(_CalculationRequestBase):
    """
    _Dispersion calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material with post-discharge composition.
	substrate : Substrate 
		The dispersing surface.
	discharge_result : DischargeResult 
		Discharge / source term definition.
	discharge_records : list[DischargeRecord] 
		Discharge / source term definition.
	discharge_record_count : int 
		Number of discharge records.
	weather : Weather 
		Weather.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
    """
    
    def __init__(self, material: Material, substrate: Substrate, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, weather: Weather, dispersion_parameters: DispersionParameters, end_point_concentration: float):
        """Initializes a new instance of the _DispersionCalculationRequest class"""
        super().__init__()

        self.material = material
        self.substrate = substrate
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.end_point_concentration = end_point_concentration


class DispersionCalculation(_CalculationBase):
    """
    Dispersion calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material with post-discharge composition.
	substrate : Substrate 
		The dispersing surface.
	discharge_result : DischargeResult 
		Discharge / source term definition.
	discharge_records : list[DischargeRecord] 
		Discharge / source term definition.
	discharge_record_count : int 
		Number of discharge records.
	weather : Weather 
		Weather.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).

    Calculation outputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	dispersion_records : list[DispersionRecord] 
		Array of Dispersion records.
	pool_records : list[PoolRecord] 
		Array of Pool records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, substrate: Substrate, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, weather: Weather, dispersion_parameters: DispersionParameters, end_point_concentration: float):
        """Initializes a new instance of the DispersionCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.substrate = substrate
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.end_point_concentration = end_point_concentration

        # Calculation outputs.
        self.scalar_udm_outputs = None
        self.dispersion_records = None
        self.pool_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Dispersion calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        DispersionCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DispersionCalculationRequest object.
        dispersion_calculation_request = _DispersionCalculationRequest(self.material, self.substrate, self.discharge_result, self.discharge_records, self.discharge_record_count, self.weather, self.dispersion_parameters, self.end_point_concentration)

        # Get the appropriate schema and use that to serialize to json.
        dispersion_calculation_request_schema = _DispersionCalculationRequestSchema()

        request_json = dispersion_calculation_request_schema.dumps(dispersion_calculation_request)
        url = get_analytics_api_target() + 'calculatedispersion?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            dispersion_calculation_response_schema = _DispersionCalculationResponseSchema()
            dispersion_calculation_response = dispersion_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(dispersion_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.scalar_udm_outputs = dispersion_calculation_response.scalar_udm_outputs
                self.dispersion_records = dispersion_calculation_response.dispersion_records
                self.pool_records = dispersion_calculation_response.pool_records
                self.result_code = dispersion_calculation_response.result_code
                self.messages = dispersion_calculation_response.messages
                self.calculation_elapsed_time = dispersion_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(dispersion_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the Dispersion calculation object"""

        parts = ['* Dispersion']

        parts.append(f'scalar_udm_outputs: {str(self.scalar_udm_outputs)}')
        parts.append(f'*** dispersion_records')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'*** pool_records')
        parts.extend(['pool_records_element' for pool_records_element in self.pool_records] if self.pool_records else [f'pool_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _DispersionCalculationResponse(_CalculationResponseBase):
    """
    Dispersion calculation response class.

    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	dispersion_records : list[DispersionRecord] 
		Array of Dispersion records.
	pool_records : list[PoolRecord] 
		Array of Pool records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, dispersion_records: list[DispersionRecord], pool_records: list[PoolRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the DispersionCalculationResponse class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.dispersion_records = dispersion_records if dispersion_records is not None else []
        self.pool_records = pool_records if pool_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Dispersion calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'scalar_udm_outputs' in data and data['scalar_udm_outputs'] is not None:
            self.scalar_udm_outputs.initialise_from_dictionary(data['scalar_udm_outputs'])
        
        if 'dispersion_records' in data and data['dispersion_records'] is not None:
            self.dispersion_records = [record.initialise_from_dictionary(record) for record in data['dispersion_records']]
        else:
            self.dispersion_records = []
        
        if 'pool_records' in data and data['pool_records'] is not None:
            self.pool_records = [record.initialise_from_dictionary(record) for record in data['pool_records']]
        else:
            self.pool_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetPhaseToReleaseForLineRuptureScenario calculation request class.
    
    Attributes
    ----------
	phase_to_release : Phase 
		Requested fluid phase to release.
	release_elevation : float 
		Release point elevation above ground.
	vessel : Vessel 
		Vessel definition input.
    """
    
    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest class"""
        super().__init__()

        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel


class SetPhaseToReleaseForLineRuptureScenarioCalculation(_CalculationBase):
    """
    SetPhaseToReleaseForLineRuptureScenario calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	phase_to_release : Phase 
		Requested fluid phase to release.
	release_elevation : float 
		Release point elevation above ground.
	vessel : Vessel 
		Vessel definition input.

    Calculation outputs:
    
	zcoord_updated : float 
		Updated z-coordinate of vessel to accommodate requested phase to release.
	pipe_height_fraction_updated : float 
		Updated pipe height fraction to accommodate requested phase to release.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the SetPhaseToReleaseForLineRuptureScenarioCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

        # Calculation outputs.
        self.zcoord_updated = None
        self.pipe_height_fraction_updated = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Set phase to release for line rupture scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        SetPhaseToReleaseForLineRuptureScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest object.
        set_phase_to_release_for_line_rupture_scenario_calculation_request = _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest(self.phase_to_release, self.release_elevation, self.vessel)

        # Get the appropriate schema and use that to serialize to json.
        set_phase_to_release_for_line_rupture_scenario_calculation_request_schema = _SetPhaseToReleaseForLineRuptureScenarioCalculationRequestSchema()

        request_json = set_phase_to_release_for_line_rupture_scenario_calculation_request_schema.dumps(set_phase_to_release_for_line_rupture_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/setphasetoreleaseforlinerupturescenario?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            set_phase_to_release_for_line_rupture_scenario_calculation_response_schema = _SetPhaseToReleaseForLineRuptureScenarioCalculationResponseSchema()
            set_phase_to_release_for_line_rupture_scenario_calculation_response = set_phase_to_release_for_line_rupture_scenario_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(set_phase_to_release_for_line_rupture_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.zcoord_updated = set_phase_to_release_for_line_rupture_scenario_calculation_response.zcoord_updated
                self.pipe_height_fraction_updated = set_phase_to_release_for_line_rupture_scenario_calculation_response.pipe_height_fraction_updated
                self.result_code = set_phase_to_release_for_line_rupture_scenario_calculation_response.result_code
                self.messages = set_phase_to_release_for_line_rupture_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_phase_to_release_for_line_rupture_scenario_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(set_phase_to_release_for_line_rupture_scenario_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the SetPhaseToReleaseForLineRuptureScenario calculation object"""

        parts = ['* SetPhaseToReleaseForLineRuptureScenario']

        parts.append(f'ZCoordUpdated : {self.zcoord_updated}')
        parts.append(f'PipeHeightFractionUpdated : {self.pipe_height_fraction_updated}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _SetPhaseToReleaseForLineRuptureScenarioCalculationResponse(_CalculationResponseBase):
    """
    SetPhaseToReleaseForLineRuptureScenario calculation response class.

    Attributes
    ----------
	zcoord_updated : float 
		Updated z-coordinate of vessel to accommodate requested phase to release.
	pipe_height_fraction_updated : float 
		Updated pipe height fraction to accommodate requested phase to release.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, zcoord_updated: float, pipe_height_fraction_updated: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the SetPhaseToReleaseForLineRuptureScenarioCalculationResponse class"""
        super().__init__()

        self.zcoord_updated = zcoord_updated
        self.pipe_height_fraction_updated = pipe_height_fraction_updated
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Set phase to release for line rupture scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'zcoord_updated' in data and data['zcoord_updated'] is not None:
            self.zcoord_updated
        
        if 'pipe_height_fraction_updated' in data and data['pipe_height_fraction_updated'] is not None:
            self.pipe_height_fraction_updated
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _SetReleaseElevationForScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetReleaseElevationForScenario calculation request class.
    
    Attributes
    ----------
	release_elevation : float 
		Release point elevation above ground.
	release_height_fraction : float 
		Release height fraction off the total vessel height.
	vessel : Vessel 
		Vessel definition input.
    """
    
    def __init__(self, release_elevation: float, release_height_fraction: float, vessel: Vessel):
        """Initializes a new instance of the _SetReleaseElevationForScenarioCalculationRequest class"""
        super().__init__()

        self.release_elevation = release_elevation
        self.release_height_fraction = release_height_fraction
        self.vessel = vessel


class SetReleaseElevationForScenarioCalculation(_CalculationBase):
    """
    SetReleaseElevationForScenario calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	release_elevation : float 
		Release point elevation above ground.
	release_height_fraction : float 
		Release height fraction off the total vessel height.
	vessel : Vessel 
		Vessel definition input.

    Calculation outputs:
    
	updated_vessel : Vessel 
		Updated vessel definition output with modified z coordinate.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, release_elevation: float, release_height_fraction: float, vessel: Vessel):
        """Initializes a new instance of the SetReleaseElevationForScenarioCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.release_elevation = release_elevation
        self.release_height_fraction = release_height_fraction
        self.vessel = vessel

        # Calculation outputs.
        self.updated_vessel = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Set release elevation for scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        SetReleaseElevationForScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetReleaseElevationForScenarioCalculationRequest object.
        set_release_elevation_for_scenario_calculation_request = _SetReleaseElevationForScenarioCalculationRequest(self.release_elevation, self.release_height_fraction, self.vessel)

        # Get the appropriate schema and use that to serialize to json.
        set_release_elevation_for_scenario_calculation_request_schema = _SetReleaseElevationForScenarioCalculationRequestSchema()

        request_json = set_release_elevation_for_scenario_calculation_request_schema.dumps(set_release_elevation_for_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/setreleaseelevationforscenario?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            set_release_elevation_for_scenario_calculation_response_schema = _SetReleaseElevationForScenarioCalculationResponseSchema()
            set_release_elevation_for_scenario_calculation_response = set_release_elevation_for_scenario_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(set_release_elevation_for_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.updated_vessel = set_release_elevation_for_scenario_calculation_response.updated_vessel
                self.result_code = set_release_elevation_for_scenario_calculation_response.result_code
                self.messages = set_release_elevation_for_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_release_elevation_for_scenario_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(set_release_elevation_for_scenario_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the SetReleaseElevationForScenario calculation object"""

        parts = ['* SetReleaseElevationForScenario']

        parts.append(f'updated_vessel: {str(self.updated_vessel)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _SetReleaseElevationForScenarioCalculationResponse(_CalculationResponseBase):
    """
    SetReleaseElevationForScenario calculation response class.

    Attributes
    ----------
	updated_vessel : Vessel 
		Updated vessel definition output with modified z coordinate.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, updated_vessel: Vessel, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the SetReleaseElevationForScenarioCalculationResponse class"""
        super().__init__()

        self.updated_vessel = updated_vessel
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Set release elevation for scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'updated_vessel' in data and data['updated_vessel'] is not None:
            self.updated_vessel.initialise_from_dictionary(data['updated_vessel'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselReliefValveCalculationRequest(_CalculationRequestBase):
    """
    _VesselReliefValve calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	relief_valve : ReliefValve 
		Relief valve scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
    """
    
    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselReliefValveCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters


class VesselReliefValveCalculation(_CalculationBase):
    """
    VesselReliefValve calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	relief_valve : ReliefValve 
		Relief valve scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.

    Calculation outputs:
    
	exit_material : Material 
		Composition of the released material (may differ from storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselReliefValveCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel relief valve calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselReliefValveCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselReliefValveCalculationRequest object.
        vessel_relief_valve_calculation_request = _VesselReliefValveCalculationRequest(self.vessel, self.relief_valve, self.discharge_parameters)

        # Get the appropriate schema and use that to serialize to json.
        vessel_relief_valve_calculation_request_schema = _VesselReliefValveCalculationRequestSchema()

        request_json = vessel_relief_valve_calculation_request_schema.dumps(vessel_relief_valve_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselreliefvalve?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_relief_valve_calculation_response_schema = _VesselReliefValveCalculationResponseSchema()
            vessel_relief_valve_calculation_response = vessel_relief_valve_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_relief_valve_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_relief_valve_calculation_response.exit_material
                self.discharge_result = vessel_relief_valve_calculation_response.discharge_result
                self.discharge_records = vessel_relief_valve_calculation_response.discharge_records
                self.result_code = vessel_relief_valve_calculation_response.result_code
                self.messages = vessel_relief_valve_calculation_response.messages
                self.calculation_elapsed_time = vessel_relief_valve_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_relief_valve_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselReliefValve calculation object"""

        parts = ['* VesselReliefValve']

        parts.append(f'exit_material: {str(self.exit_material)}')
        parts.append(f'discharge_result: {str(self.discharge_result)}')
        parts.append(f'*** discharge_records')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselReliefValveCalculationResponse(_CalculationResponseBase):
    """
    VesselReliefValve calculation response class.

    Attributes
    ----------
	exit_material : Material 
		Composition of the released material (may differ from storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselReliefValveCalculationResponse class"""
        super().__init__()

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records if discharge_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel relief valve calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'exit_material' in data and data['exit_material'] is not None:
            self.exit_material.initialise_from_dictionary(data['exit_material'])
        
        if 'discharge_result' in data and data['discharge_result'] is not None:
            self.discharge_result.initialise_from_dictionary(data['discharge_result'])
        
        if 'discharge_records' in data and data['discharge_records'] is not None:
            self.discharge_records = [record.initialise_from_dictionary(record) for record in data['discharge_records']]
        else:
            self.discharge_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _ConcentrationAtPointCalculationRequest(_CalculationRequestBase):
    """
    _ConcentrationAtPoint calculation request class.
    
    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _ConcentrationAtPointCalculationRequest class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters


class ConcentrationAtPointCalculation(_CalculationBase):
    """
    ConcentrationAtPoint calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	concentration : float 
		Concentration at a position of interest.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the ConcentrationAtPointCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.concentration = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Concentration at point calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        ConcentrationAtPointCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ConcentrationAtPointCalculationRequest object.
        concentration_at_point_calculation_request = _ConcentrationAtPointCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        concentration_at_point_calculation_request_schema = _ConcentrationAtPointCalculationRequestSchema()

        request_json = concentration_at_point_calculation_request_schema.dumps(concentration_at_point_calculation_request)
        url = get_analytics_api_target() + 'calculateconcentrationatpoint?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            concentration_at_point_calculation_response_schema = _ConcentrationAtPointCalculationResponseSchema()
            concentration_at_point_calculation_response = concentration_at_point_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(concentration_at_point_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.concentration = concentration_at_point_calculation_response.concentration
                self.result_code = concentration_at_point_calculation_response.result_code
                self.messages = concentration_at_point_calculation_response.messages
                self.calculation_elapsed_time = concentration_at_point_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(concentration_at_point_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the ConcentrationAtPoint calculation object"""

        parts = ['* ConcentrationAtPoint']

        parts.append(f'Concentration : {self.concentration}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _ConcentrationAtPointCalculationResponse(_CalculationResponseBase):
    """
    ConcentrationAtPoint calculation response class.

    Attributes
    ----------
	concentration : float 
		Concentration at a position of interest.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, concentration: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the ConcentrationAtPointCalculationResponse class"""
        super().__init__()

        self.concentration = concentration
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Concentration at point calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'concentration' in data and data['concentration'] is not None:
            self.concentration
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselStateCalculationRequest(_CalculationRequestBase):
    """
    _VesselState calculation request class.
    
    Attributes
    ----------
	material : Material 
		User-defined input material, pure component or mixture (max 20 components).
	material_state : State 
		Describes the fluid pressure, temperature, liquid fraction.
    """
    
    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the _VesselStateCalculationRequest class"""
        super().__init__()

        self.material = material
        self.material_state = material_state


class VesselStateCalculation(_CalculationBase):
    """
    VesselState calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		User-defined input material, pure component or mixture (max 20 components).
	material_state : State 
		Describes the fluid pressure, temperature, liquid fraction.

    Calculation outputs:
    
	vessel_conditions : VesselConditions 
		Describes the vessel storage conditions (Pure gas, Stratified Two-Phase or Pressurised liquid).
	output_state : State 
		Describes the fluid pressure, temperature and liquid fraction after the flash calculation.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the VesselStateCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.material_state = material_state

        # Calculation outputs.
        self.vessel_conditions = None
        self.output_state = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel state calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselStateCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselStateCalculationRequest object.
        vessel_state_calculation_request = _VesselStateCalculationRequest(self.material, self.material_state)

        # Get the appropriate schema and use that to serialize to json.
        vessel_state_calculation_request_schema = _VesselStateCalculationRequestSchema()

        request_json = vessel_state_calculation_request_schema.dumps(vessel_state_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselstate?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_state_calculation_response_schema = _VesselStateCalculationResponseSchema()
            vessel_state_calculation_response = vessel_state_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_state_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel_conditions = vessel_state_calculation_response.vessel_conditions
                self.output_state = vessel_state_calculation_response.output_state
                self.result_code = vessel_state_calculation_response.result_code
                self.messages = vessel_state_calculation_response.messages
                self.calculation_elapsed_time = vessel_state_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_state_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselState calculation object"""

        parts = ['* VesselState']

        parts.append(f'vessel_conditions:	{"(None)" if self.vessel_conditions is None else self.vessel_conditions.name}')
        parts.append(f'output_state: {str(self.output_state)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselStateCalculationResponse(_CalculationResponseBase):
    """
    VesselState calculation response class.

    Attributes
    ----------
	vessel_conditions : VesselConditions 
		Describes the vessel storage conditions (Pure gas, Stratified Two-Phase or Pressurised liquid).
	output_state : State 
		Describes the fluid pressure, temperature and liquid fraction after the flash calculation.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, vessel_conditions: VesselConditions, output_state: State, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselStateCalculationResponse class"""
        super().__init__()

        self.vessel_conditions = vessel_conditions
        self.output_state = output_state
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel state calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'vessel_conditions' in data and data['vessel_conditions'] is not None:
            self.vessel_conditions = VesselConditions(data['vessel_conditions'])
        
        if 'output_state' in data and data['output_state'] is not None:
            self.output_state.initialise_from_dictionary(data['output_state'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _DistanceToRadiationCalculationRequest(_CalculationRequestBase):
    """
    _DistanceToRadiation calculation request class.
    
    Attributes
    ----------
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.
    """
    
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _DistanceToRadiationCalculationRequest class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config


class DistanceToRadiationCalculation(_CalculationBase):
    """
    DistanceToRadiation calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.

    Calculation outputs:
    
	distance : float 
		Distance to radiation level.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the DistanceToRadiationCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.distance = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Distance to radiation calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        DistanceToRadiationCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistanceToRadiationCalculationRequest object.
        distance_to_radiation_calculation_request = _DistanceToRadiationCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the appropriate schema and use that to serialize to json.
        distance_to_radiation_calculation_request_schema = _DistanceToRadiationCalculationRequestSchema()

        request_json = distance_to_radiation_calculation_request_schema.dumps(distance_to_radiation_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancetoradiation?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            distance_to_radiation_calculation_response_schema = _DistanceToRadiationCalculationResponseSchema()
            distance_to_radiation_calculation_response = distance_to_radiation_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(distance_to_radiation_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distance = distance_to_radiation_calculation_response.distance
                self.result_code = distance_to_radiation_calculation_response.result_code
                self.messages = distance_to_radiation_calculation_response.messages
                self.calculation_elapsed_time = distance_to_radiation_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(distance_to_radiation_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the DistanceToRadiation calculation object"""

        parts = ['* DistanceToRadiation']

        parts.append(f'Distance : {self.distance}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _DistanceToRadiationCalculationResponse(_CalculationResponseBase):
    """
    DistanceToRadiation calculation response class.

    Attributes
    ----------
	distance : float 
		Distance to radiation level.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, distance: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the DistanceToRadiationCalculationResponse class"""
        super().__init__()

        self.distance = distance
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Distance to radiation calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'distance' in data and data['distance'] is not None:
            self.distance
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _ConvertCompositionMassToMoleCalculationRequest(_CalculationRequestBase):
    """
    _ConvertCompositionMassToMole calculation request class.
    
    Attributes
    ----------
	mixture : Material 
		Mixture to have composition converted.
	composition_mass : list[float] 
		Input composition of mixture in mass basis.
	composition_mass_count : int 
		Number of components in mixture.
    """
    
    def __init__(self, mixture: Material, composition_mass: list[float], composition_mass_count: int):
        """Initializes a new instance of the _ConvertCompositionMassToMoleCalculationRequest class"""
        super().__init__()

        self.mixture = mixture
        self.composition_mass = composition_mass
        self.composition_mass_count = composition_mass_count


class ConvertCompositionMassToMoleCalculation(_CalculationBase):
    """
    ConvertCompositionMassToMole calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	mixture : Material 
		Mixture to have composition converted.
	composition_mass : list[float] 
		Input composition of mixture in mass basis.
	composition_mass_count : int 
		Number of components in mixture.

    Calculation outputs:
    
	composition_mole : list[float] 
		Output composition of mixture in mole basis.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, mixture: Material, composition_mass: list[float], composition_mass_count: int):
        """Initializes a new instance of the ConvertCompositionMassToMoleCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.mixture = mixture
        self.composition_mass = composition_mass
        self.composition_mass_count = composition_mass_count

        # Calculation outputs.
        self.composition_mole = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Convert composition mass to mole calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        ConvertCompositionMassToMoleCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ConvertCompositionMassToMoleCalculationRequest object.
        convert_composition_mass_to_mole_calculation_request = _ConvertCompositionMassToMoleCalculationRequest(self.mixture, self.composition_mass, self.composition_mass_count)

        # Get the appropriate schema and use that to serialize to json.
        convert_composition_mass_to_mole_calculation_request_schema = _ConvertCompositionMassToMoleCalculationRequestSchema()

        request_json = convert_composition_mass_to_mole_calculation_request_schema.dumps(convert_composition_mass_to_mole_calculation_request)
        url = get_analytics_api_target() + 'utilities/convertcompositionmasstomole?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            convert_composition_mass_to_mole_calculation_response_schema = _ConvertCompositionMassToMoleCalculationResponseSchema()
            convert_composition_mass_to_mole_calculation_response = convert_composition_mass_to_mole_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(convert_composition_mass_to_mole_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.composition_mole = convert_composition_mass_to_mole_calculation_response.composition_mole
                self.result_code = convert_composition_mass_to_mole_calculation_response.result_code
                self.messages = convert_composition_mass_to_mole_calculation_response.messages
                self.calculation_elapsed_time = convert_composition_mass_to_mole_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(convert_composition_mass_to_mole_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the ConvertCompositionMassToMole calculation object"""

        parts = ['* ConvertCompositionMassToMole']

        parts.append(f'*** composition_mole')
        parts.extend(['composition_mole_element' for composition_mole_element in self.composition_mole] if self.composition_mole else [f'composition_mole does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _ConvertCompositionMassToMoleCalculationResponse(_CalculationResponseBase):
    """
    ConvertCompositionMassToMole calculation response class.

    Attributes
    ----------
	composition_mole : list[float] 
		Output composition of mixture in mole basis.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, composition_mole: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the ConvertCompositionMassToMoleCalculationResponse class"""
        super().__init__()

        self.composition_mole = composition_mole if composition_mole is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Convert composition mass to mole calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _LongPipeBreachCalculationRequest(_CalculationRequestBase):
    """
    _LongPipeBreach calculation request class.
    
    Attributes
    ----------
	pipe : Pipe 
		Pipe equipment item.
	pipe_breach : PipeBreach 
		Long pipeline scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
    """
    
    def __init__(self, pipe: Pipe, pipe_breach: PipeBreach, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _LongPipeBreachCalculationRequest class"""
        super().__init__()

        self.pipe = pipe
        self.pipe_breach = pipe_breach
        self.discharge_parameters = discharge_parameters


class LongPipeBreachCalculation(_CalculationBase):
    """
    LongPipeBreach calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	pipe : Pipe 
		Pipe equipment item.
	pipe_breach : PipeBreach 
		Long pipeline scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.

    Calculation outputs:
    
	exit_material : Material 
		Composition of the released material (indentical to storage composition - using PC mode).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pipe: Pipe, pipe_breach: PipeBreach, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the LongPipeBreachCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.pipe = pipe
        self.pipe_breach = pipe_breach
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Long pipe breach calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        LongPipeBreachCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LongPipeBreachCalculationRequest object.
        long_pipe_breach_calculation_request = _LongPipeBreachCalculationRequest(self.pipe, self.pipe_breach, self.discharge_parameters)

        # Get the appropriate schema and use that to serialize to json.
        long_pipe_breach_calculation_request_schema = _LongPipeBreachCalculationRequestSchema()

        request_json = long_pipe_breach_calculation_request_schema.dumps(long_pipe_breach_calculation_request)
        url = get_analytics_api_target() + 'calculatelongpipebreach?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            long_pipe_breach_calculation_response_schema = _LongPipeBreachCalculationResponseSchema()
            long_pipe_breach_calculation_response = long_pipe_breach_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(long_pipe_breach_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = long_pipe_breach_calculation_response.exit_material
                self.discharge_result = long_pipe_breach_calculation_response.discharge_result
                self.discharge_records = long_pipe_breach_calculation_response.discharge_records
                self.result_code = long_pipe_breach_calculation_response.result_code
                self.messages = long_pipe_breach_calculation_response.messages
                self.calculation_elapsed_time = long_pipe_breach_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(long_pipe_breach_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the LongPipeBreach calculation object"""

        parts = ['* LongPipeBreach']

        parts.append(f'exit_material: {str(self.exit_material)}')
        parts.append(f'discharge_result: {str(self.discharge_result)}')
        parts.append(f'*** discharge_records')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _LongPipeBreachCalculationResponse(_CalculationResponseBase):
    """
    LongPipeBreach calculation response class.

    Attributes
    ----------
	exit_material : Material 
		Composition of the released material (indentical to storage composition - using PC mode).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the LongPipeBreachCalculationResponse class"""
        super().__init__()

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records if discharge_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Long pipe breach calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'exit_material' in data and data['exit_material'] is not None:
            self.exit_material.initialise_from_dictionary(data['exit_material'])
        
        if 'discharge_result' in data and data['discharge_result'] is not None:
            self.discharge_result.initialise_from_dictionary(data['discharge_result'])
        
        if 'discharge_records' in data and data['discharge_records'] is not None:
            self.discharge_records = [record.initialise_from_dictionary(record) for record in data['discharge_records']]
        else:
            self.discharge_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _RadiationAtPointsCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtPoints calculation request class.
    
    Attributes
    ----------
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings for radiation coordinates.
	flammable_output_config_count : int 
		Number of radiation coordinates.
    """
    
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _RadiationAtPointsCalculationRequest class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count


class RadiationAtPointsCalculation(_CalculationBase):
    """
    RadiationAtPoints calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings for radiation coordinates.
	flammable_output_config_count : int 
		Number of radiation coordinates.

    Calculation outputs:
    
	radiation : list[float] 
		Array of radiation at a point.
	result_code : ResultCode 
		Response code.

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the RadiationAtPointsCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.radiation = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Radiation at points calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        RadiationAtPointsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtPointsCalculationRequest object.
        radiation_at_points_calculation_request = _RadiationAtPointsCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the appropriate schema and use that to serialize to json.
        radiation_at_points_calculation_request_schema = _RadiationAtPointsCalculationRequestSchema()

        request_json = radiation_at_points_calculation_request_schema.dumps(radiation_at_points_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatpoints?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            radiation_at_points_calculation_response_schema = _RadiationAtPointsCalculationResponseSchema()
            radiation_at_points_calculation_response = radiation_at_points_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(radiation_at_points_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_points_calculation_response.radiation
                self.result_code = radiation_at_points_calculation_response.result_code
                self.messages = radiation_at_points_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_points_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(radiation_at_points_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtPoints calculation object"""

        parts = ['* RadiationAtPoints']

        parts.append(f'*** radiation')
        parts.extend(['radiation_element' for radiation_element in self.radiation] if self.radiation else [f'radiation does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _RadiationAtPointsCalculationResponse(_CalculationResponseBase):
    """
    RadiationAtPoints calculation response class.

    Attributes
    ----------
	radiation : list[float] 
		Array of radiation at a point.
	result_code : ResultCode 
		Response code.
    """

    def __init__(self, radiation: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the RadiationAtPointsCalculationResponse class"""
        super().__init__()

        self.radiation = radiation if radiation is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Radiation at points calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLeakLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakLinkedRun calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
    """
    
    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselLeakLinkedRunCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count


class VesselLeakLinkedRunCalculation(_CalculationBase):
    """
    VesselLeakLinkedRun calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_flam_output_configs : list[DispersionOutputConfig] 
		Flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_flam_output_config_count : int 
		Number of flammable concentration levels (LFL fraction, LFL, UFL).
	dispersion_toxic_output_configs : list[DispersionOutputConfig] 
		Toxic concentration levels (concentration of interest).
	dispersion_toxic_output_config_count : int 
		Number of toxic concentration levels (concentration of interest).
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.

    Calculation outputs:
    
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselLeakLinkedRunCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.njet_contour_points = None
        self.area_ellipse_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.nflam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.npool_contour_points = None
        self.area_ellipse_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.ntoxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel leak linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLeakLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakLinkedRunCalculationRequest object.
        vessel_leak_linked_run_calculation_request = _VesselLeakLinkedRunCalculationRequest(self.vessel, self.leak, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the appropriate schema and use that to serialize to json.
        vessel_leak_linked_run_calculation_request_schema = _VesselLeakLinkedRunCalculationRequestSchema()

        request_json = vessel_leak_linked_run_calculation_request_schema.dumps(vessel_leak_linked_run_calculation_request)
        url = get_analytics_api_target() + 'vesselleaklinkedrun?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_leak_linked_run_calculation_response_schema = _VesselLeakLinkedRunCalculationResponseSchema()
            vessel_leak_linked_run_calculation_response = vessel_leak_linked_run_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_leak_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_leak_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_leak_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_leak_linked_run_calculation_response.jet_contour_points
                self.njet_contour_points = vessel_leak_linked_run_calculation_response.njet_contour_points
                self.area_ellipse_jet = vessel_leak_linked_run_calculation_response.area_ellipse_jet
                self.distances_to_flam_concentration = vessel_leak_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = vessel_leak_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = vessel_leak_linked_run_calculation_response.flam_conc_contour_points
                self.nflam_conc_contour_points = vessel_leak_linked_run_calculation_response.nflam_conc_contour_points
                self.area_footprint_flam_conc = vessel_leak_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = vessel_leak_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_leak_linked_run_calculation_response.pool_contour_points
                self.npool_contour_points = vessel_leak_linked_run_calculation_response.npool_contour_points
                self.area_ellipse_pool = vessel_leak_linked_run_calculation_response.area_ellipse_pool
                self.explosion_overpressure_results = vessel_leak_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = vessel_leak_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = vessel_leak_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = vessel_leak_linked_run_calculation_response.toxic_conc_contour_points
                self.ntoxic_conc_contour_points = vessel_leak_linked_run_calculation_response.ntoxic_conc_contour_points
                self.area_footprint_toxic_conc = vessel_leak_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = vessel_leak_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_leak_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_leak_linked_run_calculation_response.result_code
                self.messages = vessel_leak_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_linked_run_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_leak_linked_run_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakLinkedRun calculation object"""

        parts = ['* VesselLeakLinkedRun']

        parts.append(f'discharge_record: {str(self.discharge_record)}')
        parts.append(f'*** distances_to_jet_fire_radiation')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.append(f'*** jet_contour_points')
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.append(f'*** njet_contour_points')
        parts.extend(['njet_contour_points_element' for njet_contour_points_element in self.njet_contour_points] if self.njet_contour_points else [f'njet_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_jet')
        parts.extend(['area_ellipse_jet_element' for area_ellipse_jet_element in self.area_ellipse_jet] if self.area_ellipse_jet else [f'area_ellipse_jet does not contain any elements'])
        parts.append(f'*** distances_to_flam_concentration')
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.append(f'*** flam_concentrations_used')
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.append(f'*** flam_conc_contour_points')
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.append(f'*** nflam_conc_contour_points')
        parts.extend(['nflam_conc_contour_points_element' for nflam_conc_contour_points_element in self.nflam_conc_contour_points] if self.nflam_conc_contour_points else [f'nflam_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_flam_conc')
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.append(f'*** distances_to_pool_fire_radiation')
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.append(f'*** pool_contour_points')
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.append(f'*** npool_contour_points')
        parts.extend(['npool_contour_points_element' for npool_contour_points_element in self.npool_contour_points] if self.npool_contour_points else [f'npool_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_pool')
        parts.extend(['area_ellipse_pool_element' for area_ellipse_pool_element in self.area_ellipse_pool] if self.area_ellipse_pool else [f'area_ellipse_pool does not contain any elements'])
        parts.append(f'*** explosion_overpressure_results')
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.append(f'*** distances_to_toxic_concentration')
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.append(f'*** toxic_concentration_used')
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.append(f'*** toxic_conc_contour_points')
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** ntoxic_conc_contour_points')
        parts.extend(['ntoxic_conc_contour_points_element' for ntoxic_conc_contour_points_element in self.ntoxic_conc_contour_points] if self.ntoxic_conc_contour_points else [f'ntoxic_conc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_toxic_conc')
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append(f'jet_fire_flame_result: {str(self.jet_fire_flame_result)}')
        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLeakLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    VesselLeakLinkedRun calculation response class.

    Attributes
    ----------
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire contours.
	distances_to_flam_concentration : list[float] 
		Distances to concentration levels (LFL fraction, LFL and UFL).
	flam_concentrations_used : list[float] 
		Concentration levels (LFL fraction, LFL and UFL).
	flam_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels (LFL fraction, LFL and UFL).
	nflam_conc_contour_points : list[int] 
		Number of contour points per concentration level (LFL fraction, LFL and UFL).
	area_footprint_flam_conc : list[float] 
		Areas of maximum concentration footprints (LFL fraction, LFL and UFL).
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	distances_to_toxic_concentration : list[float] 
		Distance to concentration of interest (using toxic averaging time).
	toxic_concentration_used : list[float] 
		Concentration of interest.
	toxic_conc_contour_points : list[LocalPosition] 
		Maximum concentration footprint to concentration of interest (using toxic averaging time).
	ntoxic_conc_contour_points : list[int] 
		Number of contour points for maximum concentration footprint to concentration of interest.
	area_footprint_toxic_conc : list[float] 
		Area of maximum concentration footprints to concentration of interest (using toxic averaging time).
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], njet_contour_points: list[int], area_ellipse_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], nflam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], npool_contour_points: list[int], area_ellipse_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], ntoxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLeakLinkedRunCalculationResponse class"""
        super().__init__()

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation if distances_to_jet_fire_radiation is not None else []
        self.jet_contour_points = jet_contour_points if jet_contour_points is not None else []
        self.njet_contour_points = njet_contour_points if njet_contour_points is not None else []
        self.area_ellipse_jet = area_ellipse_jet if area_ellipse_jet is not None else []
        self.distances_to_flam_concentration = distances_to_flam_concentration if distances_to_flam_concentration is not None else []
        self.flam_concentrations_used = flam_concentrations_used if flam_concentrations_used is not None else []
        self.flam_conc_contour_points = flam_conc_contour_points if flam_conc_contour_points is not None else []
        self.nflam_conc_contour_points = nflam_conc_contour_points if nflam_conc_contour_points is not None else []
        self.area_footprint_flam_conc = area_footprint_flam_conc if area_footprint_flam_conc is not None else []
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation if distances_to_pool_fire_radiation is not None else []
        self.pool_contour_points = pool_contour_points if pool_contour_points is not None else []
        self.npool_contour_points = npool_contour_points if npool_contour_points is not None else []
        self.area_ellipse_pool = area_ellipse_pool if area_ellipse_pool is not None else []
        self.explosion_overpressure_results = explosion_overpressure_results if explosion_overpressure_results is not None else []
        self.distances_to_toxic_concentration = distances_to_toxic_concentration if distances_to_toxic_concentration is not None else []
        self.toxic_concentration_used = toxic_concentration_used if toxic_concentration_used is not None else []
        self.toxic_conc_contour_points = toxic_conc_contour_points if toxic_conc_contour_points is not None else []
        self.ntoxic_conc_contour_points = ntoxic_conc_contour_points if ntoxic_conc_contour_points is not None else []
        self.area_footprint_toxic_conc = area_footprint_toxic_conc if area_footprint_toxic_conc is not None else []
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel leak linked run calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'discharge_record' in data and data['discharge_record'] is not None:
            self.discharge_record.initialise_from_dictionary(data['discharge_record'])
        
        if 'jet_contour_points' in data and data['jet_contour_points'] is not None:
            self.jet_contour_points = [record.initialise_from_dictionary(record) for record in data['jet_contour_points']]
        else:
            self.jet_contour_points = []
        
        if 'flam_conc_contour_points' in data and data['flam_conc_contour_points'] is not None:
            self.flam_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['flam_conc_contour_points']]
        else:
            self.flam_conc_contour_points = []
        
        if 'pool_contour_points' in data and data['pool_contour_points'] is not None:
            self.pool_contour_points = [record.initialise_from_dictionary(record) for record in data['pool_contour_points']]
        else:
            self.pool_contour_points = []
        
        if 'explosion_overpressure_results' in data and data['explosion_overpressure_results'] is not None:
            self.explosion_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_overpressure_results']]
        else:
            self.explosion_overpressure_results = []
        
        if 'toxic_conc_contour_points' in data and data['toxic_conc_contour_points'] is not None:
            self.toxic_conc_contour_points = [record.initialise_from_dictionary(record) for record in data['toxic_conc_contour_points']]
        else:
            self.toxic_conc_contour_points = []
        
        if 'jet_fire_flame_result' in data and data['jet_fire_flame_result'] is not None:
            self.jet_fire_flame_result.initialise_from_dictionary(data['jet_fire_flame_result'])
        
        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _SetPhaseToReleaseForLeakScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetPhaseToReleaseForLeakScenario calculation request class.
    
    Attributes
    ----------
	phase_to_release : Phase 
		Requested fluid phase to release.
	release_elevation : float 
		Release point elevation above ground.
	vessel : Vessel 
		Vessel definition input.
    """
    
    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the _SetPhaseToReleaseForLeakScenarioCalculationRequest class"""
        super().__init__()

        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel


class SetPhaseToReleaseForLeakScenarioCalculation(_CalculationBase):
    """
    SetPhaseToReleaseForLeakScenario calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	phase_to_release : Phase 
		Requested fluid phase to release.
	release_elevation : float 
		Release point elevation above ground.
	vessel : Vessel 
		Vessel definition input.

    Calculation outputs:
    
	zcoord_updated : float 
		Updated z-coordinate of vessel to accommodate requested phase to release.
	hole_height_fraction_updated : float 
		Updated hole height fraction to accommodate requested phase to release.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the SetPhaseToReleaseForLeakScenarioCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

        # Calculation outputs.
        self.zcoord_updated = None
        self.hole_height_fraction_updated = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Set phase to release for leak scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        SetPhaseToReleaseForLeakScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetPhaseToReleaseForLeakScenarioCalculationRequest object.
        set_phase_to_release_for_leak_scenario_calculation_request = _SetPhaseToReleaseForLeakScenarioCalculationRequest(self.phase_to_release, self.release_elevation, self.vessel)

        # Get the appropriate schema and use that to serialize to json.
        set_phase_to_release_for_leak_scenario_calculation_request_schema = _SetPhaseToReleaseForLeakScenarioCalculationRequestSchema()

        request_json = set_phase_to_release_for_leak_scenario_calculation_request_schema.dumps(set_phase_to_release_for_leak_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/setphasetoreleaseforleakscenario?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            set_phase_to_release_for_leak_scenario_calculation_response_schema = _SetPhaseToReleaseForLeakScenarioCalculationResponseSchema()
            set_phase_to_release_for_leak_scenario_calculation_response = set_phase_to_release_for_leak_scenario_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(set_phase_to_release_for_leak_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.zcoord_updated = set_phase_to_release_for_leak_scenario_calculation_response.zcoord_updated
                self.hole_height_fraction_updated = set_phase_to_release_for_leak_scenario_calculation_response.hole_height_fraction_updated
                self.result_code = set_phase_to_release_for_leak_scenario_calculation_response.result_code
                self.messages = set_phase_to_release_for_leak_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_phase_to_release_for_leak_scenario_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(set_phase_to_release_for_leak_scenario_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the SetPhaseToReleaseForLeakScenario calculation object"""

        parts = ['* SetPhaseToReleaseForLeakScenario']

        parts.append(f'ZCoordUpdated : {self.zcoord_updated}')
        parts.append(f'HoleHeightFractionUpdated : {self.hole_height_fraction_updated}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _SetPhaseToReleaseForLeakScenarioCalculationResponse(_CalculationResponseBase):
    """
    SetPhaseToReleaseForLeakScenario calculation response class.

    Attributes
    ----------
	zcoord_updated : float 
		Updated z-coordinate of vessel to accommodate requested phase to release.
	hole_height_fraction_updated : float 
		Updated hole height fraction to accommodate requested phase to release.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, zcoord_updated: float, hole_height_fraction_updated: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the SetPhaseToReleaseForLeakScenarioCalculationResponse class"""
        super().__init__()

        self.zcoord_updated = zcoord_updated
        self.hole_height_fraction_updated = hole_height_fraction_updated
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Set phase to release for leak scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'zcoord_updated' in data and data['zcoord_updated'] is not None:
            self.zcoord_updated
        
        if 'hole_height_fraction_updated' in data and data['hole_height_fraction_updated'] is not None:
            self.hole_height_fraction_updated
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLeakFlammableLinkedRunH2CalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakFlammableLinkedRunH2 calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Concentration levels.
	dispersion_output_config_count : int 
		Number of concentration levels.
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.
    """
    
    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselLeakFlammableLinkedRunH2CalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count


class VesselLeakFlammableLinkedRunH2Calculation(_CalculationBase):
    """
    VesselLeakFlammableLinkedRunH2 calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
	substrate : Substrate 
		The dispersing surface.
	weather : Weather 
		Weather definition.
	dispersion_parameters : list[DispersionParameters] 
		Dispersion parameters.
	dispersion_parameter_count : int 
		Number of dispersion parameters.
	end_point_concentration : float 
		Concentration at which the dispersion calculations will terminate (v/v fraction).
	flammable_parameters : FlammableParameters 
		Fire model parameters.
	explosion_parameters : ExplosionParameters 
		Explosion parameters.
	dispersion_output_configs : list[DispersionOutputConfig] 
		Concentration levels.
	dispersion_output_config_count : int 
		Number of concentration levels.
	flammable_output_configs : list[FlammableOutputConfig] 
		Radiation levels.
	flammable_output_config_count : int 
		Number of radiation levels.
	explosion_output_configs : list[ExplosionOutputConfig] 
		Overpressure levels.
	explosion_output_config_count : int 
		Number of overpressure levels.
	explosion_confined_volumes : list[ExplosionConfinedVolume] 
		Explosion confined volumes.
	explosion_confined_volume_count : int 
		Number of confined explosion sources.

    Calculation outputs:
    
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire contours.
	distances_to_concentration : list[float] 
		Distances to concentration levels.
	concentrations_used : list[float] 
		Concentration levels.
	conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels.
	nconc_contour_points : list[int] 
		Number of contour points per concentration level.
	area_footprint_conc : list[float] 
		Areas of maximum concentration footprints.
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselLeakFlammableLinkedRunH2Calculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.njet_contour_points = None
        self.area_ellipse_jet = None
        self.distances_to_concentration = None
        self.concentrations_used = None
        self.conc_contour_points = None
        self.nconc_contour_points = None
        self.area_footprint_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.npool_contour_points = None
        self.area_ellipse_pool = None
        self.explosion_overpressure_results = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel leak flammable linked run h2 calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLeakFlammableLinkedRunH2Calculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakFlammableLinkedRunH2CalculationRequest object.
        vessel_leak_flammable_linked_run_h2_calculation_request = _VesselLeakFlammableLinkedRunH2CalculationRequest(self.vessel, self.leak, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_output_configs, self.dispersion_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the appropriate schema and use that to serialize to json.
        vessel_leak_flammable_linked_run_h2_calculation_request_schema = _VesselLeakFlammableLinkedRunH2CalculationRequestSchema()

        request_json = vessel_leak_flammable_linked_run_h2_calculation_request_schema.dumps(vessel_leak_flammable_linked_run_h2_calculation_request)
        url = get_analytics_api_target() + 'vesselleakflammablelinkedrunh2?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_leak_flammable_linked_run_h2_calculation_response_schema = _VesselLeakFlammableLinkedRunH2CalculationResponseSchema()
            vessel_leak_flammable_linked_run_h2_calculation_response = vessel_leak_flammable_linked_run_h2_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_leak_flammable_linked_run_h2_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_leak_flammable_linked_run_h2_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_leak_flammable_linked_run_h2_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_leak_flammable_linked_run_h2_calculation_response.jet_contour_points
                self.njet_contour_points = vessel_leak_flammable_linked_run_h2_calculation_response.njet_contour_points
                self.area_ellipse_jet = vessel_leak_flammable_linked_run_h2_calculation_response.area_ellipse_jet
                self.distances_to_concentration = vessel_leak_flammable_linked_run_h2_calculation_response.distances_to_concentration
                self.concentrations_used = vessel_leak_flammable_linked_run_h2_calculation_response.concentrations_used
                self.conc_contour_points = vessel_leak_flammable_linked_run_h2_calculation_response.conc_contour_points
                self.nconc_contour_points = vessel_leak_flammable_linked_run_h2_calculation_response.nconc_contour_points
                self.area_footprint_conc = vessel_leak_flammable_linked_run_h2_calculation_response.area_footprint_conc
                self.distances_to_pool_fire_radiation = vessel_leak_flammable_linked_run_h2_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_leak_flammable_linked_run_h2_calculation_response.pool_contour_points
                self.npool_contour_points = vessel_leak_flammable_linked_run_h2_calculation_response.npool_contour_points
                self.area_ellipse_pool = vessel_leak_flammable_linked_run_h2_calculation_response.area_ellipse_pool
                self.explosion_overpressure_results = vessel_leak_flammable_linked_run_h2_calculation_response.explosion_overpressure_results
                self.jet_fire_flame_result = vessel_leak_flammable_linked_run_h2_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_leak_flammable_linked_run_h2_calculation_response.pool_fire_flame_result
                self.result_code = vessel_leak_flammable_linked_run_h2_calculation_response.result_code
                self.messages = vessel_leak_flammable_linked_run_h2_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_flammable_linked_run_h2_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_leak_flammable_linked_run_h2_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakFlammableLinkedRunH2 calculation object"""

        parts = ['* VesselLeakFlammableLinkedRunH2']

        parts.append(f'discharge_record: {str(self.discharge_record)}')
        parts.append(f'*** distances_to_jet_fire_radiation')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.append(f'*** jet_contour_points')
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.append(f'*** njet_contour_points')
        parts.extend(['njet_contour_points_element' for njet_contour_points_element in self.njet_contour_points] if self.njet_contour_points else [f'njet_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_jet')
        parts.extend(['area_ellipse_jet_element' for area_ellipse_jet_element in self.area_ellipse_jet] if self.area_ellipse_jet else [f'area_ellipse_jet does not contain any elements'])
        parts.append(f'*** distances_to_concentration')
        parts.extend(['distances_to_concentration_element' for distances_to_concentration_element in self.distances_to_concentration] if self.distances_to_concentration else [f'distances_to_concentration does not contain any elements'])
        parts.append(f'*** concentrations_used')
        parts.extend(['concentrations_used_element' for concentrations_used_element in self.concentrations_used] if self.concentrations_used else [f'concentrations_used does not contain any elements'])
        parts.append(f'*** conc_contour_points')
        parts.extend(['conc_contour_points_element' for conc_contour_points_element in self.conc_contour_points] if self.conc_contour_points else [f'conc_contour_points does not contain any elements'])
        parts.append(f'*** nconc_contour_points')
        parts.extend(['nconc_contour_points_element' for nconc_contour_points_element in self.nconc_contour_points] if self.nconc_contour_points else [f'nconc_contour_points does not contain any elements'])
        parts.append(f'*** area_footprint_conc')
        parts.extend(['area_footprint_conc_element' for area_footprint_conc_element in self.area_footprint_conc] if self.area_footprint_conc else [f'area_footprint_conc does not contain any elements'])
        parts.append(f'*** distances_to_pool_fire_radiation')
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.append(f'*** pool_contour_points')
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.append(f'*** npool_contour_points')
        parts.extend(['npool_contour_points_element' for npool_contour_points_element in self.npool_contour_points] if self.npool_contour_points else [f'npool_contour_points does not contain any elements'])
        parts.append(f'*** area_ellipse_pool')
        parts.extend(['area_ellipse_pool_element' for area_ellipse_pool_element in self.area_ellipse_pool] if self.area_ellipse_pool else [f'area_ellipse_pool does not contain any elements'])
        parts.append(f'*** explosion_overpressure_results')
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.append(f'jet_fire_flame_result: {str(self.jet_fire_flame_result)}')
        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLeakFlammableLinkedRunH2CalculationResponse(_CalculationResponseBase):
    """
    VesselLeakFlammableLinkedRunH2 calculation response class.

    Attributes
    ----------
	discharge_record : DischargeRecord 
		Discharge data for table.
	distances_to_jet_fire_radiation : list[float] 
		Distances to jet fire radiation levels.
	jet_contour_points : list[LocalPosition] 
		Callback function for jet fire radiation contour points.
	njet_contour_points : list[int] 
		Number of points for jet fire contours per radiation level.
	area_ellipse_jet : list[float] 
		Areas of jet fire contours.
	distances_to_concentration : list[float] 
		Distances to concentration levels.
	concentrations_used : list[float] 
		Concentration levels.
	conc_contour_points : list[LocalPosition] 
		Maximum concentration footprints at given concentration levels.
	nconc_contour_points : list[int] 
		Number of contour points per concentration level.
	area_footprint_conc : list[float] 
		Areas of maximum concentration footprints.
	distances_to_pool_fire_radiation : list[float] 
		Distances to pool fire radiation levels.
	pool_contour_points : list[LocalPosition] 
		Callback function for pool fire radiation contour points.
	npool_contour_points : list[int] 
		Number of points for pool fire contours per radiation level.
	area_ellipse_pool : list[float] 
		Areas of pool fire contours.
	explosion_overpressure_results : list[ExplosionOverpressureResult] 
		Explosion results to overpressure levels.
	jet_fire_flame_result : FlameResult 
		Flame results for jet fire.
	pool_fire_flame_result : PoolFireFlameResult 
		Flame results for pool fire.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], njet_contour_points: list[int], area_ellipse_jet: list[float], distances_to_concentration: list[float], concentrations_used: list[float], conc_contour_points: list[LocalPosition], nconc_contour_points: list[int], area_footprint_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], npool_contour_points: list[int], area_ellipse_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLeakFlammableLinkedRunH2CalculationResponse class"""
        super().__init__()

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation if distances_to_jet_fire_radiation is not None else []
        self.jet_contour_points = jet_contour_points if jet_contour_points is not None else []
        self.njet_contour_points = njet_contour_points if njet_contour_points is not None else []
        self.area_ellipse_jet = area_ellipse_jet if area_ellipse_jet is not None else []
        self.distances_to_concentration = distances_to_concentration if distances_to_concentration is not None else []
        self.concentrations_used = concentrations_used if concentrations_used is not None else []
        self.conc_contour_points = conc_contour_points if conc_contour_points is not None else []
        self.nconc_contour_points = nconc_contour_points if nconc_contour_points is not None else []
        self.area_footprint_conc = area_footprint_conc if area_footprint_conc is not None else []
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation if distances_to_pool_fire_radiation is not None else []
        self.pool_contour_points = pool_contour_points if pool_contour_points is not None else []
        self.npool_contour_points = npool_contour_points if npool_contour_points is not None else []
        self.area_ellipse_pool = area_ellipse_pool if area_ellipse_pool is not None else []
        self.explosion_overpressure_results = explosion_overpressure_results if explosion_overpressure_results is not None else []
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel leak flammable linked run h2 calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'discharge_record' in data and data['discharge_record'] is not None:
            self.discharge_record.initialise_from_dictionary(data['discharge_record'])
        
        if 'jet_contour_points' in data and data['jet_contour_points'] is not None:
            self.jet_contour_points = [record.initialise_from_dictionary(record) for record in data['jet_contour_points']]
        else:
            self.jet_contour_points = []
        
        if 'conc_contour_points' in data and data['conc_contour_points'] is not None:
            self.conc_contour_points = [record.initialise_from_dictionary(record) for record in data['conc_contour_points']]
        else:
            self.conc_contour_points = []
        
        if 'pool_contour_points' in data and data['pool_contour_points'] is not None:
            self.pool_contour_points = [record.initialise_from_dictionary(record) for record in data['pool_contour_points']]
        else:
            self.pool_contour_points = []
        
        if 'explosion_overpressure_results' in data and data['explosion_overpressure_results'] is not None:
            self.explosion_overpressure_results = [record.initialise_from_dictionary(record) for record in data['explosion_overpressure_results']]
        else:
            self.explosion_overpressure_results = []
        
        if 'jet_fire_flame_result' in data and data['jet_fire_flame_result'] is not None:
            self.jet_fire_flame_result.initialise_from_dictionary(data['jet_fire_flame_result'])
        
        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _LoadMassInventoryVesselForLeakScenarioCalculationRequest(_CalculationRequestBase):
    """
    _LoadMassInventoryVesselForLeakScenario calculation request class.
    
    Attributes
    ----------
	material : Material 
		Vessel material.
	mass : float 
		Total vessel mass inventory.
	pressure : float 
		Vessel pressure in absolute scale.
	temperature : float 
		Vessel temperature.
	hole_size : float 
		Leak hole size.
	release_elevation : float 
		Release elevation.
	release_angle : float 
		Release angle.
    """
    
    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, hole_size: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the _LoadMassInventoryVesselForLeakScenarioCalculationRequest class"""
        super().__init__()

        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.hole_size = hole_size
        self.release_elevation = release_elevation
        self.release_angle = release_angle


class LoadMassInventoryVesselForLeakScenarioCalculation(_CalculationBase):
    """
    LoadMassInventoryVesselForLeakScenario calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Vessel material.
	mass : float 
		Total vessel mass inventory.
	pressure : float 
		Vessel pressure in absolute scale.
	temperature : float 
		Vessel temperature.
	hole_size : float 
		Leak hole size.
	release_elevation : float 
		Release elevation.
	release_angle : float 
		Release angle.

    Calculation outputs:
    
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, hole_size: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the LoadMassInventoryVesselForLeakScenarioCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.hole_size = hole_size
        self.release_elevation = release_elevation
        self.release_angle = release_angle

        # Calculation outputs.
        self.vessel = None
        self.leak = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Load mass inventory vessel for leak scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        LoadMassInventoryVesselForLeakScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LoadMassInventoryVesselForLeakScenarioCalculationRequest object.
        load_mass_inventory_vessel_for_leak_scenario_calculation_request = _LoadMassInventoryVesselForLeakScenarioCalculationRequest(self.material, self.mass, self.pressure, self.temperature, self.hole_size, self.release_elevation, self.release_angle)

        # Get the appropriate schema and use that to serialize to json.
        load_mass_inventory_vessel_for_leak_scenario_calculation_request_schema = _LoadMassInventoryVesselForLeakScenarioCalculationRequestSchema()

        request_json = load_mass_inventory_vessel_for_leak_scenario_calculation_request_schema.dumps(load_mass_inventory_vessel_for_leak_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/loadmassinventoryvesselforleakscenario?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            load_mass_inventory_vessel_for_leak_scenario_calculation_response_schema = _LoadMassInventoryVesselForLeakScenarioCalculationResponseSchema()
            load_mass_inventory_vessel_for_leak_scenario_calculation_response = load_mass_inventory_vessel_for_leak_scenario_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(load_mass_inventory_vessel_for_leak_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel = load_mass_inventory_vessel_for_leak_scenario_calculation_response.vessel
                self.leak = load_mass_inventory_vessel_for_leak_scenario_calculation_response.leak
                self.result_code = load_mass_inventory_vessel_for_leak_scenario_calculation_response.result_code
                self.messages = load_mass_inventory_vessel_for_leak_scenario_calculation_response.messages
                self.calculation_elapsed_time = load_mass_inventory_vessel_for_leak_scenario_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(load_mass_inventory_vessel_for_leak_scenario_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the LoadMassInventoryVesselForLeakScenario calculation object"""

        parts = ['* LoadMassInventoryVesselForLeakScenario']

        parts.append(f'vessel: {str(self.vessel)}')
        parts.append(f'leak: {str(self.leak)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _LoadMassInventoryVesselForLeakScenarioCalculationResponse(_CalculationResponseBase):
    """
    LoadMassInventoryVesselForLeakScenario calculation response class.

    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	leak : Leak 
		Leak scenario.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, vessel: Vessel, leak: Leak, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the LoadMassInventoryVesselForLeakScenarioCalculationResponse class"""
        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Load mass inventory vessel for leak scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'vessel' in data and data['vessel'] is not None:
            self.vessel.initialise_from_dictionary(data['vessel'])
        
        if 'leak' in data and data['leak'] is not None:
            self.leak.initialise_from_dictionary(data['leak'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _MaxDistanceToConcCalculationRequest(_CalculationRequestBase):
    """
    _MaxDistanceToConc calculation request class.
    
    Attributes
    ----------
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.
    """
    
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _MaxDistanceToConcCalculationRequest class"""
        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters


class MaxDistanceToConcCalculation(_CalculationBase):
    """
    MaxDistanceToConc calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	scalar_udm_outputs : ScalarUdmOutputs 
		UDM scalar outputs.
	weather : Weather 
		Weather.
	dispersion_records : list[DispersionRecord] 
		Dispersion definition.
	dispersion_record_count : int 
		Number of dispersion records.
	substrate : Substrate 
		The dispersing surface.
	dispersion_output_config : DispersionOutputConfig 
		Dispersion view configuration.
	material : Material 
		Material with post-discharge composition.
	dispersion_parameters : DispersionParameters 
		Dispersion parameters.

    Calculation outputs:
    
	conc_used : float 
		Concentration of interest.
	distance : float 
		Maximum distance to concentration of interest.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the MaxDistanceToConcCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.distance = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Max distance to conc calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        MaxDistanceToConcCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MaxDistanceToConcCalculationRequest object.
        max_distance_to_conc_calculation_request = _MaxDistanceToConcCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the appropriate schema and use that to serialize to json.
        max_distance_to_conc_calculation_request_schema = _MaxDistanceToConcCalculationRequestSchema()

        request_json = max_distance_to_conc_calculation_request_schema.dumps(max_distance_to_conc_calculation_request)
        url = get_analytics_api_target() + 'calculatemaxdistancetoconc?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            max_distance_to_conc_calculation_response_schema = _MaxDistanceToConcCalculationResponseSchema()
            max_distance_to_conc_calculation_response = max_distance_to_conc_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(max_distance_to_conc_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = max_distance_to_conc_calculation_response.conc_used
                self.distance = max_distance_to_conc_calculation_response.distance
                self.result_code = max_distance_to_conc_calculation_response.result_code
                self.messages = max_distance_to_conc_calculation_response.messages
                self.calculation_elapsed_time = max_distance_to_conc_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(max_distance_to_conc_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the MaxDistanceToConc calculation object"""

        parts = ['* MaxDistanceToConc']

        parts.append(f'ConcUsed : {self.conc_used}')
        parts.append(f'Distance : {self.distance}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _MaxDistanceToConcCalculationResponse(_CalculationResponseBase):
    """
    MaxDistanceToConc calculation response class.

    Attributes
    ----------
	conc_used : float 
		Concentration of interest.
	distance : float 
		Maximum distance to concentration of interest.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, conc_used: float, distance: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the MaxDistanceToConcCalculationResponse class"""
        super().__init__()

        self.conc_used = conc_used
        self.distance = distance
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Max distance to conc calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'conc_used' in data and data['conc_used'] is not None:
            self.conc_used
        
        if 'distance' in data and data['distance'] is not None:
            self.distance
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest(_CalculationRequestBase):
    """
    _LoadMassInventoryVesselForLineRuptureScenario calculation request class.
    
    Attributes
    ----------
	material : Material 
		Vessel material.
	mass : float 
		Total vessel mass inventory.
	pressure : float 
		Vessel pressure in absolute scale.
	temperature : float 
		Vessel temperature.
	pipe_diameter : float 
		Pipe diameter.
	pipe_length : float 
		Pipe length.
	release_elevation : float 
		Release elevation.
	release_angle : float 
		Release angle.
    """
    
    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest class"""
        super().__init__()

        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle


class LoadMassInventoryVesselForLineRuptureScenarioCalculation(_CalculationBase):
    """
    LoadMassInventoryVesselForLineRuptureScenario calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Vessel material.
	mass : float 
		Total vessel mass inventory.
	pressure : float 
		Vessel pressure in absolute scale.
	temperature : float 
		Vessel temperature.
	pipe_diameter : float 
		Pipe diameter.
	pipe_length : float 
		Pipe length.
	release_elevation : float 
		Release elevation.
	release_angle : float 
		Release angle.

    Calculation outputs:
    
	vessel : Vessel 
		Vessel definition.
	line_rupture : LineRupture 
		Line rupture.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the LoadMassInventoryVesselForLineRuptureScenarioCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle

        # Calculation outputs.
        self.vessel = None
        self.line_rupture = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Load mass inventory vessel for line rupture scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        LoadMassInventoryVesselForLineRuptureScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest object.
        load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request = _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest(self.material, self.mass, self.pressure, self.temperature, self.pipe_diameter, self.pipe_length, self.release_elevation, self.release_angle)

        # Get the appropriate schema and use that to serialize to json.
        load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request_schema = _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequestSchema()

        request_json = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request_schema.dumps(load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/loadmassinventoryvesselforlinerupturescenario?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response_schema = _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponseSchema()
            load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.vessel
                self.line_rupture = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.line_rupture
                self.result_code = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.result_code
                self.messages = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.messages
                self.calculation_elapsed_time = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the LoadMassInventoryVesselForLineRuptureScenario calculation object"""

        parts = ['* LoadMassInventoryVesselForLineRuptureScenario']

        parts.append(f'vessel: {str(self.vessel)}')
        parts.append(f'line_rupture: {str(self.line_rupture)}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse(_CalculationResponseBase):
    """
    LoadMassInventoryVesselForLineRuptureScenario calculation response class.

    Attributes
    ----------
	vessel : Vessel 
		Vessel definition.
	line_rupture : LineRupture 
		Line rupture.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, vessel: Vessel, line_rupture: LineRupture, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse class"""
        super().__init__()

        self.vessel = vessel
        self.line_rupture = line_rupture
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Load mass inventory vessel for line rupture scenario calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'vessel' in data and data['vessel'] is not None:
            self.vessel.initialise_from_dictionary(data['vessel'])
        
        if 'line_rupture' in data and data['line_rupture'] is not None:
            self.line_rupture.initialise_from_dictionary(data['line_rupture'])
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _ReliefValveMinTemperatureCalculationRequest(_CalculationRequestBase):
    """
    _ReliefValveMinTemperature calculation request class.
    
    Attributes
    ----------
	material : Material 
		Material.
	pressure : float 
		Input pressure (absolute) at which to evaluate bubble point temperature.
    """
    
    def __init__(self, material: Material, pressure: float):
        """Initializes a new instance of the _ReliefValveMinTemperatureCalculationRequest class"""
        super().__init__()

        self.material = material
        self.pressure = pressure


class ReliefValveMinTemperatureCalculation(_CalculationBase):
    """
    ReliefValveMinTemperature calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	material : Material 
		Material.
	pressure : float 
		Input pressure (absolute) at which to evaluate bubble point temperature.

    Calculation outputs:
    
	min_temperature : float 
		Calculated lower temperature limit for relief valve scenario.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, pressure: float):
        """Initializes a new instance of the ReliefValveMinTemperatureCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.material = material
        self.pressure = pressure

        # Calculation outputs.
        self.min_temperature = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Relief valve min temperature calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        ReliefValveMinTemperatureCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ReliefValveMinTemperatureCalculationRequest object.
        relief_valve_min_temperature_calculation_request = _ReliefValveMinTemperatureCalculationRequest(self.material, self.pressure)

        # Get the appropriate schema and use that to serialize to json.
        relief_valve_min_temperature_calculation_request_schema = _ReliefValveMinTemperatureCalculationRequestSchema()

        request_json = relief_valve_min_temperature_calculation_request_schema.dumps(relief_valve_min_temperature_calculation_request)
        url = get_analytics_api_target() + 'utilities/reliefvalvemintemperature?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            relief_valve_min_temperature_calculation_response_schema = _ReliefValveMinTemperatureCalculationResponseSchema()
            relief_valve_min_temperature_calculation_response = relief_valve_min_temperature_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(relief_valve_min_temperature_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.min_temperature = relief_valve_min_temperature_calculation_response.min_temperature
                self.result_code = relief_valve_min_temperature_calculation_response.result_code
                self.messages = relief_valve_min_temperature_calculation_response.messages
                self.calculation_elapsed_time = relief_valve_min_temperature_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(relief_valve_min_temperature_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the ReliefValveMinTemperature calculation object"""

        parts = ['* ReliefValveMinTemperature']

        parts.append(f'MinTemperature : {self.min_temperature}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _ReliefValveMinTemperatureCalculationResponse(_CalculationResponseBase):
    """
    ReliefValveMinTemperature calculation response class.

    Attributes
    ----------
	min_temperature : float 
		Calculated lower temperature limit for relief valve scenario.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, min_temperature: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the ReliefValveMinTemperatureCalculationResponse class"""
        super().__init__()

        self.min_temperature = min_temperature
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Relief valve min temperature calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'min_temperature' in data and data['min_temperature'] is not None:
            self.min_temperature
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselLineRuptureCalculationRequest(_CalculationRequestBase):
    """
    _VesselLineRupture calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	line_rupture : LineRupture 
		Line rupture scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.
    """
    
    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselLineRuptureCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters


class VesselLineRuptureCalculation(_CalculationBase):
    """
    VesselLineRupture calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	line_rupture : LineRupture 
		Line rupture scenario.
	discharge_parameters : DischargeParameters 
		Discharge parameters.

    Calculation outputs:
    
	exit_material : Material 
		Composition of the released material (may differ from storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselLineRuptureCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel line rupture calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselLineRuptureCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLineRuptureCalculationRequest object.
        vessel_line_rupture_calculation_request = _VesselLineRuptureCalculationRequest(self.vessel, self.line_rupture, self.discharge_parameters)

        # Get the appropriate schema and use that to serialize to json.
        vessel_line_rupture_calculation_request_schema = _VesselLineRuptureCalculationRequestSchema()

        request_json = vessel_line_rupture_calculation_request_schema.dumps(vessel_line_rupture_calculation_request)
        url = get_analytics_api_target() + 'calculatevessellinerupture?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_line_rupture_calculation_response_schema = _VesselLineRuptureCalculationResponseSchema()
            vessel_line_rupture_calculation_response = vessel_line_rupture_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_line_rupture_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_line_rupture_calculation_response.exit_material
                self.discharge_result = vessel_line_rupture_calculation_response.discharge_result
                self.discharge_records = vessel_line_rupture_calculation_response.discharge_records
                self.result_code = vessel_line_rupture_calculation_response.result_code
                self.messages = vessel_line_rupture_calculation_response.messages
                self.calculation_elapsed_time = vessel_line_rupture_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_line_rupture_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLineRupture calculation object"""

        parts = ['* VesselLineRupture']

        parts.append(f'exit_material: {str(self.exit_material)}')
        parts.append(f'discharge_result: {str(self.discharge_result)}')
        parts.append(f'*** discharge_records')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselLineRuptureCalculationResponse(_CalculationResponseBase):
    """
    VesselLineRupture calculation response class.

    Attributes
    ----------
	exit_material : Material 
		Composition of the released material (may differ from storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselLineRuptureCalculationResponse class"""
        super().__init__()

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records if discharge_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel line rupture calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'exit_material' in data and data['exit_material'] is not None:
            self.exit_material.initialise_from_dictionary(data['exit_material'])
        
        if 'discharge_result' in data and data['discharge_result'] is not None:
            self.discharge_result.initialise_from_dictionary(data['discharge_result'])
        
        if 'discharge_records' in data and data['discharge_records'] is not None:
            self.discharge_records = [record.initialise_from_dictionary(record) for record in data['discharge_records']]
        else:
            self.discharge_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _DistancesAndEllipsesToRadiationLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesAndEllipsesToRadiationLevels calculation request class.
    
    Attributes
    ----------
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings of radiation calculations.
	flammable_output_config_count : int 
		Number of radiation levels.
    """
    
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _DistancesAndEllipsesToRadiationLevelsCalculationRequest class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count


class DistancesAndEllipsesToRadiationLevelsCalculation(_CalculationBase):
    """
    DistancesAndEllipsesToRadiationLevels calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_configs : list[FlammableOutputConfig] 
		Settings of radiation calculations.
	flammable_output_config_count : int 
		Number of radiation levels.

    Calculation outputs:
    
	distances : list[float] 
		Distances to radiation levels.
	contour_points : list[LocalPosition] 
		Contour points of radiation ellipses to radiation levels.
	ncontour_points : list[int] 
		Number of contour points per radiation level.
	areas : list[float] 
		Area of the ellipse to radiation levels.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.distances = None
        self.contour_points = None
        self.ncontour_points = None
        self.areas = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Distances and ellipses to radiation levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        DistancesAndEllipsesToRadiationLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesAndEllipsesToRadiationLevelsCalculationRequest object.
        distances_and_ellipses_to_radiation_levels_calculation_request = _DistancesAndEllipsesToRadiationLevelsCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the appropriate schema and use that to serialize to json.
        distances_and_ellipses_to_radiation_levels_calculation_request_schema = _DistancesAndEllipsesToRadiationLevelsCalculationRequestSchema()

        request_json = distances_and_ellipses_to_radiation_levels_calculation_request_schema.dumps(distances_and_ellipses_to_radiation_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancesandellipsestoradiationlevels?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            distances_and_ellipses_to_radiation_levels_calculation_response_schema = _DistancesAndEllipsesToRadiationLevelsCalculationResponseSchema()
            distances_and_ellipses_to_radiation_levels_calculation_response = distances_and_ellipses_to_radiation_levels_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(distances_and_ellipses_to_radiation_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances = distances_and_ellipses_to_radiation_levels_calculation_response.distances
                self.contour_points = distances_and_ellipses_to_radiation_levels_calculation_response.contour_points
                self.ncontour_points = distances_and_ellipses_to_radiation_levels_calculation_response.ncontour_points
                self.areas = distances_and_ellipses_to_radiation_levels_calculation_response.areas
                self.result_code = distances_and_ellipses_to_radiation_levels_calculation_response.result_code
                self.messages = distances_and_ellipses_to_radiation_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_and_ellipses_to_radiation_levels_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(distances_and_ellipses_to_radiation_levels_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesAndEllipsesToRadiationLevels calculation object"""

        parts = ['* DistancesAndEllipsesToRadiationLevels']

        parts.append(f'*** distances')
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.append(f'*** contour_points')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'*** ncontour_points')
        parts.extend(['ncontour_points_element' for ncontour_points_element in self.ncontour_points] if self.ncontour_points else [f'ncontour_points does not contain any elements'])
        parts.append(f'*** areas')
        parts.extend(['areas_element' for areas_element in self.areas] if self.areas else [f'areas does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _DistancesAndEllipsesToRadiationLevelsCalculationResponse(_CalculationResponseBase):
    """
    DistancesAndEllipsesToRadiationLevels calculation response class.

    Attributes
    ----------
	distances : list[float] 
		Distances to radiation levels.
	contour_points : list[LocalPosition] 
		Contour points of radiation ellipses to radiation levels.
	ncontour_points : list[int] 
		Number of contour points per radiation level.
	areas : list[float] 
		Area of the ellipse to radiation levels.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, distances: list[float], contour_points: list[LocalPosition], ncontour_points: list[int], areas: list[float], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsCalculationResponse class"""
        super().__init__()

        self.distances = distances if distances is not None else []
        self.contour_points = contour_points if contour_points is not None else []
        self.ncontour_points = ncontour_points if ncontour_points is not None else []
        self.areas = areas if areas is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Distances and ellipses to radiation levels calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'contour_points' in data and data['contour_points'] is not None:
            self.contour_points = [record.initialise_from_dictionary(record) for record in data['contour_points']]
        else:
            self.contour_points = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _RadiationAtAPointCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtAPoint calculation request class.
    
    Attributes
    ----------
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.
    """
    
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationAtAPointCalculationRequest class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config


class RadiationAtAPointCalculation(_CalculationBase):
    """
    RadiationAtAPoint calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.

    Calculation outputs:
    
	radiation : float 
		Radiation at a point.
	result_code : ResultCode 
		Response code.

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationAtAPointCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Radiation at a point calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        RadiationAtAPointCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtAPointCalculationRequest object.
        radiation_at_apoint_calculation_request = _RadiationAtAPointCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the appropriate schema and use that to serialize to json.
        radiation_at_apoint_calculation_request_schema = _RadiationAtAPointCalculationRequestSchema()

        request_json = radiation_at_apoint_calculation_request_schema.dumps(radiation_at_apoint_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatapoint?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            radiation_at_apoint_calculation_response_schema = _RadiationAtAPointCalculationResponseSchema()
            radiation_at_apoint_calculation_response = radiation_at_apoint_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(radiation_at_apoint_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_apoint_calculation_response.radiation
                self.result_code = radiation_at_apoint_calculation_response.result_code
                self.messages = radiation_at_apoint_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_apoint_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(radiation_at_apoint_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtAPoint calculation object"""

        parts = ['* RadiationAtAPoint']

        parts.append(f'Radiation : {self.radiation}')
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _RadiationAtAPointCalculationResponse(_CalculationResponseBase):
    """
    RadiationAtAPoint calculation response class.

    Attributes
    ----------
	radiation : float 
		Radiation at a point.
	result_code : ResultCode 
		Response code.
    """

    def __init__(self, radiation: float, result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the RadiationAtAPointCalculationResponse class"""
        super().__init__()

        self.radiation = radiation
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Radiation at a point calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'radiation' in data and data['radiation'] is not None:
            self.radiation
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _TankFireCalculationRequest(_CalculationRequestBase):
    """
    _TankFire calculation request class.
    
    Attributes
    ----------
	atmospheric_storage_tank : AtmosphericStorageTank 
		Atmospheric storage tank.
	weather : Weather 
		Weather.
	substrate : Substrate 
		Substrate.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
    """
    
    def __init__(self, atmospheric_storage_tank: AtmosphericStorageTank, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the _TankFireCalculationRequest class"""
        super().__init__()

        self.atmospheric_storage_tank = atmospheric_storage_tank
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters


class TankFireCalculation(_CalculationBase):
    """
    TankFire calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	atmospheric_storage_tank : AtmosphericStorageTank 
		Atmospheric storage tank.
	weather : Weather 
		Weather.
	substrate : Substrate 
		Substrate.
	flammable_parameters : FlammableParameters 
		Flammable parameters.

    Calculation outputs:
    
	pool_fire_flame_result : PoolFireFlameResult 
		Flame scalar result.
	flame_records : list[FlameRecord] 
		Pool fire flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, atmospheric_storage_tank: AtmosphericStorageTank, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the TankFireCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.atmospheric_storage_tank = atmospheric_storage_tank
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

        # Calculation outputs.
        self.pool_fire_flame_result = None
        self.flame_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Tank fire calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        TankFireCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _TankFireCalculationRequest object.
        tank_fire_calculation_request = _TankFireCalculationRequest(self.atmospheric_storage_tank, self.weather, self.substrate, self.flammable_parameters)

        # Get the appropriate schema and use that to serialize to json.
        tank_fire_calculation_request_schema = _TankFireCalculationRequestSchema()

        request_json = tank_fire_calculation_request_schema.dumps(tank_fire_calculation_request)
        url = get_analytics_api_target() + 'calculatetankfire?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            tank_fire_calculation_response_schema = _TankFireCalculationResponseSchema()
            tank_fire_calculation_response = tank_fire_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(tank_fire_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.pool_fire_flame_result = tank_fire_calculation_response.pool_fire_flame_result
                self.flame_records = tank_fire_calculation_response.flame_records
                self.result_code = tank_fire_calculation_response.result_code
                self.messages = tank_fire_calculation_response.messages
                self.calculation_elapsed_time = tank_fire_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(tank_fire_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the TankFire calculation object"""

        parts = ['* TankFire']

        parts.append(f'pool_fire_flame_result: {str(self.pool_fire_flame_result)}')
        parts.append(f'*** flame_records')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _TankFireCalculationResponse(_CalculationResponseBase):
    """
    TankFire calculation response class.

    Attributes
    ----------
	pool_fire_flame_result : PoolFireFlameResult 
		Flame scalar result.
	flame_records : list[FlameRecord] 
		Pool fire flame records.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the TankFireCalculationResponse class"""
        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records if flame_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Tank fire calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'pool_fire_flame_result' in data and data['pool_fire_flame_result'] is not None:
            self.pool_fire_flame_result.initialise_from_dictionary(data['pool_fire_flame_result'])
        
        if 'flame_records' in data and data['flame_records'] is not None:
            self.flame_records = [record.initialise_from_dictionary(record) for record in data['flame_records']]
        else:
            self.flame_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _VesselCatastrophicRuptureCalculationRequest(_CalculationRequestBase):
    """
    _VesselCatastrophicRupture calculation request class.
    
    Attributes
    ----------
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	discharge_parameters : DischargeParameters 
		Discharge parameters.
    """
    
    def __init__(self, vessel: Vessel, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselCatastrophicRuptureCalculationRequest class"""
        super().__init__()

        self.vessel = vessel
        self.discharge_parameters = discharge_parameters


class VesselCatastrophicRuptureCalculation(_CalculationBase):
    """
    VesselCatastrophicRupture calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	vessel : Vessel 
		Vessel (pressurised or atmospheric).
	discharge_parameters : DischargeParameters 
		Discharge parameters.

    Calculation outputs:
    
	exit_material : Material 
		Composition of the released material (indentical to storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge record.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselCatastrophicRuptureCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Vessel catastrophic rupture calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        VesselCatastrophicRuptureCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselCatastrophicRuptureCalculationRequest object.
        vessel_catastrophic_rupture_calculation_request = _VesselCatastrophicRuptureCalculationRequest(self.vessel, self.discharge_parameters)

        # Get the appropriate schema and use that to serialize to json.
        vessel_catastrophic_rupture_calculation_request_schema = _VesselCatastrophicRuptureCalculationRequestSchema()

        request_json = vessel_catastrophic_rupture_calculation_request_schema.dumps(vessel_catastrophic_rupture_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselcatastrophicrupture?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            vessel_catastrophic_rupture_calculation_response_schema = _VesselCatastrophicRuptureCalculationResponseSchema()
            vessel_catastrophic_rupture_calculation_response = vessel_catastrophic_rupture_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(vessel_catastrophic_rupture_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_catastrophic_rupture_calculation_response.exit_material
                self.discharge_result = vessel_catastrophic_rupture_calculation_response.discharge_result
                self.discharge_records = vessel_catastrophic_rupture_calculation_response.discharge_records
                self.result_code = vessel_catastrophic_rupture_calculation_response.result_code
                self.messages = vessel_catastrophic_rupture_calculation_response.messages
                self.calculation_elapsed_time = vessel_catastrophic_rupture_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(vessel_catastrophic_rupture_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselCatastrophicRupture calculation object"""

        parts = ['* VesselCatastrophicRupture']

        parts.append(f'exit_material: {str(self.exit_material)}')
        parts.append(f'discharge_result: {str(self.discharge_result)}')
        parts.append(f'*** discharge_records')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _VesselCatastrophicRuptureCalculationResponse(_CalculationResponseBase):
    """
    VesselCatastrophicRupture calculation response class.

    Attributes
    ----------
	exit_material : Material 
		Composition of the released material (indentical to storage composition).
	discharge_result : DischargeResult 
		Scalar discharge results.
	discharge_records : list[DischargeRecord] 
		Array of discharge record.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the VesselCatastrophicRuptureCalculationResponse class"""
        super().__init__()

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records if discharge_records is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Vessel catastrophic rupture calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'exit_material' in data and data['exit_material'] is not None:
            self.exit_material.initialise_from_dictionary(data['exit_material'])
        
        if 'discharge_result' in data and data['discharge_result'] is not None:
            self.discharge_result.initialise_from_dictionary(data['discharge_result'])
        
        if 'discharge_records' in data and data['discharge_records'] is not None:
            self.discharge_records = [record.initialise_from_dictionary(record) for record in data['discharge_records']]
        else:
            self.discharge_records = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])

class _RadiationContourCalculationRequest(_CalculationRequestBase):
    """
    _RadiationContour calculation request class.
    
    Attributes
    ----------
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.
    """
    
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationContourCalculationRequest class"""
        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config


class RadiationContourCalculation(_CalculationBase):
    """
    RadiationContour calculation class.

    Attributes
    ----------
    Calculation inputs:
    
	flame_result : FlameResult 
		Scalar flame results.
	flame_records : list[FlameRecord] 
		Flame definition.
	flame_record_count : int 
		Number of flame records.
	weather : Weather 
		Weather.
	flammable_parameters : FlammableParameters 
		Flammable parameters.
	flammable_output_config : FlammableOutputConfig 
		Settings of flammable contours view.

    Calculation outputs:
    
	contour_points : list[LocalPosition] 
		Array of contour points.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).

    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationContourCalculation class"""
        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.contour_points = None
        self.result_code = None

        # Messages returned by the calculation.
        self.messages = list[str]()
        """ messages: List of messages returned by the Radiation contour calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

    def run(self) -> ResultCode:
        """ 
        RadiationContourCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationContourCalculationRequest object.
        radiation_contour_calculation_request = _RadiationContourCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the appropriate schema and use that to serialize to json.
        radiation_contour_calculation_request_schema = _RadiationContourCalculationRequestSchema()

        request_json = radiation_contour_calculation_request_schema.dumps(radiation_contour_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationcontour?clientId=' + get_client_alias_id()
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:
            radiation_contour_calculation_response_schema = _RadiationContourCalculationResponseSchema()
            radiation_contour_calculation_response = radiation_contour_calculation_response_schema.loads(response.text)
            self.result_code = ResultCode(radiation_contour_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.contour_points = radiation_contour_calculation_response.contour_points
                self.result_code = radiation_contour_calculation_response.result_code
                self.messages = radiation_contour_calculation_response.messages
                self.calculation_elapsed_time = radiation_contour_calculation_response.calculation_elapsed_time
            else:
                self.messages.extend(radiation_contour_calculation_response.messages)
        else:
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
            except:
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")

        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationContour calculation object"""

        parts = ['* RadiationContour']

        parts.append(f'*** contour_points')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{"(None)" if self.result_code is None else ResultCode(self.result_code).name}')

        return '\n'.join(parts)


class _RadiationContourCalculationResponse(_CalculationResponseBase):
    """
    RadiationContour calculation response class.

    Attributes
    ----------
	contour_points : list[LocalPosition] 
		Array of contour points.
	result_code : ResultCode 
		Error code (0 = OK, < 0 data input error, > 0 execution error).
    """

    def __init__(self, contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str]=[0], calculation_elapsed_time: int=0):
        """Initializes a new instance of the RadiationContourCalculationResponse class"""
        super().__init__()

        self.contour_points = contour_points if contour_points is not None else []
        self.result_code = result_code

        # Messages generated by the calculation.
        self.messages: list[str] = []
        """ messages: List of messages returned by the Radiation contour calculation. """

        # Time taken to run the calculation.
        self.calculation_elapsed_time = calculation_elapsed_time
        """ calculation_elapsed_time: Time taken to run the calculation. """

    # Initialise response with data from a dictionary.
    def initialise_from_dictionary(self, data: dict):
        """ Initialise response with data from a dictionary."""

        if 'contour_points' in data and data['contour_points'] is not None:
            self.contour_points = [record.initialise_from_dictionary(record) for record in data['contour_points']]
        else:
            self.contour_points = []
        
        if 'result_code' in data and data['result_code'] is not None:
            self.result_code = ResultCode(data.get('result_code'))
        
        # Messages generated by the calculation.
        if 'messages' in data and data['messages'] is not None:
            for dataItem in data['messages']:
                self.messages.append(dataItem)

        # Time taken to run the calculation.
        if 'calculation_elapsed_time' in data and data['calculation_elapsed_time'] is not None:
          self.calculation_elapsed_time = int(data['calculation_elapsed_time'])