Index: hermes/_4_ddstweak.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hermes/_4_ddstweak.py b/hermes/_4_ddstweak.py
new file mode 100644
--- /dev/null	(date 1722009384686)
+++ b/hermes/_4_ddstweak.py	(date 1722009384686)
@@ -0,0 +1,842 @@
+#!/usr/bin/env python3
+import os
+import textwrap
+from sys import argv
+import shutil
+from re import match
+from pathlib import Path
+from typing import Literal
+
+from ICPSR.utilities import shell
+from ICPSR.utilities.typing import PathLike
+from ICPSR.printers import mprint, print, dedent
+from ICPSR.text import cat, grep, sed, upper, lines_between, Text
+
+
+StatFileType = Literal['spss', 'sas', 'stata']
+
+
+def _check_for_type(outdir:PathLike):
+	try:
+		with open(f'{outdir}/errorlog.txt') as file: errorlog = file.read()
+		nosas   = ' SAS ' in errorlog  # grep ' SAS ' "$outdir"/errorlog.txt 2>/dev/null
+		nostata = 'no Stata files produced' in errorlog  # grep 'no Stata files produced' "$outdir"/errorlog.txt 2>/dev/null
+	except FileNotFoundError as ex:
+		nosas   = False
+		nostata = False
+
+	return nosas, nostata
+
+
+def _tweak_dds(type, outdir, tmpout):
+	""" Simple dispatch function to call the correct tweak-method """
+	if type == 'stata':
+		_4b_tweak_stata(outdir, tmpout)
+	elif type == 'spss':
+		_4b_tweak_spss(outdir, tmpout)
+	elif type == 'sas':
+		_4b_tweak_sas(outdir, tmpout)
+
+
+def run(outdir:PathLike, tmpout:PathLike):
+	"""
+	Component of the Hermes toolset developed for use at ICPSR.
+
+	Standardizes SDA DDS output to Progen-style DDS and standardizes filenames
+	per ICPSR naming conventions.
+
+	See: 4_ddstweak.sh
+
+	Args:
+		outdir: The output directory where the converted files will be saved.
+		tmpout: The temp-directory used for this Hermes session
+
+	Returns:
+		CompletedProcess: A CompletedProcess object containing the output of the script.
+
+	Raises:
+		CalledProcessError
+
+	Details:
+		The script begins by processes the DDS files by generating the top of DDS headers using the
+		"4a_customhdr.sh" script and then tweaks the rest of the DDS files for different data
+		formats (SAS, SPSS, and Stata).
+
+		For each data format, the script removes any white space at the end of lines in the DDS
+		files, then calls the appropriate 4b_tweak script ("4b_tweak" + data_format + ".sh") to
+		further process the DDS files for the specific data format.
+	"""
+
+	#-------------------------------------------------------------------------
+	# Process DDS files
+	#-------------------------------------------------------------------------
+
+	nosas, nostata = _check_for_type(outdir)
+
+	types_to_process = ['spss']
+	if not nosas:   types_to_process += ['sas']
+	if not nostata: types_to_process += ['stata']
+
+	# Generate top of DDS headers
+	_4a_customhdr(outdir, types_to_process, nosas, nostata)
+
+	# Tweak rest of DDS files
+	for type in types_to_process:
+		print(f'         {type.upper()}...')
+		prefix = type[:2]  # echo "${type}" | cut -c1-2
+
+		type_file = Path(f'{tmpout}/{prefix}{outdir}')
+
+		# Remove white space at end of lines
+		shutil.move(f'{type_file}.tmp', f'{type_file}.old')  # backup the old file
+		cat(f'{type_file}.old') | sed(' +$', '') > f'{type_file}.tmp'  # sed 's/  *$//' ${type_file}.old > ${type_file}.tmp
+
+		_tweak_dds(type, outdir, tmpout)
+
+
+def _4a_customhdr(outdir:PathLike, types_to_process:list[StatFileType] = None):
+	""" Creates customized headers for ICPSR setup files (SAS, SPSS, Stata). """
+
+	studynum, part = outdir.split('-')
+
+	if types_to_process is None:
+		nosas, nostata = _check_for_type(outdir)
+		types_to_process = ['spss']
+		if not nosas:   types_to_process += ['sas']
+		if not nostata: types_to_process += ['stata']
+
+	dds_files = {
+		'stata' : Path(f"{outdir}/ARCHIVE/set{studynum}-{part}.do"),
+		'spss'  : Path(f"{outdir}/ARCHIVE/set{studynum}-{part}.sps"),
+		'sas'   : Path(f"{outdir}/ARCHIVE/set{studynum}-{part}.sas"),
+	}
+
+	dct_files = {
+		'stata' : Path(f"{outdir}/ARCHIVE/set{studynum}-{part}.dct"),
+	}
+
+	pgm_files = {
+		'stata' : Path(f"{outdir}/STATFILES/ssf{studynum}-{part}.do"),
+		'sas'   : Path(f"{outdir}/STATFILES/ssf{studynum}-{part}.sas"),
+	}
+
+	cfg_lines = cat(f"{studynum}.cfg")
+
+	#-------------------------------------------------------------------------
+	# Title
+	#-------------------------------------------------------------------------
+	title_inf = cfg_lines | grep('^study_title *=') | sed('^.*= *') | upper()  # grep "^study_title *=" "$cfg" | sed 's/^.*= *//' | tr '[a-z]' '[A-Z]'
+	title_inf = title_inf or '[INSERT STUDY NAME]'
+
+	#-------------------------------------------------------------------------
+	# Part info
+	#-------------------------------------------------------------------------
+	ptname = cfg_lines | grep(f'^p{part}_name') | sed('^[^=]*= *') | upper()  # grep '^p'"${part}"'_name' "${cfg}" | sed 's/^[^=]*= *//' | tr '[a-z]' '[A-Z]'
+
+	part_inf = textwrap.wrap(f"(DATASET {part}:  {ptname})", width=60, break_long_words=False)  # echo "(DATASET ${part}:  ${ptname})" | fmt -60
+
+	p1_skipname = cfg_lines.grep('p1_skipname=y|p1_skipname *$', insensitive=True)  # egrep -i 'p1_skipname=y|p1_skipname *$' "${cfg}"
+
+	#-------------------------------------------------------------------------
+	# PRINT SETUP HEADERS
+	#-------------------------------------------------------------------------
+	for type in types_to_process:
+		if type in dds_files: dds = dds_files[type]
+		if type in dct_files: dct = dct_files[type]
+		if type in pgm_files: pgm = pgm_files[type]
+
+		# noinspection PyUnboundLocalVariable
+		dds_file = open(dds, 'w')
+
+		if type == 'spss':
+			print( '*-------------------------------------------------------------------------*', file=dds_file)
+			print( '*                                                                          ', file=dds_file)
+			print(f'*                     SPSS SETUP FILE FOR ICPSR {studynum}                 ', file=dds_file)
+
+		elif type == 'sas':
+			print( '/*-------------------------------------------------------------------------', file=dds_file)
+			print( ' |                                                                         ', file=dds_file)
+			print(f' |                    SAS SETUP FILE FOR ICPSR {studynum}                  ', file=dds_file)
+
+			with open(pgm, 'w') as pgm_file:
+				print( '/*-------------------------------------------------------------------------', file=pgm_file)
+				print( ' |                                                                         ', file=pgm_file)
+				print(f' |             SAS SUPPLEMENTAL SYNTAX FILE FOR ICPSR {studynum}           ', file=pgm_file)
+
+		elif type == 'stata':
+			print( '/**************************************************************************', file=dds_file)
+			print( ' |                                                                         ', file=dds_file)
+			print(f' |                    STATA SETUP FILE FOR ICPSR {studynum}                ', file=dds_file)
+
+			with open(dct, 'w') as dct_file:
+				print( 'dictionary {', file=dct_file)
+				print( '\n*****************************************************************', file=dct_file)
+				print(f'* STATA DICTIONARY FOR ICPSR {studynum}                            ', file=dct_file)
+
+			with open(pgm, 'w') as pgm_file:
+				print( '/*-------------------------------------------------------------------------*', file=pgm_file)
+				print( ' |                                                                          ', file=pgm_file)
+				print(f' |            STATA SUPPLEMENTAL SYNTAX FILE FOR ICPSR {studynum}           ', file=pgm_file)
+
+
+		for field in ('title', 'part'):
+			#-------------------------------------------------------------------------
+			# Skip if field=part and skipname=y (1 part only; no part name)
+			#-------------------------------------------------------------------------
+			if field == "part" and part == 1 and p1_skipname:
+				continue
+			else:
+				info = title_inf if field == 'title' else part_inf
+				info = textwrap.wrap(info, width=60, break_long_words=False)  #  eval "echo \$${field}_inf" | fmt -60
+				info = Text(info)
+
+				def center_with_left_pad(line, width=72):
+					"""
+					Center-justifies each line of text, with a consistent left-hand margin.
+
+					Example:
+						>>> print(text.transform(pad, 40))
+						 |         this is the first line
+						 |         this is the second line
+						 |          test line followed by
+						 |a much longer test line that exceeds the padding limit for the file
+					"""
+
+					padding = int( (len(line) + width + 1) / 2 )  # Odd number of characters? pad one more to right than left
+					return '{:>{pad}}'.format(line, pad=padding)
+
+				leftstring = '* ' if type == 'spss' else ' |'
+				left_padded = info.transform(center_with_left_pad).prefix(leftstring)
+				left_padded >> dds_file
+
+				if type != "spss":
+					left_padded >> pgm
+
+				if type == "stata":
+					info.prefix('* ') >> dct
+
+		if type == "spss":
+			print('* ', file=dds_file)
+		else:
+			print(' |', file=dds_file)
+			print(' |', file=pgm_file)
+
+		if type == "stata":
+			mprint('''
+					*
+					* Warning: Edit this file at your own risk
+					*
+					*****************************************************************
+					
+				''',
+				file=dct_file
+			)
+
+		dds_file.close()
+
+
+
+def _4b_tweak_sas(outdir:PathLike, tmpout:PathLike):
+	""" Standardizes SDA DDS output to Progen-style DDS and standardize filenames per ICPSR naming conventions. """
+
+	studynum, part = outdir.split('-')
+
+	scriptpath = Path('/opt/hermes')
+
+	sasdds    = Path(f'{outdir}/ARCHIVE/set{studynum}-{part}.sas')
+	companion = Path(f'{outdir}/STATFILES/ssf{studynum}-{part}.sas')
+
+	procfmt  = Path(f'{tmpout}/proc_fmt')
+	numfmts  = Path(f'{tmpout}/numfmts')
+	fmts     = Path(f'{tmpout}/fmt')
+
+	tmpsas = Path(f'{tmpout}/sa{studynum}-{part}.tmp')
+	tmpsas = cat(tmpsas)
+	lrecl = tmpsas | grep('LRECL=.*\.') | sed('s/[^0-9]//g')  # grep 'LRECL=.*\.' "$tmpsas" | sed 's/[^0-9]//g'
+
+	cfg = Path(f'{studynum}.cfg')
+	nonhermes = grep('nonhermes', file=cfg)
+
+	#-------------------------------------------------------------------------
+	# Look for existing sections
+	#-------------------------------------------------------------------------
+	if os.path.isfile(procfmt):
+		procformat = True
+	else:
+		procformat = Text([ tmpsas[idx:idx+2] for idx,line in enumerate(tmpsas) if match('^PROC *FORMAT', line) ])  # grep -A1 '^PROC *FORMAT' "$tmpsas"
+		procformat = match('^ +VALUE ', procformat[-1])  # tail -1 | grep '^  *VALUE '
+
+	varlabels = tmpsas | grep('^ *LABEL')
+
+	missvals  = tmpsas | grep('^IF \(.+ [<>]*= .+\) THEN .+ =', insensitive=True) | \
+						 grep("^IF \([^ ]+ = ' '\) THEN [^ ]+ = '';", invert=True)    # egrep -i '^IF \(.+ [<>]*= .+\) THEN .+ =' "$tmpsas" | egrep -v "^IF \([^ ]+ = ' '\) THEN [^ ]+ = '';"`
+
+	if os.path.isfile(fmts):
+		formats = True
+	else:
+		formats = tmpsas | grep('^ *FORMAT [^ ][^ ]* [^ ][^ ]*\.')  # grep '^ *FORMAT [^ ][^ ]* [^ ][^ ]*\.' "$tmpsas"
+
+	#-------------------------------------------------------------------------
+	# Add rest of SAS header, customizing study and part numbers
+	#-------------------------------------------------------------------------
+	if nonhermes:
+		hdr = 'sashdr_retro.txt'
+	else:
+		hdr = 'sashdr.txt'
+
+	hdr_text = cat(Path(f"{scriptpath}/{hdr}"))
+	hdr_text | sed('NNNNN', studynum) | sed('QQQQ', part) >> sasdds
+
+	if missvals or os.path.isfile(numfmts):
+		cat(Path(f'{scriptpath}/companion.sas')) >> companion
+	else:
+		os.remove(companion)
+
+	#-------------------------------------------------------------------------
+	# SAS SYNTAX
+	#-------------------------------------------------------------------------
+	#-------------------------------------------------------------------------
+	# PROC FORMAT
+	#-------------------------------------------------------------------------
+	sasdds_file = open(sasdds, 'a')
+	if procformat and not os.path.isfile(numfmts):
+		print("\n* SAS PROC FORMAT;\n", file=sasdds_file)
+		print( "/*", file=sasdds_file)
+
+		if os.path.isfile(procfmt):
+			with open(procfmt) as in_file:
+				print(in_file.read(), file=sasdds_file)
+		else:
+			lines = tmpsas | lines_between('PROC *FORMAT', 'RUN; *$')  # sed -n '/PROC *FORMAT/,/RUN; *$/p' "$tmpsas"
+			lines =  lines |  sed('PROC  FORMAT LIB=LIBRARY', 'PROC FORMAT')  # sed 's/PROC  FORMAT LIB=LIBRARY/PROC FORMAT/'
+			lines =  lines | grep('^RUN;', invert=True)  # grep -v '^RUN;'
+			lines >> sasdds_file
+
+		print("*/", file=sasdds_file)
+
+	#-------------------------------------------------------------------------
+	# INFILE, INPUT STATEMENTS
+	#-------------------------------------------------------------------------
+	print("\n\n* SAS DATA, INFILE, INPUT STATEMENTS;", file=sasdds_file)
+
+	print("\nDATA;", file=sasdds_file)
+	print(f'INFILE "data-filename" LRECL={lrecl};', file=sasdds_file)
+
+	lines = tmpsas | lines_between('INFILE INDATA.*;', ';')  # sed -n '/INFILE INDATA.*;/,/;/p' "$tmpsas"
+	lines =  lines | grep('INFILE INDATA', invert=True)  # grep -v 'INFILE INDATA'
+	lines =  lines |  sed('^ *INPUT *$', 'INPUT')  # sed 's/^ *INPUT *$/INPUT/'
+	lines =  lines |  sed('#1 ', '   ')
+	lines >> sasdds_file
+
+	#-------------------------------------------------------------------------
+	# LABEL STATEMENT
+	#-------------------------------------------------------------------------
+	if varlabels:
+		print("\n\n* SAS LABEL STATEMENT;\n", file=sasdds_file)
+
+		lines = tmpsas | lines_between('^ *LABEL', '^ *; *$')  # sed -n '/^ *LABEL/,/^ *; *$/p' "$tmpsas"
+		lines =  lines | sed('^ *LABEL', 'LABEL')  # sed 's/^ *LABEL/LABEL/'
+		lines =  lines | sed('$', ' ')  # sed 's/$/ /'
+		lines >> sasdds_file
+
+	#-------------------------------------------------------------------------
+	# INSERT DATA STEP IN COMPANION FILE, IF APPLICABLE
+	#-------------------------------------------------------------------------
+	if os.path.isfile(companion):
+
+		companion_text = cat(companion)
+
+		with open(companion, 'a') as companion_file:
+			#-------------------------------------------------------------------------
+			# Also, insert proc format if number of formats exceeded the SAS limit of
+			# 4096.
+			#-------------------------------------------------------------------------
+
+			if os.path.isfile(numfmts):
+				companion_text += dedent(f"""
+											* SAS PROC FORMAT;
+											
+											/*
+											{cat(procfmt)}
+											*/
+											"""
+				                         )
+
+			companion_text += '\n* SAS DATA STEP;'
+			companion_text += 'DATA;\nSET SAS-dataset ;\n'
+
+	#-------------------------------------------------------------------------
+	# MISSING VALUES
+	#-------------------------------------------------------------------------
+	if missvals:
+		print("\n\n* USER-DEFINED MISSING VALUES RECODE TO SAS SYSMIS;\n", file=sasdds_file)
+
+		print("/*", file=sasdds_file)
+
+		lines = tmpsas | lines_between('IF .*= *\. *;', 'PROC DATASETS')  # ed -n '/IF .*= *\. *;/,/PROC DATASETS/p' "$tmpsas"
+		lines =  lines | grep('PROC DATASETS', invert=True)  # grep -v 'PROC DATASETS'
+		lines =  lines | grep('^ *$', invert=True)  # grep -v '^ *$'
+		lines =  lines |  sed('^', '   ')  # sed 's/^/   /'
+		mprint(*lines, file=sasdds_file)
+
+		print("*/", file=sasdds_file)
+
+		if os.path.isfile(companion):
+			with open(companion, 'a') as companion_file:
+				print(file=companion_file)
+				with open(sasdds) as in_file:
+					sas_lines = lines_between(in_file.read(), 'USER-DEFINED', '\*\/')  # sed -n '/USER-DEFINED/,/\*\//p' "$sasdds"
+					mprint(*sas_lines, file=companion_file)
+
+	#-------------------------------------------------------------------------
+	# SAS FORMAT STATEMENT
+	#-------------------------------------------------------------------------
+	if formats:
+		if not os.path.isfile(numfmts):
+			print("\n\n* SAS FORMAT STATEMENT;\n", file=sasdds_file)
+
+			pritn("/*", file=sasdds_file)
+
+			if os.path.isfile(fmts):
+				print(fmts.read_text(), file=sasdds_file)
+			else:
+				lines = lines_between(tmpsas.read_text(), '^ *FORMAT', ';')  # sed -n '/^ *FORMAT/,/;/p' "$tmpsas"
+				lines = lines_between(lines, 'min and max', '\Z', remove=True)  # sed '/min and max/,$d'
+				lines = grep(lines, '.')  # grep '.'
+				mprint(*lines, sasdds_file)
+
+			print("*/", file=sasdds_file)
+		else:
+			#-------------------------------------------------------------------------
+			# Also, insert format statement if number of formats exceeded the SAS
+			# limit of 4096.
+			#-------------------------------------------------------------------------
+			with open(companion, 'a') as companion_file:
+				print(companion)
+				print( "* SAS FORMAT STATEMENT;", companion)
+				print(companion)
+				print( "/*", companion)
+				print(fmts.read_text(), companion)
+				print( "*/", companion)
+
+	#-------------------------------------------------------------------------
+	# RUN COMMAND
+	#-------------------------------------------------------------------------
+	print("\nRUN ;", file=sasdds_file)
+
+	if os.path.isfile(companion):
+		with open(companion) as companion_file:
+			print("\nRUN ;", file=companion_file)
+
+	sasdds_file.close()
+
+
+
+def _4b_tweak_spss(outdir:PathLike):
+	""" Cleans and customizes SPSS DDS files generated by module _3_makedds. """
+	return shell.run('4b_tweakspss.sh', outdir)
+
+	# PATH=/usr/bin:/bin:/opt/SPSS/bin:/opt/icpsr/bin
+	#
+	# outdir={1}
+	# scriptpath=/opt/hermes
+	# studynum=`print("{outdir}" | cut -d'-' -f1`)
+	# part=`print("{outdir}" | cut -d'-' -f2`)
+	# tmpspss=${tmpout}/sp"{studynum}-{part}".tmp
+	# spssdds="{outdir}"/ARCHIVE/set"{studynum}-{part}".sps
+	# lrecl=`grep LRECL= "{tmpspss}" | sed 's/[^0-9]//g'`
+	# cfg="{studynum}".cfg
+	# nonhermes=`grep nonhermes {cfg}`
+	# mval_sps=${tmpout}/mval.sps
+	# varlevels=${tmpout}/varlevels
+	# formats=${tmpout}/reapply_print.sps
+	# formats_pres=${tmpout}/spss_reapply_pres.sps
+	#
+	# #-------------------------------------------------------------------------
+	# # Look for existing sections
+	# #-------------------------------------------------------------------------
+	#
+	# varlabs=`grep '^VARIABLE LABELS' "{tmpspss}"`
+	# vallabs=`grep -A1 '^VALUE LABELS' "{tmpspss}" | tail -1 | grep '[^ \.]'`
+	#
+	# if [ -s "{mval_sps}" ]:
+	# 		missvals=y
+	#
+	# #-------------------------------------------------------------------------
+	# # Add rest of SPSS header, customizing study and part numbers
+	# #-------------------------------------------------------------------------
+	#
+	# if [ "{nonhermes}" ]:
+	# 		hdr=spsshdr_retro.txt
+	# else:
+	# 		hdr=spsshdr.txt
+	#
+	# sed "s/NNNNN/{studynum}/" "{scriptpath}/{hdr}" | sed "s/QQQQ/{part}/" >>, file="{spssdds}"
+	#
+	# #-------------------------------------------------------------------------
+	# # SPSS SYNTAX
+	# #-------------------------------------------------------------------------
+	#
+	# #-------------------------------------------------------------------------
+	# # FILE HANDLE AND DATA LIST
+	# #-------------------------------------------------------------------------
+	#
+	# print(>>, file="{spssdds}")
+	# print("* SPSS FILE HANDLE AND DATA LIST COMMANDS." >>, file="{spssdds}")
+	# print(>>, file="{spssdds}")
+	#
+	# print('FILE HANDLE DATA / NAME="data-filename" LRECL='"{lrecl}." >>, file="{spssdds}")
+	# print('DATA LIST FILE=DATA /' >>, file="{spssdds}")
+	#
+	# #-------------------------------------------------------------------------
+	# # Copy data list from SDA SPSS output.  Non-Hermes applications may
+	# # involve card image data.  Leave the card numbers in the output if
+	# # applicable.
+	# #-------------------------------------------------------------------------
+	#
+	# cards=`sed -n '/^DATA LIST/,/^  *\. *$/p' "{tmpspss}" | grep '^ *\/[2-9] '`
+	#
+	# if [ "{cards}" ]:
+	# 		sed -n '/^DATA LIST/,/^  *\. *$/p' "{tmpspss}" | grep '.' | grep -v 'DATA LIST' | grep -v 'FILE=.x.'  >>, file="{spssdds}"
+	# else:
+	# 		sed -n '/^DATA LIST/,/^  *\. *$/p' "{tmpspss}" | grep '.' | grep -v 'DATA LIST' | grep -v 'FILE=.x.' | \
+	# 			 sed 's/\/1/  /' >>, file="{spssdds}"
+	#
+	# #-------------------------------------------------------------------------
+	# # Realign variables on 1st line of data list if only 2 variables
+	# #-------------------------------------------------------------------------
+	#
+	# oldline1=`grep -A1 '^DATA LIST FILE=DATA' "{spssdds}" | tail -1`
+	# numvars=`print("{oldline1}" | splitit | wc -l | sed 's/ //g'`)
+	#
+	# if [ "{numvars}" -eq 2 ]:
+	# 		width=`print("{oldline1}" | wc -L | sed 's/ //g'`)
+	#
+	# 		leftspace=`expr 48 - "{width}"`
+	#
+	# 		leftstring='|'
+	#
+	# 		#-------------------------------------------------------------------------
+	# 		# Left pad
+	# 		#-------------------------------------------------------------------------
+	#
+	# 		i=1
+	#
+	# 		while [ "{i}" -le "{leftspace}" ]
+	# 				leftstring="{leftstring} "
+	# 				i=`expr "{i}" + 1`
+	#
+	# 		mv  "{spssdds}" "{spssdds}".old
+	# 		sed "s#^ *\({oldline1}\)#{leftstring}\1#" "{spssdds}".old  | sed 's/^|//' > "{spssdds}"
+	# 		rm "{spssdds}".old
+	#
+	#
+	# #-------------------------------------------------------------------------
+	# # VARIABLE LABELS
+	# #-------------------------------------------------------------------------
+	# if [ "{varlabs}" ]:
+	# 		print(>>, file="{spssdds}")
+	# 		print("* SPSS VARIABLE LABELS COMMAND" >>, file="{spssdds}")
+	# 		print(>>, file="{spssdds}")
+	#
+	# 		#-------------------------------------------------------------------------
+	# 		# Wrap long labels
+	# 		#-------------------------------------------------------------------------
+	# 		varlabels=`sed -n '/^VARIABLE LABELS/,/^ *\. *$/p' "{tmpspss}"`
+	# 		longlabels=`print("{varlabels}" | grep -n '^.\{256,\}'`)
+	# 		lastline=`print("{varlabels}" | wc -l | sed 's/ //g'`)
+	#
+	# 		if [ not "{longlabels}" ]:
+	# 				print("{varlabels}" >>, file="{spssdds}")
+	# 		else:
+	# 				start=1
+	# 				print("{longlabels}" | while read longline)
+	# 						longnum=`print("{longline}" | cut -d: -f1`)
+	# 						flabel=`print("{longline}" | sed 's/^[0-9]\{1,\}://' | sed 's| /$|/|' | fmt -150`)
+	# 						end=`expr "{longnum}" - 1`
+	# 						check=`expr "{start}" - 1`
+	#
+	# 						if [ "{check}" -ne "{end}" ]:
+	# 								print("{varlabels}" | sed -n "{start},{end}"'p' >>, file="{spssdds}")
+	#
+	# 						#-------------------------------------------------------------------------
+	# 						# How many lines in wrapped label?
+	# 						#-------------------------------------------------------------------------
+	# 						lablines=`print("{flabel}" | wc -l | sed 's/  *//'`)
+	#
+	# 						#-------------------------------------------------------------------------
+	# 						# First line of individual label only needs a + at the end
+	# 						#-------------------------------------------------------------------------
+	# 						print("{flabel}" | head -1 | sed "s/\$/'+/" >>, file="{spssdds}")
+	#
+	# 						#-------------------------------------------------------------------------
+	# 						# Inner lines (if any) need ' at the beginning and + at the end
+	# 						#-------------------------------------------------------------------------
+	# 						if [ "{lablines}" -gt 2 ]:
+	# 								stop=`expr "{lablines}" - 1`
+	#
+	# 								print("{flabel}" | sed -n "2,{stop}"'p' | sed "s/^ */     ' /" | sed "s/'*\$/'+/" >>, file="{spssdds}")
+	#
+	# 						#-------------------------------------------------------------------------
+	# 						# Last line of individual label only needs ' at the beginning unless it
+	# 						# contains only the / variable separator
+	# 						#-------------------------------------------------------------------------
+	# 						separator=`print("{flabel}" | tail -1 | grep '^  */$'`)
+	#
+	# 						if [ "{separator}" ]:
+	# 								print("{flabel}" | tail -1 >>, file="{spssdds}")
+	# 						else:
+	# 								print("{flabel}" | tail -1 | sed "s/^ */     ' /" >>, file="{spssdds}")
+	#
+	# 						#-------------------------------------------------------------------------
+	# 						# Increment start line for next iteration
+	# 						#-------------------------------------------------------------------------
+	# 						start=`expr "{longnum}" + 1`
+	#
+	# 				#-------------------------------------------------------------------------
+	# 				# All done with long labels; print rest of variable labels section
+	# 				#-------------------------------------------------------------------------
+	# 				lastlong=`print("{longlabels}" |  tail -1 | cut -d: -f1`)
+	# 				start=`expr "{lastlong}" + 1`
+	#
+	# 				if [ "{start}" -le "{lastline}" ]:
+	# 						print("{varlabels}" | sed -n "{start},{lastline}"'p' >>, file="{spssdds}")
+	#
+	# #-------------------------------------------------------------------------
+	# # VALUE LABELS
+	# #-------------------------------------------------------------------------
+	# if [ "{vallabs}" ]:
+	# 		print(>>, file="{spssdds}")
+	# 		print(>>, file="{spssdds}")
+	# 		print("* SPSS VALUE LABELS COMMAND." >>, file="{spssdds}")
+	# 		print(>>, file="{spssdds}")
+	# 		sed -n '/^VALUE LABELS/,/\. *$/p' "{tmpspss}"  >>, file="{spssdds}"
+	#
+	# #-------------------------------------------------------------------------
+	# # MISSING VALUES
+	# #-------------------------------------------------------------------------
+	# if [ "{missvals}" ]:
+	# 		print(>>, file="{spssdds}")
+	# 		print("* SPSS MISSING VALUES COMMAND." >>, file="{spssdds}")
+	# 		print(>>, file="{spssdds}")
+	#
+	# 		print("* MISSING VALUES" >>, file="{spssdds}")
+	# 		sed 's/ and / /' "{mval_sps}" | sed 's/through Highest/thru hi/' | sed 's/Lowest through/lo thru/' >>, file="{spssdds}"
+	# 		print('   .'  >>, file="{spssdds}")
+	#
+	# print(>>, file="{spssdds}")
+	# print("EXECUTE." >>, file="{spssdds}")
+	#
+	# #-------------------------------------------------------------------------
+	# # VARIABLE LEVELS
+	# #-------------------------------------------------------------------------
+	# if [ -f "{varlevels}" ]:
+	# 		print(>>, file="{spssdds}")
+	# 		print("* SPSS VARIABLE LEVEL COMMAND." >>, file="{spssdds}")
+	#
+	# 		for level in scale nominal ordinal:
+	# 				 varlist=`grep ";{level}" "{varlevels}" | cut -d\; -f1 | sed 's/^/   /'`
+	#
+	# 				 if [ "{varlist}" ]:
+	# 						 print(>>, file="{spssdds}")
+	# 						 print("VARIABLE LEVEL" >>, file="{spssdds}")
+	# 						 print("{varlist}" >>, file="{spssdds}")
+	# 						 print("    ({level})." >>, file="{spssdds}")
+	#
+	# #-------------------------------------------------------------------------
+	# # REAPPLY ORIGINAL FORMATS IF RUNNING IN PRESERVE FORMAT MODE (-p)
+	# #-------------------------------------------------------------------------
+	# if [ -f "{formats_pres}" ]:
+	# 		has_fmts=`egrep -v '^FORMAT|^ +\.$' "{formats_pres}"`
+	# 		if [ "{has_fmts}" ]:
+	# 				print(>>, file="{spssdds}")
+	# 				print("* SPSS FORMAT COMMAND." >>, file="{spssdds}")
+	# 				print(>>, file="{spssdds}")
+	# 				cat "{formats_pres}" >>, file="{spssdds}"
+	#
+	# #-------------------------------------------------------------------------
+	# # OPTIMIZE PRINT FORMATS
+	# #-------------------------------------------------------------------------
+	# if [ -f "{formats}" ]:
+	# 		has_fmts=`egrep -v 'PRINT FORMAT|^ +\.$' "{formats}"`
+	# 		if [ "{has_fmts}" ]:
+	# 				print(>>, file="{spssdds}")
+	# 				print("* SPSS PRINT FORMAT COMMAND." >>, file="{spssdds}")
+	# 				print(>>, file="{spssdds}")
+	# 				cat "{formats}" >>, file="{spssdds}"
+	#
+	# #-------------------------------------------------------------------------
+	# # OUTFILE SYNTAX
+	# #-------------------------------------------------------------------------
+	# cat ${scriptpath}/outfile.sps >>, file="{spssdds}"
+
+
+
+def _4b_tweak_stata(outdir:PathLike):
+	""" Cleans and customizes Stata DDS files generated by module _3_makedds. """
+	return shell.run('4b_tweakstata.sh', outdir)
+
+	# PATH=/usr/bin:/bin:/opt/SPSS/bin:/opt/newturn/bin
+	#
+	# outdir={1}
+	# scriptpath=/opt/hermes
+	# studynum=`print("{outdir}" | cut -d'-' -f1`)
+	# part=`print("{outdir}" | cut -d'-' -f2`)
+	# tmpstata=${tmpout}/st"{studynum}-{part}".tmp
+	# statadds="{outdir}"/ARCHIVE/set"{studynum}-{part}"
+	# ddl="{outdir}"/SDA/ddl"{studynum}-{part}".txt
+	# companion="{outdir}"/STATFILES/ssf"{studynum}-{part}".do
+	# lrecl=`grep 'LRECL=.*\.' "{tmpstata}" | sed 's/[^0-9]//g'`
+	# ascii="{outdir}"/ARCHIVE/da"{studynum}-{part}".txt
+	# reformat=${tmpout}/reapply_print.do
+	#
+	# if [ not "{lrecl}" ]:
+	# 		lrecl=`grep 'Record length: *[0-9]*' "{tmpstata}" | sed 's/[^0-9]//g'`
+	#
+	# #-----------------------------------------------------------------
+	# # Check for presence of value labels, missing values
+	# #-----------------------------------------------------------------
+	#
+	# vallabs=`grep 'label define' "{tmpstata}"`
+	# mvals=`grep 'replace .* = [\."]"* if .*' "{tmpstata}" | egrep -v 'replace [^ ]+ = "" if \([^ ]+ == "."\)'`
+	#
+	# cfg="{studynum}".cfg
+	# nonhermes=`grep nonhermes {cfg}`
+	#
+	# #-------------------------------------------------------------------------
+	# # Add next chunk of Stata header, customizing study and part numbers
+	# #-------------------------------------------------------------------------
+	# hdr=statahdr.txt
+	#
+	# if [ "{nonhermes}" ]:
+	# 		hdr=statahdr_retro.txt
+	#
+	# lrecl=`head -1 < {ascii} | wc -L`
+	#
+	# numvars=`grep '^name *= *' {ddl} | wc -l | sed 's/[^0-9]//g'`
+	#
+	# if [ "{numvars}" -le 5000 ]:
+	# 		sed "s/NNNNN/{studynum}/" "{scriptpath}/{hdr}"  | sed "s/QQQQ/{part}/"  | grep -v 'set maxvar' >>, file="{statadds}".do
+	# else:
+	# 		maxvars=`expr "{numvars}" + 10`
+	# 		sed "s/NNNNN/{studynum}/" "{scriptpath}/{hdr}"  | sed "s/QQQQ/{part}/"  | \
+	# 		sed "s/set maxvar 5000 \(.* to\) 5000/set maxvar {maxvars} \1 {maxvars}/" >>, file="{statadds}".do
+	#
+	# section=3
+	#
+	# #-------------------------------------------------------------------------
+	# # Reformat to optimized widths
+	# #-------------------------------------------------------------------------
+	# if [ -f "{reformat}" ]:
+	# 		printf '/********************************************************************\n\n' >>, file="{statadds}".do
+	#
+	# 		printf " Section {section}: Reformat\n\n"                                               >>, file="{statadds}".do
+	#
+	# 		print('  This section applies optimized formats to variables.' >>, file="{statadds}".do)
+	# 		print(>>, file="{statadds}".do)
+	#
+	# 		printf '*********************************************************************/\n\n'     >>, file="{statadds}".do
+	#
+	# 		cat "{reformat}" >>, file="{statadds}".do
+	# 		print(>>, file="{statadds}".do)
+	# 		print(>>, file="{statadds}".do)
+	#
+	# 		section=`expr "{section}" + 1`
+	#
+	#
+	# #-------------------------------------------------------------------------
+	# # Add value labels comments if applicable
+	# #-------------------------------------------------------------------------
+	#
+	# if [ "{vallabs}" ]:
+	# 		printf '/*********************************************************\n\n' >>, file="{statadds}".do
+	#
+	# 		print("Section {section}: Value Label Definitions" >>, file="{statadds}".do)
+	# 		print('This section defines labels for the individual values of each variable.'  >>, file="{statadds}".do)
+	# 		print('We suggest that users do not modify this section.' >>, file="{statadds}".do)
+	#
+	# 		printf '\n**********************************************************/\n\n'  >>, file="{statadds}".do
+	#
+	# 		section=`expr "{section}" + 1`
+	#
+	# #-------------------------------------------------------------------------
+	# # Split Stata DDS file into .do and .dct files.  Replace any double quotes
+	# # in the label with single quotes to avoid Stata syntax errors.
+	# #-------------------------------------------------------------------------
+	#
+	# datalabel=`grep '^title *=' {ddl} | cut -d= -f2 | tr '"' "'" | sed 's/^ */"/' | sed 's/ *$/"/'`
+	#
+	# print("label data ${datalabel}" >>, file="{statadds}".do)
+	# print(>>, file="{statadds}".do)
+	#
+	# sed -n '/^#delimit/,/delimit cr/p' "{tmpstata}" >>, file="{statadds}".do
+	# print(>>, file="{statadds}".do)
+	#
+	# #-------------------------------------------------------------------------
+	# # Missing values, if applicable
+	# #-------------------------------------------------------------------------
+	#
+	# if [ "{mvals}" ]:
+	#
+	# 		cat "{scriptpath}"/companion.do >>, file="{companion}"
+	#
+	# 		printf '\n/***************************************************************************\n\n' >>, file="{statadds}".do
+	#
+	# 		printf " Section {section}: Missing Values\n\n"  >>, file="{statadds}".do
+	#
+	# 		print(' This section will replace numeric missing values (i.e., -9) with generic'  >>, file="{statadds}".do)
+	# 		print(' system missing ".".  By default the code in this section is commented out.' >>, file="{statadds}".do)
+	# 		print(' Users wishing to apply the generic missing values should remove the comment' >>, file="{statadds}".do)
+	# 		print(' at the beginning and end of this section.  Note that Stata allows you to' >>, file="{statadds}".do)
+	# 		print(' specify up to 27 unique missing value codes.'                             >>, file="{statadds}".do)
+	# 		print(>>, file="{statadds}".do)
+	#
+	# 		printf '****************************************************************/\n\n'        >>, file="{statadds}".do
+	#
+	# 		print('/*'                                                                         >>, file="{statadds}".do)
+	#
+	# 		sed -n '/^replace/,/^dictionary using Y/p' "{tmpstata}" | grep -v 'dictionary using Y'  >>, file="{statadds}".do
+	# 		sed -n '/^replace/,/^dictionary using Y/p' "{tmpstata}" | grep -v 'dictionary using Y'  >>, file="{companion}"
+	#
+	# 		print('*/'                                                                         >>, file="{statadds}".do)
+	#
+	# 		section=`expr "{section}" + 1`
+	# else:
+	# 		rm "{companion}"
+	#
+	# #-------------------------------------------------------------------------
+	# # Outfile syntax
+	# #-------------------------------------------------------------------------
+	#
+	# printf '/********************************************************************\n\n' >>, file="{statadds}".do
+	#
+	# printf " Section {section}: Save Outfile\n\n"                                               >>, file="{statadds}".do
+	#
+	# print('  This section saves out a Stata system format file.  There is no reason to' >>, file="{statadds}".do)
+	# printf '  modify it if the macros in Section 1 were specified correctly.\n\n'          >>, file="{statadds}".do
+	#
+	# printf '*********************************************************************/\n\n'     >>, file="{statadds}".do
+	#
+	# printf "save \`outfile', replace\n\n"                                                     >>, file="{statadds}".do
+	#
+	# #-------------------------------------------------------------------------
+	# # Rest of Stata .dct file
+	# #-------------------------------------------------------------------------
+	#
+	# sed -n '/^.lines([0-9]\{1,\})/,{p}' "{tmpstata}" | sed 's/\(column.*\)long\(.*%1[0-9]\)/\1double\2/' >>, file="{statadds}".dct
+
+
+
+
+# if run as script, run with command line args
+if __name__ == '__main__':
+	if len(argv) != 2:
+		mprint("""
+			Usage:  4_ddstweak.sh [study_number-part_number]
+					   e.g., 4_ddstweak.sh 1234-3
+			
+					Exiting...
+		""")
+		exit()
+	else:
+		run(argv[1])
