# coding: utf-8

"""
    Versatile Data Kit Control Service API

    The Data Jobs API of Versatile Data Kit Control Service. Data Jobs allows Data Engineers to implement automated pull ingestion (E in ELT) and batch data transformation into a database (T in ELT). See also https://github.com/vmware/versatile-data-kit/wiki/Introduction The API has resource-oriented URLs, JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs. The API enables creating, deploying, managing and executing Data Jobs in the runtime environment.<br> <br> ![](https://github.com/vmware/versatile-data-kit/wiki/vdk-data-job-lifecycle-state-diagram.png) <br> The API reflects the usual Data Job Development lifecycle:<br> <li> Create a new data job (webhook to further configure the job, e.g authorize its creation, setup permissions, etc). <li> Download keytab. Develop and run the data job locally. <li> Deploy the data job in cloud runtime environment to run on a scheduled basis. <br><br> If Authentication is enabled, pass OAuth2 access token in HTTP header 'Authorization: Bearer [access-token-here]' (https://datatracker.ietf.org/doc/html/rfc6750). <br The API promotes some best practices (inspired by https://12factor.net): <li> Explicitly declare and isolate dependencies. <li> Strict separation of configurations from code. Configurations vary substantially across deploys, code does not. <li> Separation between the build, release/deploy, and run stages. <li> Data Jobs are stateless and share-nothing processes. Any data that needs to be persisted must be stored in a stateful backing service (e.g IProperties). <li> Implementation is assumed to be atomic and idempotent - should be OK for a job to fail somewhere in the middle; subsequent restart should not cause data corruption. <li> Keep development, staging, and production as similar as possible. <br><br> <b>API Evolution</b><br> In the following sections, there are some terms that have a special meaning in the context of the APIs. <br><br> <li> <i>Stable</i> - The implementation of the API has been battle-tested (has been in production for some time). The API is a subject to semantic versioning model and will follow deprecation policy. <li> <i>Experimental</i> - May disappear without notice and is not a subject to semantic versioning. Implementation of the API is not considered stable nor well tested. Generally this is given to clients to experiment within testing environment. Must not be used in production. <li> <i>Deprecated</i> - API is expected to be removed within next one or two major version upgrade. The deprecation notice/comment will say when the API will be removed and what alternatives should be used instead.  # noqa: E501

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictStr

from typing import Optional, Union

from taurus_datajob_api.models.data_job import DataJob
from taurus_datajob_api.models.data_job_query_response import DataJobQueryResponse

from taurus_datajob_api.api_client import ApiClient
from taurus_datajob_api.api_response import ApiResponse
from taurus_datajob_api.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DataJobsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def data_job_create(self, team_name : Annotated[StrictStr, Field(..., description="The Team which owns the Data Job")], data_job : DataJob, name : Annotated[Optional[StrictStr], Field(description="The Name of the Data Job")] = None, **kwargs) -> None:  # noqa: E501
        """Creates a new Data Job | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i> | Creates a new Data Job.<br> The name of the Data job should comply to the following naming convention:<br> <li>should start with a letter <li>50 characters at most <li>5 characters at least <li>should contain only lowercase alphanumeric symbols and dash [a-z0-9\\-] <br><br> When succesfully created clients can download the keytab associated with the Data Job to run it locally.<br> To deploy so that it can be executed reguarly in the runtime environment use /data-jobs/for-team/{team_name}/jobs/{job_name}/deployments API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_create(team_name, data_job, name, async_req=True)
        >>> result = thread.get()

        :param team_name: The Team which owns the Data Job (required)
        :type team_name: str
        :param data_job: (required)
        :type data_job: DataJob
        :param name: The Name of the Data Job
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the data_job_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.data_job_create_with_http_info(team_name, data_job, name, **kwargs)  # noqa: E501

    @validate_arguments
    def data_job_create_with_http_info(self, team_name : Annotated[StrictStr, Field(..., description="The Team which owns the Data Job")], data_job : DataJob, name : Annotated[Optional[StrictStr], Field(description="The Name of the Data Job")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Creates a new Data Job | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i> | Creates a new Data Job.<br> The name of the Data job should comply to the following naming convention:<br> <li>should start with a letter <li>50 characters at most <li>5 characters at least <li>should contain only lowercase alphanumeric symbols and dash [a-z0-9\\-] <br><br> When succesfully created clients can download the keytab associated with the Data Job to run it locally.<br> To deploy so that it can be executed reguarly in the runtime environment use /data-jobs/for-team/{team_name}/jobs/{job_name}/deployments API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_create_with_http_info(team_name, data_job, name, async_req=True)
        >>> result = thread.get()

        :param team_name: The Team which owns the Data Job (required)
        :type team_name: str
        :param data_job: (required)
        :type data_job: DataJob
        :param name: The Name of the Data Job
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'team_name',
            'data_job',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_job_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['team_name']:
            _path_params['team_name'] = _params['team_name']


        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['data_job'] is not None:
            _body_params = _params['data_job']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/data-jobs/for-team/{team_name}/jobs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def data_job_delete(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name")], **kwargs) -> None:  # noqa: E501
        """Delete Data Job | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i> | Delete Data Job including its state (properties) and deployments. Currently executing Data Jobs will be left to finish.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_delete(team_name, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the data_job_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.data_job_delete_with_http_info(team_name, job_name, **kwargs)  # noqa: E501

    @validate_arguments
    def data_job_delete_with_http_info(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Data Job | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i> | Delete Data Job including its state (properties) and deployments. Currently executing Data Jobs will be left to finish.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_delete_with_http_info(team_name, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'team_name',
            'job_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_job_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['team_name']:
            _path_params['team_name'] = _params['team_name']

        if _params['job_name']:
            _path_params['job_name'] = _params['job_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/data-jobs/for-team/{team_name}/jobs/{job_name}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def data_job_keytab_download(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name.")], **kwargs) -> bytearray:  # noqa: E501
        """Get data job keytab. | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_keytab_download(team_name, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name. (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the data_job_keytab_download_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.data_job_keytab_download_with_http_info(team_name, job_name, **kwargs)  # noqa: E501

    @validate_arguments
    def data_job_keytab_download_with_http_info(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get data job keytab. | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_keytab_download_with_http_info(team_name, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name. (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'team_name',
            'job_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_job_keytab_download" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['team_name']:
            _path_params['team_name'] = _params['team_name']

        if _params['job_name']:
            _path_params['job_name'] = _params['job_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '400': "Error",
            '404': "Error",
        }

        return self.api_client.call_api(
            '/data-jobs/for-team/{team_name}/jobs/{job_name}/keytab', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def data_job_read(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name")], **kwargs) -> DataJob:  # noqa: E501
        """Retrieves details of an existing Data Job by specifying the name of the Data Job. | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_read(team_name, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DataJob
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the data_job_read_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.data_job_read_with_http_info(team_name, job_name, **kwargs)  # noqa: E501

    @validate_arguments
    def data_job_read_with_http_info(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name")], **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieves details of an existing Data Job by specifying the name of the Data Job. | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_read_with_http_info(team_name, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DataJob, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'team_name',
            'job_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_job_read" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['team_name']:
            _path_params['team_name'] = _params['team_name']

        if _params['job_name']:
            _path_params['job_name'] = _params['job_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "DataJob",
            '404': "Error",
        }

        return self.api_client.call_api(
            '/data-jobs/for-team/{team_name}/jobs/{job_name}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def data_job_team_update(self, team_name : Annotated[StrictStr, Field(..., description="Current Team Name.")], new_team : Annotated[StrictStr, Field(..., description="New Team Name.")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name.")], **kwargs) -> None:  # noqa: E501
        """Update API for Data Jobs team | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i> | Update API for Data Jobs team  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_team_update(team_name, new_team, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Current Team Name. (required)
        :type team_name: str
        :param new_team: New Team Name. (required)
        :type new_team: str
        :param job_name: Data Job Name. (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the data_job_team_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.data_job_team_update_with_http_info(team_name, new_team, job_name, **kwargs)  # noqa: E501

    @validate_arguments
    def data_job_team_update_with_http_info(self, team_name : Annotated[StrictStr, Field(..., description="Current Team Name.")], new_team : Annotated[StrictStr, Field(..., description="New Team Name.")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Update API for Data Jobs team | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i> | Update API for Data Jobs team  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_team_update_with_http_info(team_name, new_team, job_name, async_req=True)
        >>> result = thread.get()

        :param team_name: Current Team Name. (required)
        :type team_name: str
        :param new_team: New Team Name. (required)
        :type new_team: str
        :param job_name: Data Job Name. (required)
        :type job_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'team_name',
            'new_team',
            'job_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_job_team_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['team_name']:
            _path_params['team_name'] = _params['team_name']

        if _params['new_team']:
            _path_params['new_team'] = _params['new_team']

        if _params['job_name']:
            _path_params['job_name'] = _params['job_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/data-jobs/for-team/{team_name}/jobs/{job_name}/team/{new_team}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def data_job_update(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name")], data_job : DataJob, **kwargs) -> None:  # noqa: E501
        """Update Data Job. | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_update(team_name, job_name, data_job, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name (required)
        :type job_name: str
        :param data_job: (required)
        :type data_job: DataJob
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the data_job_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.data_job_update_with_http_info(team_name, job_name, data_job, **kwargs)  # noqa: E501

    @validate_arguments
    def data_job_update_with_http_info(self, team_name : Annotated[StrictStr, Field(..., description="Team Name")], job_name : Annotated[StrictStr, Field(..., description="Data Job Name")], data_job : DataJob, **kwargs) -> ApiResponse:  # noqa: E501
        """Update Data Job. | (Stable)  # noqa: E501

        <i>(Introduced in v1.0)</i>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.data_job_update_with_http_info(team_name, job_name, data_job, async_req=True)
        >>> result = thread.get()

        :param team_name: Team Name (required)
        :type team_name: str
        :param job_name: Data Job Name (required)
        :type job_name: str
        :param data_job: (required)
        :type data_job: DataJob
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'team_name',
            'job_name',
            'data_job'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_job_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['team_name']:
            _path_params['team_name'] = _params['team_name']

        if _params['job_name']:
            _path_params['job_name'] = _params['job_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['data_job'] is not None:
            _body_params = _params['data_job']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/data-jobs/for-team/{team_name}/jobs/{job_name}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def jobs_query(self, team_name : Annotated[StrictStr, Field(..., description="The Team which owns the Data Job")], query : Annotated[Optional[StrictStr], Field(description="Request a GraphQL-like query.")] = None, operation_name : Annotated[Optional[StrictStr], Field(description="If the query is specified and contains several named operations, an operation_name query parameter can be used to control which one should be executed")] = None, variables : Annotated[Optional[StrictStr], Field(description="If query is specified then variables can be sent as a JSON-encoded string in an additional query parameter called variables")] = None, **kwargs) -> DataJobQueryResponse:  # noqa: E501
        """Query Data Jobs details using GraphQL  # noqa: E501

        List data Jobs with GraphQL like query. By choosing which field to be returned you can control the output. You can learn more about the GraphQL queries by visiting [GraphQL official website](https://graphql.org/learn/queries/) Query should be provided as GET parameter, not by POST body. Don't worry about the spaces and tabs Keep in mind that each aditional field <b>could make query response time slower, for instance deployments</b>, it's best if you request only what you need <br/><br/>  The <b>pageNumber</b> and <b>pageSize</b> arguments are required! Page number should be a <b>number greater than 1</b>, and pageSize <b>should be greater than 1</b> (per page) Check the latest example for the full list of supported query fields.<br/><br/>  Simplest query that you could make is to fetch the job names ``` {   jobs(pageNumber: 1, pageSize: 25) {     content {       jobName     }   } } ```  You could also use filtering and sorting function. Filter object has <b>property, pattern and sort</b> fields.<br/> * <b>property</b> points out which field you want to filter, if you point out some other field that is not supported, an invalid response will be return.<br/> * <b>pattern</b> should be a non-empty string which the provided property should contains [ignoring cases], for instance: `starshot` pattern will match <b>import-starshot-sql, StarShot-servers and notify-starshot</b> job names, but it won't match <b>stars-shot-daily-prune`</b> If a pattern string is not provided, then you must atleast provide the property field<br/> * <b>sort</b> should be an enum value - ASC (ascending) or DESC (descending) option [not required, default is ASC] Multiple filters could be applied, but <b>maximum one should contain sorting</b>! ``` {   jobs(     pageNumber: 1,     pageSize: 25,     filter: [{       property: \"jobName\",       pattern: \"starshot\",       sort: DESC     }],   ) {     content {       jobName     }   } } ```  You could also search for a string into the properties that you are requesting, for instance: This query will search for job names, team names and descriptions which contains the provided \"starshot\" string ``` {   jobs(     pageNumber: 1,     pageSize: 25,     search: \"starshot\"   ) {     content {       jobName,       config {         team         description       }     }   } } ```  Data jobs execution could also be searched by providing arguments to the <b>execution</b> field. Same as parent query arguments, the <b>pageNumber</b> and <b>pageSize</b> arguments are required! Page number should be a <b>number greater than 1</b>, and pageSize <b>should be between 1 and 100 results</b> (per page). You can also <b>filter</b> using the similar object structure as the parent query, but currently <b>filtering is not supported</b>, you can only provide field for sorting. This query will search ``` {   jobs(     pageNumber: 1,     pageSize: 25,   ) {     content {       jobName,       deployments {         id         executions(           pageNumber: 1,           pageSize: 5,           filter: [{             teamNameIn: [\"starshot\"]           }],           order: {             property: \"startTime\",               direction: DESC           }         ) {           id           status           startTime           endTime         {       }     }   } } ```  Full example of currently available for fetching fields. Note that if you combine searching and filtering, first it will apply filters and then within filtered jobs it will apply the search, vice versa is currently not supported: ``` {   jobs(     pageNumber: 1,     pageSize: 25,     search: \"daily\",     filter: [{       property: \"jobName\",       pattern: \"import-sql\",     },{       property: \"team\",       pattern: \"starshot\",       sort: DESC     },{       property: \"deployments.enabled\",       pattern: \"enabled\",     }],   ) {     content {       jobName       config {         team         description         sourceUrl         schedule {           scheduleCron           nextRunEpochSeconds         }         contacts {           notifiedOnJobFailureUserError           notifiedOnJobFailurePlatformError           notifiedOnJobSuccess           notifiedOnJobDeploy         }       }       deployments {         id         enabled         jobVersion         mode         executions(           pageNumber: 1,           pageSize: 25,           filter: [{             teamNameIn: [\"starshot\"]           }],           order: {             property: \"startTime\",               direction: DESC           }         ) {           id           type           status           message           startTime           endTime           opId           vkdVersion           jobVersion           jobSchedule           resourcesCpuRequest           resourcesCpuLimit           resourcesMemoryRequest           resourcesMemoryLimit           deployedDate           deployedBy           startedBy           logsUrl         }       }     }     totalPages     totalItems     }   } } ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.jobs_query(team_name, query, operation_name, variables, async_req=True)
        >>> result = thread.get()

        :param team_name: The Team which owns the Data Job (required)
        :type team_name: str
        :param query: Request a GraphQL-like query.
        :type query: str
        :param operation_name: If the query is specified and contains several named operations, an operation_name query parameter can be used to control which one should be executed
        :type operation_name: str
        :param variables: If query is specified then variables can be sent as a JSON-encoded string in an additional query parameter called variables
        :type variables: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DataJobQueryResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the jobs_query_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.jobs_query_with_http_info(team_name, query, operation_name, variables, **kwargs)  # noqa: E501

    @validate_arguments
    def jobs_query_with_http_info(self, team_name : Annotated[StrictStr, Field(..., description="The Team which owns the Data Job")], query : Annotated[Optional[StrictStr], Field(description="Request a GraphQL-like query.")] = None, operation_name : Annotated[Optional[StrictStr], Field(description="If the query is specified and contains several named operations, an operation_name query parameter can be used to control which one should be executed")] = None, variables : Annotated[Optional[StrictStr], Field(description="If query is specified then variables can be sent as a JSON-encoded string in an additional query parameter called variables")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Query Data Jobs details using GraphQL  # noqa: E501

        List data Jobs with GraphQL like query. By choosing which field to be returned you can control the output. You can learn more about the GraphQL queries by visiting [GraphQL official website](https://graphql.org/learn/queries/) Query should be provided as GET parameter, not by POST body. Don't worry about the spaces and tabs Keep in mind that each aditional field <b>could make query response time slower, for instance deployments</b>, it's best if you request only what you need <br/><br/>  The <b>pageNumber</b> and <b>pageSize</b> arguments are required! Page number should be a <b>number greater than 1</b>, and pageSize <b>should be greater than 1</b> (per page) Check the latest example for the full list of supported query fields.<br/><br/>  Simplest query that you could make is to fetch the job names ``` {   jobs(pageNumber: 1, pageSize: 25) {     content {       jobName     }   } } ```  You could also use filtering and sorting function. Filter object has <b>property, pattern and sort</b> fields.<br/> * <b>property</b> points out which field you want to filter, if you point out some other field that is not supported, an invalid response will be return.<br/> * <b>pattern</b> should be a non-empty string which the provided property should contains [ignoring cases], for instance: `starshot` pattern will match <b>import-starshot-sql, StarShot-servers and notify-starshot</b> job names, but it won't match <b>stars-shot-daily-prune`</b> If a pattern string is not provided, then you must atleast provide the property field<br/> * <b>sort</b> should be an enum value - ASC (ascending) or DESC (descending) option [not required, default is ASC] Multiple filters could be applied, but <b>maximum one should contain sorting</b>! ``` {   jobs(     pageNumber: 1,     pageSize: 25,     filter: [{       property: \"jobName\",       pattern: \"starshot\",       sort: DESC     }],   ) {     content {       jobName     }   } } ```  You could also search for a string into the properties that you are requesting, for instance: This query will search for job names, team names and descriptions which contains the provided \"starshot\" string ``` {   jobs(     pageNumber: 1,     pageSize: 25,     search: \"starshot\"   ) {     content {       jobName,       config {         team         description       }     }   } } ```  Data jobs execution could also be searched by providing arguments to the <b>execution</b> field. Same as parent query arguments, the <b>pageNumber</b> and <b>pageSize</b> arguments are required! Page number should be a <b>number greater than 1</b>, and pageSize <b>should be between 1 and 100 results</b> (per page). You can also <b>filter</b> using the similar object structure as the parent query, but currently <b>filtering is not supported</b>, you can only provide field for sorting. This query will search ``` {   jobs(     pageNumber: 1,     pageSize: 25,   ) {     content {       jobName,       deployments {         id         executions(           pageNumber: 1,           pageSize: 5,           filter: [{             teamNameIn: [\"starshot\"]           }],           order: {             property: \"startTime\",               direction: DESC           }         ) {           id           status           startTime           endTime         {       }     }   } } ```  Full example of currently available for fetching fields. Note that if you combine searching and filtering, first it will apply filters and then within filtered jobs it will apply the search, vice versa is currently not supported: ``` {   jobs(     pageNumber: 1,     pageSize: 25,     search: \"daily\",     filter: [{       property: \"jobName\",       pattern: \"import-sql\",     },{       property: \"team\",       pattern: \"starshot\",       sort: DESC     },{       property: \"deployments.enabled\",       pattern: \"enabled\",     }],   ) {     content {       jobName       config {         team         description         sourceUrl         schedule {           scheduleCron           nextRunEpochSeconds         }         contacts {           notifiedOnJobFailureUserError           notifiedOnJobFailurePlatformError           notifiedOnJobSuccess           notifiedOnJobDeploy         }       }       deployments {         id         enabled         jobVersion         mode         executions(           pageNumber: 1,           pageSize: 25,           filter: [{             teamNameIn: [\"starshot\"]           }],           order: {             property: \"startTime\",               direction: DESC           }         ) {           id           type           status           message           startTime           endTime           opId           vkdVersion           jobVersion           jobSchedule           resourcesCpuRequest           resourcesCpuLimit           resourcesMemoryRequest           resourcesMemoryLimit           deployedDate           deployedBy           startedBy           logsUrl         }       }     }     totalPages     totalItems     }   } } ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.jobs_query_with_http_info(team_name, query, operation_name, variables, async_req=True)
        >>> result = thread.get()

        :param team_name: The Team which owns the Data Job (required)
        :type team_name: str
        :param query: Request a GraphQL-like query.
        :type query: str
        :param operation_name: If the query is specified and contains several named operations, an operation_name query parameter can be used to control which one should be executed
        :type operation_name: str
        :param variables: If query is specified then variables can be sent as a JSON-encoded string in an additional query parameter called variables
        :type variables: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DataJobQueryResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'team_name',
            'query',
            'operation_name',
            'variables'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_query" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['team_name']:
            _path_params['team_name'] = _params['team_name']


        # process the query parameters
        _query_params = []
        if _params.get('query') is not None:  # noqa: E501
            _query_params.append(('query', _params['query']))

        if _params.get('operation_name') is not None:  # noqa: E501
            _query_params.append(('operation_name', _params['operation_name']))

        if _params.get('variables') is not None:  # noqa: E501
            _query_params.append(('variables', _params['variables']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "DataJobQueryResponse",
            '400': "DataJobQueryResponseWithError",
        }

        return self.api_client.call_api(
            '/data-jobs/for-team/{team_name}/jobs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
