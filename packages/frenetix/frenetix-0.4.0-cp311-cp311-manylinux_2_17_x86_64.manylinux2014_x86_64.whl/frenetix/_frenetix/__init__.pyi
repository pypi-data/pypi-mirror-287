from collections.abc import Iterator, Mapping, Sequence
from typing import Annotated, overload

from numpy.typing import ArrayLike

from . import trajectory_functions as trajectory_functions


class CartesianPlannerState:
    def __init__(self, pos: Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')], orientation: float, velocity: float, acceleration: float, steering_angle: float) -> None: ...

    @property
    def pos(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    @pos.setter
    def pos(self, arg: Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')], /) -> None: ...

    @property
    def orientation(self) -> float: ...

    @orientation.setter
    def orientation(self, arg: float, /) -> None: ...

    @property
    def velocity(self) -> float: ...

    @velocity.setter
    def velocity(self, arg: float, /) -> None: ...

    @property
    def acceleration(self) -> float: ...

    @acceleration.setter
    def acceleration(self, arg: float, /) -> None: ...

    @property
    def steering_angle(self) -> float: ...

    @steering_angle.setter
    def steering_angle(self, arg: float, /) -> None: ...

class CartesianSample:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], y: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], theta_gl: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], v: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], a: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], kappa_gl: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], kappa_dot: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]) -> None: ...

    @property
    def is_initialized(self) -> bool: ...

    @is_initialized.setter
    def is_initialized(self, arg: bool, /) -> None: ...

    @property
    def x(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @x.setter
    def x(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def y(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @y.setter
    def y(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def theta(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @theta.setter
    def theta(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def v(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @v.setter
    def v(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def a(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @a.setter
    def a(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def kappa(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @kappa.setter
    def kappa(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def kappa_dot(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @kappa_dot.setter
    def kappa_dot(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    def __str__(self) -> str: ...

    def __getstate__(self) -> dict: ...

    def __setstate__(self, arg: dict, /) -> None: ...

class CoordinateSystemWrapper:
    def __init__(self, ref_path: Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='None')]) -> None: ...

    @property
    def ref_pos(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @ref_pos.setter
    def ref_pos(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def ref_curv(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @ref_curv.setter
    def ref_curv(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def ref_theta(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @ref_theta.setter
    def ref_theta(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def ref_curv_d(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @ref_curv_d.setter
    def ref_curv_d(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def ref_curv_dd(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @ref_curv_dd.setter
    def ref_curv_dd(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def ref_line(self) -> list[Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]]: ...

    @ref_line.setter
    def ref_line(self, arg: Sequence[Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]], /) -> None: ...

    def __getstate__(self) -> dict: ...

    def __setstate__(self, arg: dict, /) -> None: ...

class CurviLinearSample:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, s: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], d: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], theta_gl: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], dd: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], ddd: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], ss: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], sss: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]) -> None: ...

    @property
    def is_initialized(self) -> bool: ...

    @is_initialized.setter
    def is_initialized(self, arg: bool, /) -> None: ...

    @property
    def s(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @s.setter
    def s(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def d(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @d.setter
    def d(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def theta(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @theta.setter
    def theta(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def d_dot(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @d_dot.setter
    def d_dot(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def d_ddot(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @d_ddot.setter
    def d_ddot(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def s_dot(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @s_dot.setter
    def s_dot(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @property
    def s_ddot(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @s_ddot.setter
    def s_ddot(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    def __str__(self) -> str: ...

    def __getstate__(self) -> dict: ...

    def __setstate__(self, arg: dict, /) -> None: ...

class CurvilinearPlannerState:
    def __init__(self, x0_lon: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')], x0_lat: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')]) -> None: ...

    @property
    def x0_lon(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')]: ...

    @x0_lon.setter
    def x0_lon(self, arg: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')], /) -> None: ...

    @property
    def x0_lat(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')]: ...

    @x0_lat.setter
    def x0_lat(self, arg: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')], /) -> None: ...

class InvalidCovarianceMatrixError(ValueError):
    pass

class LinearTrajectory:
    def __call__(self, arg: float, /) -> float: ...

    def squared_jerk_integral(self, arg: float, /) -> float: ...

class PlannerState:
    def __init__(self, x_0: CartesianPlannerState, x_cl: CurvilinearPlannerState, wheelbase: float) -> None: ...

    @property
    def x_0(self) -> CartesianPlannerState: ...

    @x_0.setter
    def x_0(self, arg: CartesianPlannerState, /) -> None: ...

    @property
    def x_cl(self) -> CurvilinearPlannerState: ...

    @x_cl.setter
    def x_cl(self, arg: CurvilinearPlannerState, /) -> None: ...

    @property
    def wheelbase(self) -> float: ...

    @wheelbase.setter
    def wheelbase(self, arg: float, /) -> None: ...

class PoseWithCovariance:
    def __init__(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(4), order='C')], arg2: Annotated[ArrayLike, dict(dtype='float64', shape=(6, 6), order='F')], /) -> None: ...

    def __repr__(self) -> str: ...

    @property
    def position(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')]: ...

    @property
    def orientation(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(4), order='C')]: ...

    @property
    def covariance(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(6, 6), order='F')]: ...

class PredictedObject:
    def __init__(self, arg0: int, arg1: Sequence[PoseWithCovariance], arg2: float, arg3: float, /) -> None: ...

    def __repr__(self) -> str: ...

    @property
    def object_id(self) -> int: ...

    @property
    def length(self) -> float: ...

    @property
    def width(self) -> float: ...

    @property
    def predictedPath(self) -> list[PoseWithCovariance]: ...

class QuarticTrajectory(LinearTrajectory):
    def __init__(self, tau_0: float, delta_tau: float, x_0: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')], x_d: Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')], x_0_order: Annotated[ArrayLike, dict(dtype='int32', shape=(3), order='C')], x_d_order: Annotated[ArrayLike, dict(dtype='int32', shape=(2), order='C')]) -> None: ...

    @property
    def coeffs(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(5), order='C')]: ...

    def __call__(self, t: float, derivative: float = 0.0) -> float: ...

    def squared_jerk_integral(self, arg: float, /) -> float: ...

    @property
    def delta_tau(self) -> float: ...

    def __getstate__(self) -> dict: ...

    def __setstate__(self, arg: dict, /) -> None: ...

class QuinticTrajectory(LinearTrajectory):
    def __init__(self, tau_0: float, delta_tau: float, x_0: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')], x_d: Annotated[ArrayLike, dict(dtype='float64', shape=(3), order='C')], x_0_order: Annotated[ArrayLike, dict(dtype='int32', shape=(3), order='C')], x_d_order: Annotated[ArrayLike, dict(dtype='int32', shape=(3), order='C')]) -> None: ...

    @property
    def coeffs(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(6), order='C')]: ...

    def __call__(self, t: float, derivative: float = 0.0) -> float: ...

    def squared_jerk_integral(self, arg: float, /) -> float: ...

    @property
    def delta_tau(self) -> float: ...

    def __getstate__(self) -> dict: ...

    def __setstate__(self, arg: dict, /) -> None: ...

class SamplingConfiguration:
    def __init__(self, *, t_min: float, t_max: float, dt: float, d_delta: float, sampling_level: int, time_based_lateral_delta_scaling: bool = True, enforce_time_bounds: bool = True, strict_velocity_sampling: bool = True, ego_position_lateral_sampling: bool = False) -> None: ...

class TrajectoryHandler:
    def __init__(self, dt: float) -> None: ...

    def generate_stopping_trajectories(self, arg0: PlannerState, arg1: SamplingConfiguration, arg2: float, arg3: float, arg4: bool, /) -> None: ...

    def generate_trajectories(self, samplingMatrix: Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), order='None')], lowVelocityMode: bool) -> None: ...

    def sort(self) -> None: ...

    def add_feasability_function(self, arg: trajectory_functions.FeasabilityStrategy) -> None: ...

    def add_cost_function(self, arg: trajectory_functions.CostStrategy) -> None: ...

    def clear_cost_functions(self) -> None:
        """Clears all cost functions."""

    def set_all_cost_weights_to_zero(self) -> None:
        """Sets all cost function weights to zero."""

    def add_function(self, arg: trajectory_functions.TrajectoryStrategy) -> None: ...

    def evaluate_trajectory(self, trajectory: TrajectorySample, calculateAllCosts: bool = False) -> None: ...

    def evaluate_all_current_functions(self, calculateAllCosts: bool = False) -> None: ...

    def evaluate_all_current_functions_concurrent(self, calculateAllCosts: bool = False) -> None: ...

    def get_feasible_count(self) -> int: ...

    def get_infeasible_count(self) -> int: ...

    def get_sorted_trajectories(self) -> Iterator[TrajectorySample]: ...

    def get_cost_functions(self) -> Iterator[tuple[str, trajectory_functions.CostStrategy]]: ...

    def get_feasability_functions(self) -> Iterator[tuple[str, trajectory_functions.FeasabilityStrategy]]: ...

    def get_other_functions(self) -> Iterator[tuple[str, trajectory_functions.TrajectoryStrategy]]: ...

    def reset_Trajectories(self) -> None:
        """Resets the trajectories container."""

class TrajectorySample:
    @overload
    def __init__(self, dt: float, trajectoryLongitudinal: QuarticTrajectory, trajectoryLateral: QuinticTrajectory, uniqueId: int) -> None: ...

    @overload
    def __init__(self, x0: float, y0: float, orientation0: float, acceleration0: float, velocity0: float) -> None: ...

    @property
    def dt(self) -> float: ...

    @dt.setter
    def dt(self, arg: float, /) -> None: ...

    @property
    def cost(self) -> float: ...

    @cost.setter
    def cost(self, arg: float, /) -> None: ...

    @property
    def _cost(self) -> float: ...

    @_cost.setter
    def _cost(self, arg: float, /) -> None: ...

    @property
    def harm_occ_module(self) -> float | None: ...

    @harm_occ_module.setter
    def harm_occ_module(self, arg: float, /) -> None: ...

    @property
    def _harm_occ_module(self) -> float | None: ...

    @_harm_occ_module.setter
    def _harm_occ_module(self, arg: float, /) -> None: ...

    @property
    def _coll_detected(self) -> bool | None: ...

    @_coll_detected.setter
    def _coll_detected(self, arg: bool, /) -> None: ...

    @property
    def uniqueId(self) -> int | None: ...

    @uniqueId.setter
    def uniqueId(self, arg: int, /) -> None: ...

    @property
    def trajectory_long(self) -> LinearTrajectory: ...

    @trajectory_long.setter
    def trajectory_long(self, arg: LinearTrajectory, /) -> None: ...

    @property
    def trajectory_lat(self) -> LinearTrajectory: ...

    @trajectory_lat.setter
    def trajectory_lat(self, arg: LinearTrajectory, /) -> None: ...

    @property
    def cartesian(self) -> CartesianSample: ...

    @cartesian.setter
    def cartesian(self, arg: CartesianSample, /) -> None: ...

    @property
    def curvilinear(self) -> CurviLinearSample: ...

    @curvilinear.setter
    def curvilinear(self, arg: CurviLinearSample, /) -> None: ...

    @property
    def boundary_harm(self) -> float | None: ...

    @boundary_harm.setter
    def boundary_harm(self, arg: float, /) -> None: ...

    @property
    def _ego_risk(self) -> float | None: ...

    @_ego_risk.setter
    def _ego_risk(self, arg: float, /) -> None: ...

    @property
    def _obst_risk(self) -> float | None: ...

    @_obst_risk.setter
    def _obst_risk(self, arg: float, /) -> None: ...

    @property
    def feasabilityMap(self) -> dict[str, float]: ...

    @feasabilityMap.setter
    def feasabilityMap(self, arg: Mapping[str, float], /) -> None: ...

    @property
    def costMap(self) -> dict[str, tuple[float, float]]: ...

    @costMap.setter
    def costMap(self, arg: Mapping[str, tuple[float, float]], /) -> None: ...

    @property
    def feasible(self) -> bool: ...

    @feasible.setter
    def feasible(self, arg: bool, /) -> None: ...

    @property
    def valid(self) -> bool: ...

    @valid.setter
    def valid(self, arg: bool, /) -> None: ...

    @property
    def sampling_parameters(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @sampling_parameters.setter
    def sampling_parameters(self, arg: Annotated[ArrayLike, dict(dtype='float64', writable=False, shape=(None), order='None')], /) -> None: ...

    @staticmethod
    def compute_standstill_trajectory(coordinate_system: CoordinateSystemWrapper, planner_state: PlannerState, dt: float, horizon: float) -> TrajectorySample: ...

    def __getstate__(self) -> dict: ...

    def __setstate__(self, arg: dict, /) -> None: ...

    def add_cost_value_to_list(self, cost_function_name: str, cost: float, weighted_costs: float) -> None:
        """
        Add a cost value to the list of cost values. This includes the weighted and unweighted cost.
        """

def compute_initial_state(coordinate_system: CoordinateSystemWrapper, x_0: CartesianPlannerState, wheelbase: float, low_velocity_mode: bool) -> CurvilinearPlannerState: ...

def setup_logger(logger: object) -> None: ...
