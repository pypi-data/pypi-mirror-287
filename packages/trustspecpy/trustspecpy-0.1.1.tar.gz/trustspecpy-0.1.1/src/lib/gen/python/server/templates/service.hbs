from abc import ABC, abstractmethod
from pydantic import BaseModel
from typing import Generator, Tuple

class {{to_pascal_case feature}}Service(ABC):
{{#each ops}}{{#each this}}    {{#if (filterNonconst this.res.meta)}}class {{to_pascal_case this.name}}Headers(BaseModel):
        {{#each (filterNonconst this.res.meta)}}{{to_snake_case this.[0]}}: {{fmtType this.[1]}}
        {{/each}}
        def to_dict(self) -> dict[str, str]:
            return {
                {{#each (filterNonconst this.res.meta)}}"{{this.[0]}}": str(self.{{to_snake_case this.[0]}}){{#unless @last}},{{/unless}}
                {{/each}}
            }{{/if}}

    @abstractmethod
    def {{to_snake_case this.name}}(self{{#if this.req}}, {{#if (eq this.req.form "multipart/form-data")}}request: {{fmtName this.name}}.{{>dtoName val=(fmtClass this.name)}} = Depends({{fmtName this.name}}.{{fmtClass this.name}}Dto.of_form){{else if (or (eq this.req.type "obj") (eq this.req.type "seq") (eq this.req.type "map"))}}{{fmtName (add this.name "Req")}}: {{fmtName (add this.name "Req")}}.{{>dtoName val=(fmtClass (add this.name "Req"))}}{{else}}request: {{fmtType this.req}}{{/if}}{{/if}}{{#each this.params}}, {{to_snake_case this.name}}: {{#if this.opt}}{{fmtOpt (fmtType this)}}{{else}}{{fmtType this}}{{/if}}{{/each}}) -> {{#if this.res}}{{#if (filterNonconst this.res.meta)}}Tuple[{{/if}}{{#if (eq this.res.carrier "stream")}}Generator[{{fmtType this.res}}, None, None]{{else}}{{#if this.res.path}}{{fmtType this.res (to_pascal_case this.name)}}{{else if (or (eq this.res.type "obj") (eq this.res.type "seq") (eq this.res.type "map"))}}{{fmtName (add this.name "Res")}}.{{>dtoName val=(fmtClass (add this.name "Res"))}}{{else}}{{fmtType this.res}}{{/if}}{{/if}}{{#if this.res.meta}}{{#if (filterNonconst this.res.meta)}}, {{to_pascal_case this.name}}Headers]{{/if}}{{/if}}{{else}}None{{/if}}:
        raise NotImplementedError
{{/each}}{{/each}}
