from io import BufferedReader
from pydantic import parse_obj_as
from typing import Any, Generator
from trust import client

class {{to_pascal_case feature}}Service:
{{#each ops}}{{#each this}}
    def {{to_snake_case this.name}}(self{{#if this.req}}, {{#if this.req.path}}{{fmtName (fmtType this.req)}}: {{fmtType this.req (to_pascal_case this.name)}}{{else if (or (eq this.req.type "obj") (eq this.req.type "seq") (eq this.req.type "map"))}}{{fmtName (add this.name "Req")}}: {{fmtName (add this.name "Req")}}.{{>dtoName val=(fmtClass (add this.name "Req"))}}{{else}}request: {{fmtType this.req}}{{/if}}{{#if (eq this.req.form "multipart/form-data")}}, file: BufferedReader{{/if}}{{/if}}{{#if this.params}}{{#each (sortOptionalsLast this.params)}}, {{to_snake_case this.name}}: {{#if (hasKey this "default")}}{{#fmtOpt (fmtType this)}}{{/fmtOpt}}{{#if (hasKey this "default")}} = None{{/if}}{{else}}{{fmtType this}}{{/if}}{{/each}}{{/if}}) -> {{#if this.res}}{{#if (eq this.res.carrier "stream")}}Generator[{{fmtType this.res}}, None, None]{{else}}{{#if this.res.path}}{{fmtType this.res (to_pascal_case this.name)}}{{else if (or (eq this.res.type "obj") (eq this.res.type "seq") (eq this.res.type "map"))}}{{fmtName (add this.name "Res")}}.{{>dtoName val=(fmtClass (add this.name "Res"))}}{{else}}{{fmtType this.res}}{{/if}}{{/if}}{{else}}None{{/if}}:
        query_params = {}{{#each this.params}}{{#if (eq this.loc "query")}}
        if {{to_snake_case this.name}} is not None:
            query_params[{{json this.name}}] = {{to_snake_case this.name}}{{/if}}{{/each}}
        {{#if this.res}}response = {{/if}}client.{{to_lower_case this.type}}("{{@../key}}".format({{#each (filterOpParamsByLoc this.params "path")}}{{this.name}} = {{to_snake_case this.name}}{{#unless @last}}, {{/unless}}{{/each}}), params = query_params{{#if this.req}}, {{#if (eq this.req.form "multipart/form-data")}}data = {{#if this.req.path}}{{fmtName (fmtType this.req)}}{{else}}{{fmtName this.name}}{{/if}}.form(), files = {"file": file}{{else}}data = {{#if this.req.path}}{{fmtName (fmtType this.req)}}{{else if (or (eq this.req.type "obj") (eq this.req.type "seq") (eq this.req.type "map"))}}{{fmtName (add this.name "Req")}}{{else}}request{{/if}}.model_dump_json(exclude_none=True){{/if}}{{/if}}){{#if this.res}}
        if response.is_error:
            raise Exception(response.json())
        return parse_obj_as({{#if this.res.path}}{{fmtType this.res (to_pascal_case this.name)}}{{else if (or (eq this.res.type "obj") (eq this.res.type "seq") (eq this.res.type "map"))}}{{fmtName (add this.name "Res")}}.{{>dtoName val=(fmtClass (add this.name "Res"))}}{{else}}{{fmtType this.res}}{{/if}}, response.json()){{/if}}
{{/each}}{{/each}}
