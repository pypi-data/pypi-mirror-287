<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sankey &mdash; graphpack  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/togglebutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>let toggleHintShow = 'Click to see the algorithm pseudocode, parameters and hints';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            graphpack
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html#quick-start">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html#on-ramp">On Ramp</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Overview and Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#compression-pipeline">Compression Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Demo Pipeline</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Graph Compression Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html#demo-modules">Demo Modules</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Glossaries</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../graph-compression-glossary.html">Graph Compression Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compression-algorithm-glossary.html">Compression Algorithm Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">License</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">graphpack</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">sankey</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sankey</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>

<span class="kn">from</span> <span class="nn">graphpack.utils</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">MARGIN</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># Margin for the plot</span>
<span class="n">MAX_MARGIN</span> <span class="o">=</span> <span class="mi">500</span>  <span class="c1"># Maximum margin for the plot (increase if last layer nodes&#39; labels are cut off)</span>


<div class="viewcode-block" id="lighten_color">
<a class="viewcode-back" href="../demo.html#sankey.lighten_color">[docs]</a>
<span class="k">def</span> <span class="nf">lighten_color</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lighten the given color by the specified amount.</span>

<span class="sd">    Args:</span>
<span class="sd">        color (str): A color name or RGBA string.</span>
<span class="sd">        amount (float, optional): The amount to lighten the color (0.0 to 1.0).</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The lightened color as an RGBA string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if the color is already in RGBA format</span>
    <span class="n">rgba_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d*\.?\d+)\)&#39;</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">rgba_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="c1"># Extract RGBA components from the string</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># Apply the amount to the alpha component</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;rgba(</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s1">)&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Convert named color to RGBA</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;rgba(</span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">255</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">255</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">255</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s1">)&#39;</span></div>



<div class="viewcode-block" id="load_data">
<a class="viewcode-back" href="../demo.html#sankey.load_data">[docs]</a>
<span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="n">input_path</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load compression mappings and group labels for each parameter.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_path (str): Path to the input files.</span>
<span class="sd">        graph (str): Input graph identifier.</span>
<span class="sd">        method (str): Clustering method used.</span>
<span class="sd">        parameter (str): Clustering parameter name.</span>
<span class="sd">        parameters (list): List of parameters to be analyzed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: Two dictionaries, one for compression mappings and one for group labels, and the (eventually updated) list of parameter&#39;s values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize dictionaries to store compression mappings and groups for each parameter</span>
    <span class="n">compression_mappings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Create a copy of parameters to iterate over</span>
    <span class="n">parameters_copy</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[:]</span>

    <span class="c1"># Load compression mappings and group labels for each parameter</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters_copy</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">input_path</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">/compression_mapping.json&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">compression_mappings</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

            <span class="n">labels_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">input_path</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">/labels_mapping.json&#39;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">labels_file</span><span class="p">):</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">labels_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If labels_mapping.json doesn&#39;t exist, use names from compression_mapping.json as group labels</span>
                <span class="n">compression_data</span> <span class="o">=</span> <span class="n">compression_mappings</span><span class="p">[</span><span class="n">param</span><span class="p">]</span>
                <span class="n">groups</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">compression_data</span><span class="p">}</span>

        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Files for parameter </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2"> not found. Skipping this value.&quot;</span><span class="p">)</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">compression_mappings</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">parameters</span></div>



<div class="viewcode-block" id="map_transitions">
<a class="viewcode-back" href="../demo.html#sankey.map_transitions">[docs]</a>
<span class="k">def</span> <span class="nf">map_transitions</span><span class="p">(</span><span class="n">compression_mappings</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">min_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map transitions between consecutive parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        compression_mappings (dict): Compression mappings for each parameter.</span>
<span class="sd">        groups (dict): Group labels for each parameter.</span>
<span class="sd">        parameters (list): List of parameters to be analyzed.</span>
<span class="sd">        min_size (int): Minimum cluster size to be considered significant.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: List of transitions between clusters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize a list to store the gene transitions between resolutions</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">small_cluster_label</span> <span class="o">=</span> <span class="s2">&quot;small clusters&quot;</span>

    <span class="c1"># Iterate through each pair of consecutive resolutions to map transitions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">param_from</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">param_to</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">param_from</span> <span class="ow">in</span> <span class="n">compression_mappings</span> <span class="ow">and</span> <span class="n">param_to</span> <span class="ow">in</span> <span class="n">compression_mappings</span><span class="p">:</span>
            <span class="n">mapping_from</span> <span class="o">=</span> <span class="n">compression_mappings</span><span class="p">[</span><span class="n">param_from</span><span class="p">]</span>
            <span class="n">mapping_to</span> <span class="o">=</span> <span class="n">compression_mappings</span><span class="p">[</span><span class="n">param_to</span><span class="p">]</span>
            <span class="n">group_from</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">param_from</span><span class="p">]</span>
            <span class="n">group_to</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">param_to</span><span class="p">]</span>

            <span class="c1"># Create a reverse mapping from gene to cluster for the target resolution</span>
            <span class="n">reverse_mapping_to</span> <span class="o">=</span> <span class="p">{</span><span class="n">gene</span><span class="p">:</span> <span class="n">cluster</span> <span class="k">for</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">genes</span> <span class="ow">in</span> <span class="n">mapping_to</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">genes</span><span class="p">}</span>

            <span class="c1"># Map transitions from the current resolution to the next</span>
            <span class="k">for</span> <span class="n">cluster_from</span><span class="p">,</span> <span class="n">genes_from</span> <span class="ow">in</span> <span class="n">mapping_from</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">source_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">param_from</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">group_from</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_from</span><span class="p">),</span><span class="w"> </span><span class="n">small_cluster_label</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">genes_from</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_size</span><span class="p">:</span>  <span class="c1"># Main cluster handling</span>
                    <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">genes_from</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">reverse_mapping_to</span><span class="p">:</span>
                            <span class="n">cluster_to</span> <span class="o">=</span> <span class="n">reverse_mapping_to</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span>
                            <span class="n">target_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">param_to</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">group_to</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_to</span><span class="p">),</span><span class="w"> </span><span class="n">small_cluster_label</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping_to</span><span class="p">[</span><span class="n">cluster_to</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">min_size</span><span class="p">:</span>
                                <span class="n">transitions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">source_label</span><span class="p">,</span> <span class="n">target_label</span><span class="p">,</span> <span class="n">gene</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">transitions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">source_label</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">param_to</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">small_cluster_label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">gene</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Handle small clusters at the source resolution</span>
                    <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">genes_from</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">reverse_mapping_to</span><span class="p">:</span>
                            <span class="n">cluster_to</span> <span class="o">=</span> <span class="n">reverse_mapping_to</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span>
                            <span class="n">target_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">param_to</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">group_to</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_to</span><span class="p">),</span><span class="w"> </span><span class="n">small_cluster_label</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping_to</span><span class="p">[</span><span class="n">cluster_to</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">min_size</span><span class="p">:</span>
                                <span class="n">transitions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">param_from</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">small_cluster_label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">target_label</span><span class="p">,</span> <span class="n">gene</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">param_from</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">small_cluster_label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">param_to</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">small_cluster_label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                     <span class="n">gene</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping transition from resolution </span><span class="si">{</span><span class="n">param_from</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">param_to</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transitions</span></div>



<div class="viewcode-block" id="create_sankey_plot">
<a class="viewcode-back" href="../demo.html#sankey.create_sankey_plot">[docs]</a>
<span class="k">def</span> <span class="nf">create_sankey_plot</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">input_graph</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create and save the Sankey plot.</span>

<span class="sd">    Args:</span>
<span class="sd">        transitions (list): List of transitions between clusters.</span>
<span class="sd">        min_size (int): Minimum cluster size to be considered significant.</span>
<span class="sd">        parameter (str): Clustering parameter name.</span>
<span class="sd">        method (str): Clustering method used.</span>
<span class="sd">        input_graph (str): Knowledge graph identifier.</span>
<span class="sd">        output_folder (str): Path to the output folder.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a DataFrame from the transitions list</span>
    <span class="n">transitions_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">,</span> <span class="s1">&#39;Target&#39;</span><span class="p">,</span> <span class="s1">&#39;Gene&#39;</span><span class="p">])</span>

    <span class="c1"># Extract unique stages from Source and Target columns</span>
    <span class="n">stages</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">transitions_df</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">transitions_df</span><span class="p">[</span><span class="s1">&#39;Target&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>

    <span class="c1"># Initialize a dictionary to store nodes grouped by stage</span>
    <span class="n">stage_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">stage</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">stages</span><span class="p">}</span>

    <span class="c1"># Populate stage_nodes dictionary with nodes, sorted alphabetically within each stage</span>
    <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">stage_nodes</span><span class="p">:</span>
        <span class="n">stage_nodes</span><span class="p">[</span><span class="n">stage</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">transitions_df</span><span class="p">[</span><span class="n">transitions_df</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">stage</span><span class="p">)][</span><span class="s1">&#39;Source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">stage_nodes</span><span class="p">[</span><span class="n">stage</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">transitions_df</span><span class="p">[</span><span class="n">transitions_df</span><span class="p">[</span><span class="s1">&#39;Target&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">stage</span><span class="p">)][</span><span class="s1">&#39;Target&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">stage_nodes</span><span class="p">[</span><span class="n">stage</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">stage_nodes</span><span class="p">[</span><span class="n">stage</span><span class="p">])))</span>

    <span class="c1"># Flatten stage_nodes dictionary into a sorted list of nodes</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">stages</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">stage_nodes</span><span class="p">[</span><span class="n">stage</span><span class="p">]]</span>

    <span class="c1"># Create a dictionary to map node labels to their indices</span>
    <span class="n">node_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">)}</span>

    <span class="c1"># Initialize lists to store links with updated indices</span>
    <span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through each row in transitions_df to create links with updated indices</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">transitions_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">source_index</span> <span class="o">=</span> <span class="n">node_indices</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">]]</span>
        <span class="n">target_index</span> <span class="o">=</span> <span class="n">node_indices</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Target&#39;</span><span class="p">]]</span>
        <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="n">source_index</span><span class="p">,</span>
            <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">target_index</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">})</span>

    <span class="c1"># Prepare custom data for each node with limited gene list</span>
    <span class="n">node_customdata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gene_display_limit</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Limit the number of genes displayed in hover info</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">node_stage</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">genes</span> <span class="o">=</span> <span class="n">transitions_df</span><span class="p">[(</span><span class="n">transitions_df</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">transitions_df</span><span class="p">[</span><span class="s1">&#39;Target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">)][</span><span class="s1">&#39;Gene&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">gene_list</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">genes</span><span class="p">[:</span><span class="n">gene_display_limit</span><span class="p">])</span>  <span class="c1"># Limit the number of genes displayed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gene_display_limit</span><span class="p">:</span>
            <span class="n">gene_list</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;, ... (+</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">gene_display_limit</span><span class="si">}</span><span class="s1"> more)&#39;</span>
        <span class="n">custom_data</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Parameter: </span><span class="si">{</span><span class="n">node_stage</span><span class="si">}</span><span class="s2">&lt;br&gt;Community: </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">&lt;br&gt;Genes: </span><span class="si">{</span><span class="n">gene_list</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">node_customdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">custom_data</span><span class="p">)</span>

    <span class="c1"># Extract unique community names</span>
    <span class="n">communities</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)))</span>

    <span class="c1"># Generate a larger color palette using matplotlib</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">mcolors</span><span class="o">.</span><span class="n">CSS4_COLORS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">COLORS</span><span class="p">]</span>
    <span class="n">color_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">community</span><span class="p">:</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">community</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">communities</span><span class="p">)}</span>

    <span class="c1"># Assign colors to nodes based on their community</span>
    <span class="n">node_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">community</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;small clusters&#39;</span><span class="p">):</span>
            <span class="n">node_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;rgba(0, 0, 0, 0)&#39;</span><span class="p">)</span>  <span class="c1"># Transparent color for small clusters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">color_map</span><span class="p">[</span><span class="n">community</span><span class="p">])</span>

    <span class="c1"># Create a list to store line colors based on whether the target node is a small cluster</span>
    <span class="n">line_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="n">target_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]]</span>
        <span class="n">source_color</span> <span class="o">=</span> <span class="n">node_colors</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]]</span>
        <span class="n">target_color</span> <span class="o">=</span> <span class="n">node_colors</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">target_node</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;small clusters&#39;</span><span class="p">):</span>
            <span class="n">line_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">CSS4_COLORS</span><span class="p">[</span><span class="s1">&#39;whitesmoke&#39;</span><span class="p">])</span>  <span class="c1"># Lighter gray for links going into small clusters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Lighter version of the source node color, if big communities, else lightgray for other links</span>
            <span class="n">line_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lighten_color</span><span class="p">(</span><span class="n">source_color</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">))</span> <span class="k">if</span> <span class="n">min_size</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">else</span> <span class="n">line_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">mcolors</span><span class="o">.</span><span class="n">CSS4_COLORS</span><span class="p">[</span><span class="s1">&#39;lightgray&#39;</span><span class="p">])</span>

    <span class="c1"># Create Sankey plot with custom hover information, node colors, and link colors</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">go</span><span class="o">.</span><span class="n">Sankey</span><span class="p">(</span>
        <span class="n">node</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">pad</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>  <span class="c1"># Padding between nodes</span>
            <span class="n">thickness</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>  <span class="c1"># Thickness of the links</span>
            <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">mcolors</span><span class="o">.</span><span class="n">CSS4_COLORS</span><span class="p">[</span><span class="s1">&#39;lightgray&#39;</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span>
            <span class="n">label</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>  <span class="c1"># Node labels</span>
            <span class="n">color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">,</span>  <span class="c1"># Assign node colors</span>
            <span class="n">customdata</span><span class="o">=</span><span class="n">node_customdata</span><span class="p">,</span>  <span class="c1"># Use the prepared custom data</span>
            <span class="n">hovertemplate</span><span class="o">=</span><span class="s1">&#39;%</span><span class="si">{customdata}</span><span class="s1">&lt;extra&gt;&lt;/extra&gt;&#39;</span><span class="p">,</span>  <span class="c1"># Use the custom data for hover text</span>
            <span class="n">hoverinfo</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>  <span class="c1"># Enable hover information for nodes</span>
        <span class="p">),</span>
        <span class="n">link</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">],</span>  <span class="c1"># Indices of source nodes</span>
            <span class="n">target</span><span class="o">=</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">],</span>  <span class="c1"># Indices of target nodes</span>
            <span class="n">value</span><span class="o">=</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">],</span>  <span class="c1"># Link values</span>
            <span class="n">hoverinfo</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>  <span class="c1"># Disable hover interaction for links</span>
            <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">),</span>
            <span class="n">color</span><span class="o">=</span><span class="n">line_colors</span><span class="p">,</span>  <span class="c1"># Specify link colors based on conditions</span>
        <span class="p">)</span>
    <span class="p">)])</span>

    <span class="c1"># Update the layout of the plot</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
        <span class="n">title_text</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Genes&#39; community membership for </span><span class="si">{</span><span class="n">input_graph</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">margin</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">MARGIN</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">MARGIN</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">MAX_MARGIN</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">MARGIN</span><span class="p">),</span>  <span class="c1"># Adjusted margins</span>
        <span class="n">font_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>  <span class="c1"># Adjusted font size for better visibility</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>  <span class="c1"># Increased width for better visibility</span>
        <span class="n">height</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>  <span class="c1"># Increased height for better visibility</span>
        <span class="n">plot_bgcolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
        <span class="n">paper_bgcolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
        <span class="n">font_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span>
    <span class="p">)</span>

    <span class="c1"># JavaScript for aligning node labels to the right</span>
    <span class="n">js</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    const TEXTPAD = 3; // constant used by Plotly.js</span>
<span class="s1">    </span>
<span class="s1">    function sankeyNodeLabelsAlign(position, forcePos) {</span>
<span class="s1">      const textAnchor = {left: &#39;end&#39;, right: &#39;start&#39;, center: &#39;middle&#39;}[position];</span>
<span class="s1">      const nodes = gd.getElementsByClassName(&#39;sankey-node&#39;);</span>
<span class="s1">    </span>
<span class="s1">      for (const node of nodes) {</span>
<span class="s1">        const d = node.__data__;</span>
<span class="s1">        const label = node.getElementsByClassName(&#39;node-label&#39;).item(0);</span>
<span class="s1">    </span>
<span class="s1">        // Ensure to reset any previous modifications</span>
<span class="s1">        label.setAttribute(&#39;x&#39;, 0);</span>
<span class="s1">    </span>
<span class="s1">        if (!d.horizontal)</span>
<span class="s1">          continue;</span>
<span class="s1">    </span>
<span class="s1">        // This is how Plotly&#39;s default text positioning is computed (coordinates</span>
<span class="s1">        // are relative to that of the corresponding node).</span>
<span class="s1">        const padX = d.nodeLineWidth / 2 + TEXTPAD;</span>
<span class="s1">        const posX = padX + d.visibleWidth;</span>
<span class="s1">        let x;</span>
<span class="s1">    </span>
<span class="s1">        switch (position) {</span>
<span class="s1">          case &#39;left&#39;:</span>
<span class="s1">            if (d.left || (d.node.originalLayer === 0 &amp;&amp; !forcePos))</span>
<span class="s1">              continue;</span>
<span class="s1">            x = -posX - padX;</span>
<span class="s1">            break;</span>
<span class="s1">    </span>
<span class="s1">          case &#39;right&#39;:</span>
<span class="s1">            if (!d.left || !forcePos)</span>
<span class="s1">              continue;</span>
<span class="s1">            x = posX + padX;</span>
<span class="s1">            break;</span>
<span class="s1">    </span>
<span class="s1">          case &#39;center&#39;:</span>
<span class="s1">            if (!forcePos &amp;&amp; (d.left || d.node.originalLayer === 0))</span>
<span class="s1">              continue;</span>
<span class="s1">            x = (d.nodeLineWidth + d.visibleWidth) / 2 + (d.left ? padX : -posX);</span>
<span class="s1">            break;</span>
<span class="s1">        }</span>
<span class="s1">    </span>
<span class="s1">        // Ensure last layer nodes&#39; labels are inside the plot area</span>
<span class="s1">        if (d.node.originalLayer === d.layerLength - 1) {</span>
<span class="s1">          x = Math.min(x, gd.layout.width - label.getBBox().width - padX);</span>
<span class="s1">        }</span>
<span class="s1">    </span>
<span class="s1">        label.setAttribute(&#39;x&#39;, x);</span>
<span class="s1">        label.setAttribute(&#39;text-anchor&#39;, textAnchor);</span>
<span class="s1">      }</span>
<span class="s1">    }</span>
<span class="s1">    const gd = document.getElementById(&#39;</span><span class="si">{plot_id}</span><span class="s1">&#39;);</span>
<span class="s1">    const position = &#39;right&#39;; // Set position to &#39;right&#39;, &#39;left&#39;, or &#39;center&#39;</span>
<span class="s1">    const forcePos = true;</span>
<span class="s1">    </span>
<span class="s1">    gd.on(&#39;plotly_afterplot&#39;, sankeyNodeLabelsAlign.bind(gd, position, forcePos));</span>
<span class="s1">    gd.emit(&#39;plotly_afterplot&#39;);</span>
<span class="s1">    &#39;&#39;&#39;</span>

    <span class="c1"># Create output folder if it does not exist</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_folder</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_folder</span><span class="p">)</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">write_html</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_folder</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">input_graph</span><span class="si">}</span><span class="s2">_sankey_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_s_</span><span class="si">{</span><span class="n">min_size</span><span class="si">}</span><span class="s2">.html&quot;</span><span class="p">,</span> <span class="n">post_script</span><span class="o">=</span><span class="n">js</span><span class="p">)</span></div>



<div class="viewcode-block" id="produce_sankey">
<a class="viewcode-back" href="../demo.html#sankey.produce_sankey">[docs]</a>
<span class="k">def</span> <span class="nf">produce_sankey</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">input_path</span><span class="o">=</span><span class="s1">&#39;data/output&#39;</span><span class="p">,</span> <span class="n">output_folder</span><span class="o">=</span><span class="s1">&#39;sankey&#39;</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                   <span class="n">method</span><span class="o">=</span><span class="s1">&#39;louvain&#39;</span><span class="p">,</span> <span class="n">parameter</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main function for the GraphPack tool Sankey plot script.</span>

<span class="sd">    This script generates a Sankey plot to visualize gene community membership transitions across</span>
<span class="sd">    different clustering resolutions for a given network.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (str): Input graph identifier. Required parameter.</span>
<span class="sd">        input_path (str, optional): Path to the input files. Default is &quot;data/output&quot;.</span>
<span class="sd">        output_folder (str, optional): Path to the output folder. Default is &quot;sankey&quot;.</span>
<span class="sd">        min_size (int, optional): Minimum cluster size to be considered significant. Default is 100.</span>
<span class="sd">        method (str, optional): Clustering method used. Default is &quot;louvain&quot;.</span>
<span class="sd">        parameter (str, optional): Clustering parameter name, as it appears in the subfolders&#39; names. Default is &quot;r&quot;.</span>
<span class="sd">        values (list of float, optional): List of parameters to be analyzed. Default is [1.25, 3.0, 5.0, 10.0, 20.0, 30.0].</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from graphpack.demo.sankey import *</span>
<span class="sd">        &gt;&gt;&gt; produce_sankey(input_path=&quot;./&quot;, output_folder=&quot;results&quot;, min_size=50, graph=&#39;simple_graph&#39;, method=&#39;hclust&#39;, parameter=&#39;k&#39;, values=[10, 50, 100, 250])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Print information about the arguments</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">80</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;GraphPack Tool Sankey plot script&#39;</span><span class="si">:</span><span class="s2">^80</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">80</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">▶ Input graph:       </span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;▶ Method:           </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;▶ Parameters:       </span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s2"> in [ </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">))</span><span class="si">}</span><span class="s2"> ]&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">▶ Min cluster size: </span><span class="si">{</span><span class="n">min_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">▶ Input folder:     </span><span class="si">{</span><span class="n">input_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;▶ Output folder:    </span><span class="si">{</span><span class="n">output_folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">📑 Loading data...&quot;</span><span class="p">)</span>
    <span class="n">compression_mappings</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">load_data</span><span class="p">(</span><span class="n">input_path</span><span class="p">,</span>
                                                     <span class="n">graph</span><span class="p">,</span>
                                                     <span class="n">method</span><span class="p">,</span>
                                                     <span class="n">parameter</span><span class="p">,</span>
                                                     <span class="n">values</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;⚙️ Mapping transitions...&quot;</span><span class="p">)</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="n">map_transitions</span><span class="p">(</span><span class="n">compression_mappings</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">min_size</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;📊 Creating Sankey plot...&quot;</span><span class="p">)</span>
    <span class="n">create_sankey_plot</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">✅  Done!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sankey plot for gene community membership transitions has been saved in &#39;</span><span class="si">{</span><span class="n">output_folder</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="parse_args">
<a class="viewcode-back" href="../demo.html#sankey.parse_args">[docs]</a>
<span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse command-line arguments for Sankey plot script.</span>

<span class="sd">    Command-line arguments:</span>

<span class="sd">    Args:</span>
<span class="sd">        --graph (str): Input graph identifier. Required argument.</span>
<span class="sd">        --input-path (str): Path to the input files. Default is &quot;data/output&quot;.</span>
<span class="sd">        --output-folder (str): Path to the output folder. Default is &quot;sankey&quot;.</span>
<span class="sd">        --min-size (int): Minimum cluster size to be considered significant. Default is 100.</span>
<span class="sd">        --method (str): Clustering method used. Default is &quot;louvain&quot;.</span>
<span class="sd">        --parameter (str): Clustering parameter name. Default is &quot;r&quot;.</span>
<span class="sd">        --parameters (list of float): List of parameters to be analyzed. Default is [1.25, 3.0, 5.0, 10.0, 20.0, 30.0].</span>

<span class="sd">    Returns:</span>
<span class="sd">        args (argparse.Namespace): Parsed command-line arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">graphpack</span> <span class="kn">import</span> <span class="n">__version__</span>


    <span class="c1"># Create the custom parser</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">CustomArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Generate a Sankey plot for gene community membership transitions.&quot;</span><span class="p">,</span>
        <span class="n">epilog</span><span class="o">=</span><span class="s2">&quot;For more information, please refer to the documentation.&quot;</span><span class="p">,</span>
        <span class="n">add_help</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-h&#39;</span><span class="p">,</span> <span class="s1">&#39;--help&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;help&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">SUPPRESS</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Show this help message and exit.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-v&#39;</span><span class="p">,</span> <span class="s1">&#39;--version&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;version&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;%(prog)s </span><span class="si">{</span><span class="n">__version__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Show the version of the program.&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="s1">&#39;--graph&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Input graph identifier.&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;--input-path&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;data/output&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Path to ihe input files. Default is &quot;data/output&quot;.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="s1">&#39;--output-folder&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;sankey&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Path to the output folder. Default is &quot;sankey&quot;.&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="s1">&#39;--min-size&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Minimum cluster size to be considered significant. Default is 100.&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="s1">&#39;--method&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;louvain&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Clustering method used. Default is &quot;louvain&quot;.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-p&#39;</span><span class="p">,</span> <span class="s1">&#39;--parameter&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Clustering parameter name, as it appears in the output subfolder. Default is &quot;r&quot;.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-V&#39;</span><span class="p">,</span> <span class="s1">&#39;--values&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">],</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;List of parameters to be analyzed. Default is [1.25, 3.0, 5.0, 10.0, 20.0, 30.0].&#39;</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">LONG_DESCR</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ORANGE_BOLD</span><span class="si">}</span><span class="s2">Warning: no parameters provided. To display the help, run the script with --help</span><span class="si">{</span><span class="n">RESET</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Validate input  path</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">input_path</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">RED_BOLD</span><span class="si">}</span><span class="s2">Error: Input file &#39;</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">input_path</span><span class="si">}</span><span class="s2">&#39; does not exist.&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


    <span class="c1"># Validate output folder path</span>
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_path</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ORANGE_BOLD</span><span class="si">}</span><span class="s2">Warning: Output folder &#39;</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&#39; does not exist.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">BOLD</span><span class="si">}</span><span class="s2">Creating it now.</span><span class="si">{</span><span class="n">RESET</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">RED_BOLD</span><span class="si">}</span><span class="s2">Error: Failed to create output folder &#39;</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&#39;. </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}{</span><span class="n">RESET</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Validate the method argument</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">METHODS</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">RED_BOLD</span><span class="si">}</span><span class="s2">Error: Unsupported compression method &#39;</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;.</span><span class="si">{</span><span class="n">RESET</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">BOLD</span><span class="si">}</span><span class="s2">Supported methods are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">METHODS</span><span class="p">)</span><span class="si">}{</span><span class="n">RESET</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Cast to integer the parameter values if the method is not Louvain (k must be integer)</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;louvain&#39;</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">args</span></div>



<div class="viewcode-block" id="main">
<a class="viewcode-back" href="../demo.html#sankey.main">[docs]</a>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">()</span>
    <span class="n">produce_sankey</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">))</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Daniele.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>