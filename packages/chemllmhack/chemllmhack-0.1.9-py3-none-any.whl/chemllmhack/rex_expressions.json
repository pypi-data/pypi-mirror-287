{
  "help_info": "We needed a way to compose supercomputing modules together. To automatically take the output from one module and — possibly after some basic transformations — feed it as input into another module. And, as it turns out, supporting the required transformations results in a programming language. \n\nWhy not use Python? Why not WASM? Why not an existing DSL? We will get to that. First, let’s understand what Rex can do.\n\n# Basics\n\n## Math\n\nWe can write mathematical expressions intuitively, and it will follow the usual operator precedence:\n\n```haskell\nw + x * y + z\n```\n\n## Function calls\n\nWe can call functions by naming them, and then listing their arguments (white space separated). If we assume some function called `auto3D` then we can do:\n\n```haskell\nauto3D x y z\n```\n\nIf we need to pass the result of one function into another, we need to use parentheses to make sure things happen in the right order:\n\n```haskell\nexess a b (auto3D x y z)\n```\n\nThis passes 3 arguments to the `exess` function. The 3rd argument is the result of calling the `auto3D` function with 3 arguments, `x`, `y`, and `z`.\n\n### The wrong way\n\n<aside>\n⚠\uFE0F This is the wrong way, but lots of beginners do it, and it causes all kinds of strange type errors.\n\n</aside>\n\nDropping the parentheses looks like\n\n```haskell\nexess a b auto3D x y z\n```\n\nWhich is trying to call the `exess` function with 6 arguments, the 3rd of which is the `auto3D` function itself. Not the result of calling the `auto3D` function, but the actual `auto3D` function. There are many situations where you might want to pass around functions like values, but this isn’t one of them.\n\n## Calling operators like functions\n\nJust now, we say that we can use math operators like `x + y` but we can also call them like functions, specifying their name, and then their parameters. The only difference is that we have to surround the operator with parentheses.\n\n```haskell\n(+) x y\n```\n\n## Currying (partially calling a function)\n\nIn Rex, if a function takes N arguments we do not have to provide all N arguments. It is completely acceptable to pass <N:\n\n```haskell\n(*) 2\n```\n\nThe result of doing this is that the expression will return a *brand new function*. This unnamed function captured the arguments that have previously been provided, and waits to receive more. Once it has received them, it evaluates like normal.\n\nIn fact, this is actually how all functions are call. In Rex, whitespace is “left associative” which means `f x y z` is equivalent to `(((f x) y) z)`. As you can see, if `f` is a function that takes 3 arguments, passing it 3 arguments all at once is the same as passing them 1 at a time.\n\n## Mapping\n\nSometimes we want to apply a function not to one value, but to a list of values. To do this, we can use the `map` function. \n\n```haskell\nmap ((*) 2) [1, 2, 3]\n```\n\nWe have provided `(*) 2` as the first argument, which is itself a function that takes one argument and doubles it.\n\nWe have then provided a list of integers.\n\nThe `map` function takes the function we have provided and applies it to every item in the list, resulting a new list. In our case, the new list will be `[2, 4, 6]`.\n\n# Beginner’s Virtual Screening Protocol\n\n## Our first supercomputing module\n\n```haskell\nauto3D r1 o1 (map smi list_of_smols)\n```\n\nFor anyone familiar with Haskell, or other functional programming languages, this should look familiar. \n\nThis expression extracts the SMILES string from each Smol entity in a list (assuming the existence of some variable call `list_of_smols`) and calls the `auto3D` function with those SMILES as inputs. The result will be a list of `auto3D` outputs, one for each of the Smol entities in the input list.\n\n(Note: the `r1` and `o1` variables are assumed to be variables that are a `RunSpec` and `Auto3DOptions` respectively, which tell Auto3D how to configure itself when it runs.)\n\nSimilarly, we can prepare proteins:\n\n```haskell\nmap (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins\n```\n\nThis expression extracts the FASTA sequence from each protein in a list, runs a multiple sequence alignment, and then uses that to run colabfold.\n\nThe output of this expression will be a list of predicted structures, one for each of the input proteins. \n\nNext, let’s look at pocket prediction:\n\n```haskell\np2rank r4 o4 list_of_conformers\n```\n\nUnsurprisingly, we see the exact same pattern. And it might be obvious where we are going with this too.\n\n## Putting it together\n\n Let’s combine all of these together. \n\n```haskell\ngnina r5 o5 \n  (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins)\n  (p2rank r4 o4 (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins))\n  (flatten (auto3D r1 o1 (map smi list_of_smols)))\n```\n\nWhen we look at everything together we notice that some of our functions are already hatched. While others aren’t. This is mostly due to their expected computational intensity. Less intense functions like `gnina`, `p2rank`, and `auto3D` are batched whereas more intense functions like `colabfold` and `mmseqs2` are not batched.\n\nThe `gnina` function looks like this:\n\n```haskell\ngnina : RunSpec -> GninaOptions -> [Conformer] -> [[BindingSite]] -> [Conformer]\ngnina run_spec opts proteins binding_sites smols = -- impl details ...\n```\n\nOur expression above will call `gnina` for every small molecule against every binding site found for every protein. \n\nBut, our expression is inefficient. As written, it will run mmseqs2 and colabfold twice. We can make this better by using a lambda:\n\n```haskell\n(\\ps ->\n  gnina r5 o5 \n    ps\n    (p2rank r4 o4 ps)\n    (flatten (auto3D r1 o1 (map smi list_of_smols))))\n  (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins)\n```\n\nThis will run the sequence alignment and folding functions once, assign it to the variable `ps` and then re-use `ps`.\n\n(Note: this is not strictly necessary, as Rex is capable of not recomputing expressions that are identical to previously computing expressions, but it is good practice nonetheless because we may change how we get the protein conformers. Without the lambda, we would have to make this change in multiple places. With the lambda, we only have to make it in one place.)\n\n## Making it reusable\n\nThis is a very simple virtual screening protocol that allows us to predict structures, predict binding sites, and then dock a set of small molecules against these structures and binding sites. \n\nBut right now, it uses hardcoded variables. What if we want to share this protocol with others, and allow them to use it for their own list of proteins and small molecules?\n\nThis is where we can rely on *currying*. This is where we call a function with fewer arguments than it expects, resulting in a function that can be called by others, still expecting more arguments. Changing our expression in this way is trivial:\n\n```haskell\n(\\ps smols ->\n  gnina r5 o5 \n    ps\n    (p2rank r4 o4 ps)\n    (flatten (auto3D r1 o1 (map smi smols))))\n. map (colabfold r3 o3 . mmseqs2 r2 o2 . seq)\n```\n\nWhen evaluating this expression, Rex will return a function that expects 2 outstanding arguments: a list of proteins and a list of small molecules. \n\nWhy? Because the expression `map (colabfold r3 o3 . mmseqs2 r2 o2 . seq)` (let’s call it `g`) expects 1 argument. When we `.` this expression with the lambda expression (let’s call it `f`) we get `(f . g) x = f (g x)` by the definition of `.`. \n\nSince `f` expect multiple arguments, call `f (g x))` itself returns a function that expects the result of the arguments, namely `smols`.\n\nSo our expression defines a function that accepts a list of proteins, then a list of smols, and returns the results of docking all smols against all binding sites of all proteins.\n\nPhew!\n\nRight now, this syntax is a little arcane and difficult for humans to write. However, as Rex evolves we can make it a little easier to work with.\n\n# More Advanced Screening\n\nAssuming the binding site is defined as follows:\n\n```haskell\ntype BindingSite = BindingSite {\n  bb_min: (f64, f64, f64)\n  bb_max: (f64, f64, f64)\n  confidence: f64\n}\n```\n\nWe can improve our protocol by filtering bad binding sites:\n\n```haskell\n(\\ps proteins smols ->\n  gnina r5 o5 \n    ps\n    (filter ((>) 0.8 . confidence) (p2rank r4 o4 ps))\n    (flatten (auto3D r1 o1 (map smi smols))))\n. map (colabfold r3 o3 . mmseqs2 r2 o2 . seq)\n```\n\nAnd we can also optimise the outputs of `auto3D` by measuring their energies with a more accurate calculation, and then picking the lowest ones. Let’s assume the `exess_min` function minimises the structure and has the following type:\n\n```haskell\nexess_min : RunSpec -> ExessEminOptions -> [Conformer] -> [(Conformer, QMOutput)]\n```\n\nThen we get the following insanity:\n\n```haskell\n(\\conformers proteins smols ->\n   gnina r5 o5 \n     conformers\n     (filter\n        ((>) 0.8 . confidence)\n        (p2rank r4 o4 conformers))\n     (map\n        (head . sort (total_energy . get 1))\n        (map \n           (map (exess_min r5 o5))\n           (auto3D r1 o1 (map smi smols)))))\n . map (colabfold r3 o3 . mmseqs2 r2 o2 . seq)\n```\n\n### Sidenote\n\n<aside>\n⚠\uFE0F This section is not currently supported by Rex and can be thought of as a list of to-dos. However, it’s all syntactical, requiring no changes to the execution engine.\n\n</aside>\n\nAt this point we have achieved a of parentheses and reading our code has gotten a little out of hand. So it’s probably time to define a very low precedence left-associative operator `$` that is defined:\n\n```haskell\n($) f x = f x\n\n-- then\nf $ g x $ h y\n\n-- would be equivalent to\nf (g x) $ h y\n\n-- which is\nf (g x) (h y)\n```\n\nIt has no functional effect other than abusing operator precedence to beaten up code. Which, in fairness, is what operator precedence is all about.\n\n```haskell\n(\\ps proteins smols ->\n    gnina r5 o5 \n      ps\n      (filter\n       $ (>) 0.8 . confidence\n       $ p2rank r4 o4 ps)\n      (map \n       $ head \n         . sort (total_energy . get 1)\n         . (map $ exess_min r5 o5)\n       $ (auto3D r1 o1\n          $ map smi smols)))\n . map \n   $ colabfold r3 o3\n     . mmseqs2 r2 o2\n     . seq\n```\n\nI’m not sure that this is much more readable, but it definitely has fewer parentheses.\n\nWe should seriously about `let` bindings to further simplify the above:\n\n```haskell\nlet \n  sort_by_total_energy = sort   (total_energy . get 1),\n  filter_by_confidence = filter ((>) 0.8 . confidence),\n  map_exess_min        = map    (exess_min r5 o5),\n  map_auto3D           = auto3D r1 o1 . map smi,\nin\n  (\\ps proteins smols ->\n    gnina r5 o5 ps\n      (filter_by_confidence\n       $ p2rank r4 o4 ps)\n      (map \n       $ head\n         . sort_by_total_energy\n         . map_exess_min\n       $ map_auto3D smols))\n   . map\n     $ colabfold r3 o3\n       . mmseqs2 r2 o2\n       . seq\n```\n\nThis is probably as good as we are going to get it. Using `let` has allowed us to avoid too many parentheses but also to avoid too many `$` which look ugly and are hard to keep track of when there’s more than one in any given expression.\n\nOverall, it’s pretty good! \n\nOther than the lack of `do` statements (which are an affront to all that is beautiful), this should be very familiar to any functional programmer. One major advantage of this syntax is that programmers (and LLMs) can learn Rex (and its crazy concepts) by learning intermediate-level Haskell (no lazy evaluation or type-classes).\n\n# Another examples\n\n```haskell\nlet \n  best_pose   = head $ rxdock protein_conformer smol_conformer,\n  simulation  = openmm $ merge_conformers protein_conformer best_pose,\n  frames      = dry_frames simulation,\n  best_frames = tica frames,\nin\n  (+)\n    avg (map (total_energy . pbsa) frames)\n    avg (map (total_energy . nnff) best_frames))\n```",
  "prepare_protein": "prepared_protein = (get \"Ok\" (get 0 (await (get 1 \n    ( prepare_protein_rex\n      (json '{\"resources\":{\"cpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{}'))\n      (arg [[ (upload (json protein_sequence)) ]])\n    )\n  ))))",
  "auto3d": "(get \"Ok\" (get 0 (await (get 1 \n    ( auto3d_rex\n      (json '{\"resources\":{\"gpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{\"k\":1}'))\n      (arg [\"CCCC\"])\n    )\n  ))))",
  "gnina": "gnina_rex_template",
  "gmx": "Still in progress, please check other module first.",
  "comprehensive_example": "let\n  smiles = [\"CCCC\", \"CCCN\", \"CCCO\"],\n  protein_sequence = \"MKVLLAAVILGVVIGAIVFGIPGK\",\n\n  auto3d_result = (get \"Ok\" (get 0 (await (get 1 \n    ( auto3d_rex\n      (json '{\"resources\":{\"gpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet2\"}')\n      (arg (json '{\"k\":1}'))\n      (arg smiles)\n    )\n  )))),\n\n  prepared_protein = (get \"Ok\" (get 0 (await (get 1 \n    ( prepare_protein_rex\n      (json '{\"resources\":{\"cpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{}'))\n      (arg [[ (upload (json protein_sequence)) ]])\n    )\n  )))),\n\n  p2rank_result = (get \"Ok\" (get 0 (await (get 1 \n    ( p2rank_rex\n      (json '{\"resources\":{\"cpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{\"use_alphafold_config\":false}'))\n      (arg prepared_protein)\n    )\n  )))),\n\n  gnina_result = (get \"Ok\" (get 0 (await (get 1 \n    ( gnina_rex\n      (json '{\"resources\":{\"gpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet2\"}')\n      (arg (json '{\"num_modes\":10,\"exhaustiveness\":8}'))\n      (arg prepared_protein)\n      (arg [(get 0 (get 0 p2rank_result))])\n      (arg auto3d_result)\n      (arg [])\n    )\n  ))))\n\nin\n  {\n    auto3d_conformers: auto3d_result,\n    prepared_protein: prepared_protein,\n    binding_sites: p2rank_result,\n    docking_results: gnina_result\n  }",
  "hackthon_task": "Task One: Correlation Coefficient Calculation\n\nFrom the dataset we provide, select specific BTK proteins and their corresponding ligands in SMILES format.\nRun the in-silico protocol on the RUSH platform to obtain and record the final simulated affinity values or other potential reference values.\nUse the provided benchmark function to calculate the correlation coefficient between the simulated affinity values and the experimental affinity values in the dataset to assess the accuracy of the simulation.\nTask Two: RMSD Calculation\n\nWe will provide a set of protein structures (without ligands) and a series of ligands in SMILES format.\nParticipants need to predict the protein-ligand complex structures, run the in-silico protocol on the RUSH platform, and generate simulated PDB files.\nUse the benchmark function; our provided benchmark function will automatically align the generated protein structures and calculate the RMSD values compared to the actual crystal structures to assess the consistency of the structure prediction.",
  "gnina_parameter": "protein_conformer: Object[Conformer];\noriginal_ligand_conformer: Object[Conformer];\nligands_conformers: Object[[Conformer]];\ngnina_options: GninaOptions {\n    minimise: bool?,\n    num_modes: u32?,\n    autobox: f32?,\n    exhaustiveness: u32?,\n    docking_site: GninaDockingSite {\n        center_x: f32,\n        size_y: f32,\n        size_x: f32,\n        center_y: f32,\n        center_z: f32,\n        size_z: f32\n    }?\n}?\n->\nresults: Object {\n    path: @[[GninaResult {\n        score: GninaScore {\n            cnn_score: f32,\n            affinity: f32,\n            cnn_affinity: f32,\n            mode: i32\n        },\n        ligand: Conformer {\n            amino_acid_seq_ids: [i32]?,\n            amino_acid_labels: [Label {u32, string}]?,\n            residue_insertion_codes: [string]?,\n            amino_acid_insertion_codes: [string]?,\n            residue_labels: [Label {u32, string}]?,\n            amino_acids: [[u32]]?,\n            residue_seq: [string]?,\n            binding_site_interactions: [BindingSiteInteraction {\n                ligand_atom_idx: u32?,\n                receptor_atom_idx: u32?,\n                ligand_xyz: [f32]?,\n                ligand_residue_idx: u32,\n                receptor_amino_acid_idx: u32,\n                receptor_is_positively_charged: bool,\n                receptor_is_donor: bool,\n                receptor_xyz: [f32]?,\n                pi_stack_kind: PiStackKind[P | T]?,\n                receptor_is_charged: bool\n            }]?,\n            residues: [[u32]]?,\n            subunits: [[u32]]?,\n            topology: Topology {\n                connectivity: [Bond {u32, u32, u8}]?,\n                formal_charges: [i8]?,\n                fragments: [[u32]]?,\n                fragment_multiplicities: [i8]?,\n                atom_charges: [i8]?,\n                fragment_charges: [i8]?,\n                velocities: [f32]?,\n                alts: [Alt {u32, [u32]}]?,\n                atom_labels: [string]?,\n                fragment_partial_charges: [f32]?,\n                geometry: [f32],\n                fragment_formal_charges: [i8]?,\n                partial_charges: [f32]?,\n                labels: [string]?,\n                version: TopologyVersion[V0 | V1]?\n            },\n            residue_seq_ids: [i32]?\n        }\n    }]],\n    size: u32,\n    format: ObjectFormat[json | bin]?\n}\n\nParameters\n\nprotein_conformer: protein conformer\noriginal_ligand_conformer: optional reference ligand for binding site\nligands_conformers: ligand conformers\ngnina_options: Within the GninaOptions;\nThe exhaustiveness would determine the search extent for the docking algorithm.\nThe num_modes would determine the number of dock poses to report.\nThe minimise argument would determine whether to minimise the energy of the final pose.\nThe docking_site would be for specifying where to dock the ligand to.\nReturns\n\na list of ligand conformers and their scores",
  "auto3d_parameter": "molecule_file: Object[@$Bytes];\nmolecule_file_type: string;\noptions: Auto3dOptions {\n    window: f32?,\n    memory: u32?,\n    capacity: u32?,\n    patience: u32?,\n    opt_steps: u32?,\n    convergence_threshold: f32?,\n    k: i32?,\n    mpi_np: u32?,\n    threshold: f32?,\n    use_gpu: bool?,\n    enumerate_tautomer: bool?,\n    job_name: string?,\n    enumerate_isomer: bool?,\n    verbose: bool?,\n    max_confs: u32?,\n    optimizing_engine: Auto3dOptimizingEngines[ANI2x | ANI2xt | AIMNET]?,\n    gpu_idx: [u32]?\n}\n->\nconformer_sdf: Object[@$SDF];\nconformers: Object[[Conformer]]\n\nParameters\n\nmolecule_file: The input molecules as a file; either one SMILES string per line, or an SDF\nmolecule_file_type: The string 'smi' or 'sdf', depending on the input type\noptions: A dict with options to pass; see auto3d docs for details\nReturns\n\nA sdf file containing the ligand(s)'s conformers\n\nReturns\n\nA vec of qdxf conformers"
}